(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _isReactNative = _interopRequireDefault(require("./isReactNative"));

var _uriToBlob = _interopRequireDefault(require("./uriToBlob"));

var _FileSource = _interopRequireDefault(require("./sources/FileSource"));

var _StreamSource = _interopRequireDefault(require("./sources/StreamSource"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

var FileReader = /*#__PURE__*/function () {
  function FileReader() {
    _classCallCheck(this, FileReader);
  }

  _createClass(FileReader, [{
    key: "openFile",
    value: function openFile(input, chunkSize) {
      // In React Native, when user selects a file, instead of a File or Blob,
      // you usually get a file object {} with a uri property that contains
      // a local path to the file. We use XMLHttpRequest to fetch
      // the file blob, before uploading with tus.
      if ((0, _isReactNative["default"])() && input && typeof input.uri !== 'undefined') {
        return (0, _uriToBlob["default"])(input.uri).then(function (blob) {
          return new _FileSource["default"](blob);
        })["catch"](function (err) {
          throw new Error("tus: cannot fetch `file.uri` as Blob, make sure the uri is correct and accessible. ".concat(err));
        });
      } // Since we emulate the Blob type in our tests (not all target browsers
      // support it), we cannot use `instanceof` for testing whether the input value
      // can be handled. Instead, we simply check is the slice() function and the
      // size property are available.


      if (typeof input.slice === 'function' && typeof input.size !== 'undefined') {
        return Promise.resolve(new _FileSource["default"](input));
      }

      if (typeof input.read === 'function') {
        chunkSize = Number(chunkSize);

        if (!Number.isFinite(chunkSize)) {
          return Promise.reject(new Error('cannot create source for stream without a finite value for the `chunkSize` option'));
        }

        return Promise.resolve(new _StreamSource["default"](input, chunkSize));
      }

      return Promise.reject(new Error('source object may only be an instance of File, Blob, or Reader in this environment'));
    }
  }]);

  return FileReader;
}();

exports["default"] = FileReader;

},{"./isReactNative":5,"./sources/FileSource":6,"./sources/StreamSource":7,"./uriToBlob":10}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = fingerprint;

var _isReactNative = _interopRequireDefault(require("./isReactNative"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
} // TODO: Differenciate between input types

/**
 * Generate a fingerprint for a file which will be used the store the endpoint
 *
 * @param {File} file
 * @param {Object} options
 * @param {Function} callback
 */


function fingerprint(file, options) {
  if ((0, _isReactNative["default"])()) {
    return Promise.resolve(reactNativeFingerprint(file, options));
  }

  return Promise.resolve(['tus-br', file.name, file.type, file.size, file.lastModified, options.endpoint].join('-'));
}

function reactNativeFingerprint(file, options) {
  var exifHash = file.exif ? hashCode(JSON.stringify(file.exif)) : 'noexif';
  return ['tus-rn', file.name || 'noname', file.size || 'nosize', exifHash, options.endpoint].join('/');
}

function hashCode(str) {
  /* eslint-disable no-bitwise */
  // from https://stackoverflow.com/a/8831937/151666
  var hash = 0;

  if (str.length === 0) {
    return hash;
  }

  for (var i = 0; i < str.length; i++) {
    var _char = str.charCodeAt(i);

    hash = (hash << 5) - hash + _char;
    hash &= hash; // Convert to 32bit integer
  }

  return hash;
}

},{"./isReactNative":5}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
/* eslint-disable max-classes-per-file */


var XHRHttpStack = /*#__PURE__*/function () {
  function XHRHttpStack() {
    _classCallCheck(this, XHRHttpStack);
  }

  _createClass(XHRHttpStack, [{
    key: "createRequest",
    value: function createRequest(method, url) {
      return new Request(method, url);
    }
  }, {
    key: "getName",
    value: function getName() {
      return 'XHRHttpStack';
    }
  }]);

  return XHRHttpStack;
}();

exports["default"] = XHRHttpStack;

var Request = /*#__PURE__*/function () {
  function Request(method, url) {
    _classCallCheck(this, Request);

    this._xhr = new XMLHttpRequest();

    this._xhr.open(method, url, true);

    this._method = method;
    this._url = url;
    this._headers = {};
  }

  _createClass(Request, [{
    key: "getMethod",
    value: function getMethod() {
      return this._method;
    }
  }, {
    key: "getURL",
    value: function getURL() {
      return this._url;
    }
  }, {
    key: "setHeader",
    value: function setHeader(header, value) {
      this._xhr.setRequestHeader(header, value);

      this._headers[header] = value;
    }
  }, {
    key: "getHeader",
    value: function getHeader(header) {
      return this._headers[header];
    }
  }, {
    key: "setProgressHandler",
    value: function setProgressHandler(progressHandler) {
      // Test support for progress events before attaching an event listener
      if (!('upload' in this._xhr)) {
        return;
      }

      this._xhr.upload.onprogress = function (e) {
        if (!e.lengthComputable) {
          return;
        }

        progressHandler(e.loaded);
      };
    }
  }, {
    key: "send",
    value: function send() {
      var _this = this;

      var body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      return new Promise(function (resolve, reject) {
        _this._xhr.onload = function () {
          resolve(new Response(_this._xhr));
        };

        _this._xhr.onerror = function (err) {
          reject(err);
        };

        _this._xhr.send(body);
      });
    }
  }, {
    key: "abort",
    value: function abort() {
      this._xhr.abort();

      return Promise.resolve();
    }
  }, {
    key: "getUnderlyingObject",
    value: function getUnderlyingObject() {
      return this._xhr;
    }
  }]);

  return Request;
}();

var Response = /*#__PURE__*/function () {
  function Response(xhr) {
    _classCallCheck(this, Response);

    this._xhr = xhr;
  }

  _createClass(Response, [{
    key: "getStatus",
    value: function getStatus() {
      return this._xhr.status;
    }
  }, {
    key: "getHeader",
    value: function getHeader(header) {
      return this._xhr.getResponseHeader(header);
    }
  }, {
    key: "getBody",
    value: function getBody() {
      return this._xhr.responseText;
    }
  }, {
    key: "getUnderlyingObject",
    value: function getUnderlyingObject() {
      return this._xhr;
    }
  }]);

  return Response;
}();

},{}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "DefaultHttpStack", {
  enumerable: true,
  get: function get() {
    return _httpStack["default"];
  }
});
Object.defineProperty(exports, "DetailedError", {
  enumerable: true,
  get: function get() {
    return _error["default"];
  }
});
exports.Upload = void 0;
Object.defineProperty(exports, "canStoreURLs", {
  enumerable: true,
  get: function get() {
    return _urlStorage.canStoreURLs;
  }
});
exports.defaultOptions = void 0;
Object.defineProperty(exports, "enableDebugLog", {
  enumerable: true,
  get: function get() {
    return _logger.enableDebugLog;
  }
});
exports.isSupported = void 0;

var _upload = _interopRequireDefault(require("../upload"));

var _noopUrlStorage = _interopRequireDefault(require("../noopUrlStorage"));

var _logger = require("../logger");

var _error = _interopRequireDefault(require("../error"));

var _urlStorage = require("./urlStorage");

var _httpStack = _interopRequireDefault(require("./httpStack"));

var _fileReader = _interopRequireDefault(require("./fileReader"));

var _fileSignature = _interopRequireDefault(require("./fileSignature"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var defaultOptions = _objectSpread(_objectSpread({}, _upload["default"].defaultOptions), {}, {
  httpStack: new _httpStack["default"](),
  fileReader: new _fileReader["default"](),
  urlStorage: _urlStorage.canStoreURLs ? new _urlStorage.WebStorageUrlStorage() : new _noopUrlStorage["default"](),
  fingerprint: _fileSignature["default"]
});

exports.defaultOptions = defaultOptions;

var Upload = /*#__PURE__*/function (_BaseUpload) {
  _inherits(Upload, _BaseUpload);

  var _super = _createSuper(Upload);

  function Upload() {
    var file = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Upload);

    options = _objectSpread(_objectSpread({}, defaultOptions), options);
    return _super.call(this, file, options);
  }

  _createClass(Upload, null, [{
    key: "terminate",
    value: function terminate(url) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      options = _objectSpread(_objectSpread({}, defaultOptions), options);
      return _upload["default"].terminate(url, options);
    }
  }]);

  return Upload;
}(_upload["default"]);

exports.Upload = Upload;
var _window = window,
    XMLHttpRequest = _window.XMLHttpRequest,
    Blob = _window.Blob;
var isSupported = XMLHttpRequest && Blob && typeof Blob.prototype.slice === 'function';
exports.isSupported = isSupported;

},{"../error":12,"../logger":13,"../noopUrlStorage":14,"../upload":15,"./fileReader":1,"./fileSignature":2,"./httpStack":3,"./urlStorage":11}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var isReactNative = function isReactNative() {
  return typeof navigator !== 'undefined' && typeof navigator.product === 'string' && navigator.product.toLowerCase() === 'reactnative';
};

var _default = isReactNative;
exports["default"] = _default;

},{}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _isCordova = _interopRequireDefault(require("./isCordova"));

var _readAsByteArray = _interopRequireDefault(require("./readAsByteArray"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

var FileSource = /*#__PURE__*/function () {
  // Make this.size a method
  function FileSource(file) {
    _classCallCheck(this, FileSource);

    this._file = file;
    this.size = file.size;
  }

  _createClass(FileSource, [{
    key: "slice",
    value: function slice(start, end) {
      // In Apache Cordova applications, a File must be resolved using
      // FileReader instances, see
      // https://cordova.apache.org/docs/en/8.x/reference/cordova-plugin-file/index.html#read-a-file
      if ((0, _isCordova["default"])()) {
        return (0, _readAsByteArray["default"])(this._file.slice(start, end));
      }

      var value = this._file.slice(start, end);

      return Promise.resolve({
        value: value
      });
    }
  }, {
    key: "close",
    value: function close() {// Nothing to do here since we don't need to release any resources.
    }
  }]);

  return FileSource;
}();

exports["default"] = FileSource;

},{"./isCordova":8,"./readAsByteArray":9}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function len(blobOrArray) {
  if (blobOrArray === undefined) return 0;
  if (blobOrArray.size !== undefined) return blobOrArray.size;
  return blobOrArray.length;
}
/*
  Typed arrays and blobs don't have a concat method.
  This function helps StreamSource accumulate data to reach chunkSize.
*/


function concat(a, b) {
  if (a.concat) {
    // Is `a` an Array?
    return a.concat(b);
  }

  if (a instanceof Blob) {
    return new Blob([a, b], {
      type: a.type
    });
  }

  if (a.set) {
    // Is `a` a typed array?
    var c = new a.constructor(a.length + b.length);
    c.set(a);
    c.set(b, a.length);
    return c;
  }

  throw new Error('Unknown data type');
}

var StreamSource = /*#__PURE__*/function () {
  function StreamSource(reader) {
    _classCallCheck(this, StreamSource);

    this._buffer = undefined;
    this._bufferOffset = 0;
    this._reader = reader;
    this._done = false;
  }

  _createClass(StreamSource, [{
    key: "slice",
    value: function slice(start, end) {
      if (start < this._bufferOffset) {
        return Promise.reject(new Error("Requested data is before the reader's current offset"));
      }

      return this._readUntilEnoughDataOrDone(start, end);
    }
  }, {
    key: "_readUntilEnoughDataOrDone",
    value: function _readUntilEnoughDataOrDone(start, end) {
      var _this = this;

      var hasEnoughData = end <= this._bufferOffset + len(this._buffer);

      if (this._done || hasEnoughData) {
        var value = this._getDataFromBuffer(start, end);

        var done = value == null ? this._done : false;
        return Promise.resolve({
          value: value,
          done: done
        });
      }

      return this._reader.read().then(function (_ref) {
        var value = _ref.value,
            done = _ref.done;

        if (done) {
          _this._done = true;
        } else if (_this._buffer === undefined) {
          _this._buffer = value;
        } else {
          _this._buffer = concat(_this._buffer, value);
        }

        return _this._readUntilEnoughDataOrDone(start, end);
      });
    }
  }, {
    key: "_getDataFromBuffer",
    value: function _getDataFromBuffer(start, end) {
      // Remove data from buffer before `start`.
      // Data might be reread from the buffer if an upload fails, so we can only
      // safely delete data when it comes *before* what is currently being read.
      if (start > this._bufferOffset) {
        this._buffer = this._buffer.slice(start - this._bufferOffset);
        this._bufferOffset = start;
      } // If the buffer is empty after removing old data, all data has been read.


      var hasAllDataBeenRead = len(this._buffer) === 0;

      if (this._done && hasAllDataBeenRead) {
        return null;
      } // We already removed data before `start`, so we just return the first
      // chunk from the buffer.


      return this._buffer.slice(0, end - start);
    }
  }, {
    key: "close",
    value: function close() {
      if (this._reader.cancel) {
        this._reader.cancel();
      }
    }
  }]);

  return StreamSource;
}();

exports["default"] = StreamSource;

},{}],8:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var isCordova = function isCordova() {
  return typeof window !== 'undefined' && (typeof window.PhoneGap !== 'undefined' || typeof window.Cordova !== 'undefined' || typeof window.cordova !== 'undefined');
};

var _default = isCordova;
exports["default"] = _default;

},{}],9:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = readAsByteArray;
/**
 * readAsByteArray converts a File object to a Uint8Array.
 * This function is only used on the Apache Cordova platform.
 * See https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-file/index.html#read-a-file
 */

function readAsByteArray(chunk) {
  return new Promise(function (resolve, reject) {
    var reader = new FileReader();

    reader.onload = function () {
      var value = new Uint8Array(reader.result);
      resolve({
        value: value
      });
    };

    reader.onerror = function (err) {
      reject(err);
    };

    reader.readAsArrayBuffer(chunk);
  });
}

},{}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = uriToBlob;
/**
 * uriToBlob resolves a URI to a Blob object. This is used for
 * React Native to retrieve a file (identified by a file://
 * URI) as a blob.
 */

function uriToBlob(uri) {
  return new Promise(function (resolve, reject) {
    var xhr = new XMLHttpRequest();
    xhr.responseType = 'blob';

    xhr.onload = function () {
      var blob = xhr.response;
      resolve(blob);
    };

    xhr.onerror = function (err) {
      reject(err);
    };

    xhr.open('GET', uri);
    xhr.send();
  });
}

},{}],11:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.canStoreURLs = exports.WebStorageUrlStorage = void 0;

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

var hasStorage = false;

try {
  hasStorage = 'localStorage' in window; // Attempt to store and read entries from the local storage to detect Private
  // Mode on Safari on iOS (see #49)

  var key = 'tusSupport';
  localStorage.setItem(key, localStorage.getItem(key));
} catch (e) {
  // If we try to access localStorage inside a sandboxed iframe, a SecurityError
  // is thrown. When in private mode on iOS Safari, a QuotaExceededError is
  // thrown (see #49)
  if (e.code === e.SECURITY_ERR || e.code === e.QUOTA_EXCEEDED_ERR) {
    hasStorage = false;
  } else {
    throw e;
  }
}

var canStoreURLs = hasStorage;
exports.canStoreURLs = canStoreURLs;

var WebStorageUrlStorage = /*#__PURE__*/function () {
  function WebStorageUrlStorage() {
    _classCallCheck(this, WebStorageUrlStorage);
  }

  _createClass(WebStorageUrlStorage, [{
    key: "findAllUploads",
    value: function findAllUploads() {
      var results = this._findEntries('tus::');

      return Promise.resolve(results);
    }
  }, {
    key: "findUploadsByFingerprint",
    value: function findUploadsByFingerprint(fingerprint) {
      var results = this._findEntries("tus::".concat(fingerprint, "::"));

      return Promise.resolve(results);
    }
  }, {
    key: "removeUpload",
    value: function removeUpload(urlStorageKey) {
      localStorage.removeItem(urlStorageKey);
      return Promise.resolve();
    }
  }, {
    key: "addUpload",
    value: function addUpload(fingerprint, upload) {
      var id = Math.round(Math.random() * 1e12);
      var key = "tus::".concat(fingerprint, "::").concat(id);
      localStorage.setItem(key, JSON.stringify(upload));
      return Promise.resolve(key);
    }
  }, {
    key: "_findEntries",
    value: function _findEntries(prefix) {
      var results = [];

      for (var i = 0; i < localStorage.length; i++) {
        var _key = localStorage.key(i);

        if (_key.indexOf(prefix) !== 0) continue;

        try {
          var upload = JSON.parse(localStorage.getItem(_key));
          upload.urlStorageKey = _key;
          results.push(upload);
        } catch (e) {// The JSON parse error is intentionally ignored here, so a malformed
          // entry in the storage cannot prevent an upload.
        }
      }

      return results;
    }
  }]);

  return WebStorageUrlStorage;
}();

exports.WebStorageUrlStorage = WebStorageUrlStorage;

},{}],12:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

var DetailedError = /*#__PURE__*/function (_Error) {
  _inherits(DetailedError, _Error);

  var _super = _createSuper(DetailedError);

  function DetailedError(message) {
    var _this;

    var causingErr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var req = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var res = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

    _classCallCheck(this, DetailedError);

    _this = _super.call(this, message);
    _this.originalRequest = req;
    _this.originalResponse = res;
    _this.causingError = causingErr;

    if (causingErr != null) {
      message += ", caused by ".concat(causingErr.toString());
    }

    if (req != null) {
      var requestId = req.getHeader('X-Request-ID') || 'n/a';
      var method = req.getMethod();
      var url = req.getURL();
      var status = res ? res.getStatus() : 'n/a';
      var body = res ? res.getBody() || '' : 'n/a';
      message += ", originated from request (method: ".concat(method, ", url: ").concat(url, ", response code: ").concat(status, ", response text: ").concat(body, ", request id: ").concat(requestId, ")");
    }

    _this.message = message;
    return _this;
  }

  return _createClass(DetailedError);
}( /*#__PURE__*/_wrapNativeSuper(Error));

var _default = DetailedError;
exports["default"] = _default;

},{}],13:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.enableDebugLog = enableDebugLog;
exports.log = log;
/* eslint no-console: "off" */

var isEnabled = false;

function enableDebugLog() {
  isEnabled = true;
}

function log(msg) {
  if (!isEnabled) return;
  console.log(msg);
}

},{}],14:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
/* eslint no-unused-vars: "off" */


var NoopUrlStorage = /*#__PURE__*/function () {
  function NoopUrlStorage() {
    _classCallCheck(this, NoopUrlStorage);
  }

  _createClass(NoopUrlStorage, [{
    key: "listAllUploads",
    value: function listAllUploads() {
      return Promise.resolve([]);
    }
  }, {
    key: "findUploadsByFingerprint",
    value: function findUploadsByFingerprint(fingerprint) {
      return Promise.resolve([]);
    }
  }, {
    key: "removeUpload",
    value: function removeUpload(urlStorageKey) {
      return Promise.resolve();
    }
  }, {
    key: "addUpload",
    value: function addUpload(fingerprint, upload) {
      return Promise.resolve(null);
    }
  }]);

  return NoopUrlStorage;
}();

exports["default"] = NoopUrlStorage;

},{}],15:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _jsBase = require("js-base64");

var _urlParse = _interopRequireDefault(require("url-parse"));

var _error = _interopRequireDefault(require("./error"));

var _logger = require("./logger");

var _uuid = _interopRequireDefault(require("./uuid"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

var defaultOptions = {
  endpoint: null,
  uploadUrl: null,
  metadata: {},
  fingerprint: null,
  uploadSize: null,
  onProgress: null,
  onChunkComplete: null,
  onSuccess: null,
  onError: null,
  _onUploadUrlAvailable: null,
  overridePatchMethod: false,
  headers: {},
  addRequestId: false,
  onBeforeRequest: null,
  onAfterResponse: null,
  onShouldRetry: null,
  chunkSize: Infinity,
  retryDelays: [0, 1000, 3000, 5000],
  parallelUploads: 1,
  splitSizeIntoParts: null,
  // If set, wait for one partial parallel upload chunk to reach this percentage
  // before resuming the next partial upload.
  staggerPercent: null,
  storeFingerprintForResuming: true,
  removeFingerprintOnSuccess: false,
  uploadLengthDeferred: false,
  uploadDataDuringCreation: false,
  urlStorage: null,
  fileReader: null,
  httpStack: null
};

var BaseUpload = /*#__PURE__*/function () {
  function BaseUpload(file, options) {
    _classCallCheck(this, BaseUpload); // Warn about removed options from previous versions


    if ('resume' in options) {
      console.log('tus: The `resume` option has been removed in tus-js-client v2. Please use the URL storage API instead.'); // eslint-disable-line no-console
    } // The default options will already be added from the wrapper classes.


    this.options = options; // Cast chunkSize to integer

    this.options.chunkSize = Number(this.options.chunkSize); // The storage module used to store URLs

    this._urlStorage = this.options.urlStorage; // The underlying File/Blob object

    this.file = file; // The URL against which the file will be uploaded

    this.url = null; // The underlying request object for the current PATCH request

    this._req = null; // The fingerpinrt for the current file (set after start())

    this._fingerprint = null; // The key that the URL storage returned when saving an URL with a fingerprint,

    this._urlStorageKey = null; // The offset used in the current PATCH request

    this._offset = null; // True if the current PATCH request has been aborted

    this._aborted = false; // The file's size in bytes

    this._size = null; // The Source object which will wrap around the given file and provides us
    // with a unified interface for getting its size and slice chunks from its
    // content allowing us to easily handle Files, Blobs, Buffers and Streams.

    this._source = null; // The current count of attempts which have been made. Zero indicates none.

    this._retryAttempt = 0; // The timeout's ID which is used to delay the next retry

    this._retryTimeout = null; // The offset of the remote upload before the latest attempt was started.

    this._offsetBeforeRetry = 0; // An array of BaseUpload instances which are used for uploading the different
    // parts, if the parallelUploads option is used.

    this._parallelUploads = null; // A custom function for splitting the upload size into parts, if the
    // parallelUploads option is used.

    this._splitSizeIntoParts = null; // An array of upload URLs which are used for uploading the different
    // parts, if the parallelUploads option is used.

    this._parallelUploadUrls = null; // If a partial upload, the current chunk object that this partial upload is
    // uploading.

    this._currentChunk = null; // Whether this is an initial upload, or subtasks initiated in
    // _startParallelUpload.

    this._initialUpload = true;
  }
  /**
   * Use the Termination extension to delete an upload from the server by sending a DELETE
   * request to the specified upload URL. This is only possible if the server supports the
   * Termination extension. If the `options.retryDelays` property is set, the method will
   * also retry if an error ocurrs.
   *
   * @param {String} url The upload's URL which will be terminated.
   * @param {object} options Optional options for influencing HTTP requests.
   * @return {Promise} The Promise will be resolved/rejected when the requests finish.
   */


  _createClass(BaseUpload, [{
    key: "findPreviousUploads",
    value: function findPreviousUploads() {
      var _this = this;

      return this.options.fingerprint(this.file, this.options).then(function (fingerprint) {
        return _this._urlStorage.findUploadsByFingerprint(fingerprint);
      });
    }
  }, {
    key: "resumeFromPreviousUpload",
    value: function resumeFromPreviousUpload(previousUpload) {
      this.url = previousUpload.uploadUrl || null;
      this._parallelUploadUrls = previousUpload.parallelUploadUrls || null;
      this._urlStorageKey = previousUpload.urlStorageKey;
    }
  }, {
    key: "start",
    value: function start() {
      var _this2 = this;

      var file = this.file;

      if (!file) {
        this._emitError(new Error('tus: no file or stream to upload provided'));

        return;
      }

      if (!this.options.endpoint && !this.options.uploadUrl && !this.url) {
        this._emitError(new Error('tus: neither an endpoint or an upload URL is provided'));

        return;
      }

      var retryDelays = this.options.retryDelays;

      if (retryDelays != null && Object.prototype.toString.call(retryDelays) !== '[object Array]') {
        this._emitError(new Error('tus: the `retryDelays` option must either be an array or null'));

        return;
      }

      if (this.options.parallelUploads > 1) {
        // Test which options are incompatible with parallel uploads.
        for (var _i = 0, _arr = ['uploadUrl', 'uploadSize', 'uploadLengthDeferred']; _i < _arr.length; _i++) {
          var optionName = _arr[_i];

          if (this.options[optionName]) {
            this._emitError(new Error("tus: cannot use the ".concat(optionName, " option when parallelUploads is enabled")));

            return;
          }
        }
      }

      if (this.options.staggerPercent !== null) {
        if (this._initialUpload && this.options.parallelUploads <= 1) {
          this._emitError(new Error("tus: cannot use the staggerPercent option when parallelUploads is disabled"));
        }
      }

      if (this.options.splitSizeIntoParts !== null) {
        if (this.options.parallelUploads <= 1) {
          this._emitError(new Error("tus: cannot use the splitSizeIntoParts option when parallelUploads is disabled"));
        }
      }

      this.options.fingerprint(file, this.options).then(function (fingerprint) {
        if (fingerprint == null) {
          (0, _logger.log)('No fingerprint was calculated meaning that the upload cannot be stored in the URL storage.');
        } else {
          (0, _logger.log)("Calculated fingerprint: ".concat(fingerprint));
        }

        _this2._fingerprint = fingerprint;

        if (_this2._source) {
          return _this2._source;
        }

        return _this2.options.fileReader.openFile(file, _this2.options.chunkSize);
      }).then(function (source) {
        _this2._source = source; // First, we look at the uploadLengthDeferred option.
        // Next, we check if the caller has supplied a manual upload size.
        // Finally, we try to use the calculated size from the source object.

        if (_this2.options.uploadLengthDeferred) {
          _this2._size = null;
        } else if (_this2.options.uploadSize != null) {
          _this2._size = Number(_this2.options.uploadSize);

          if (Number.isNaN(_this2._size)) {
            _this2._emitError(new Error('tus: cannot convert `uploadSize` option into a number'));

            return;
          }
        } else {
          _this2._size = _this2._source.size;

          if (_this2._size == null) {
            _this2._emitError(new Error("tus: cannot automatically derive upload's size from input. Specify it manually using the `uploadSize` option or use the `uploadLengthDeferred` option"));

            return;
          }
        } // If the upload was configured to use multiple requests or if we resume from
        // an upload which used multiple requests, we start a parallel upload.


        if (_this2.options.parallelUploads > 1 || _this2._parallelUploadUrls != null) {
          _this2._startParallelUpload();
        } else {
          _this2._startSingleUpload();
        }
      })["catch"](function (err) {
        _this2._emitError(err);
      });
    }
    /**
     * Initiate the uploading procedure for a parallelized upload, where one file is split into
     * multiple request which are run in parallel.
     *
     * @api private
     */

  }, {
    key: "_startParallelUpload",
    value: function _startParallelUpload() {
      var _this$options$splitSi,
          _this3 = this;

      var totalSize = this._size;
      var totalProgress = 0;
      var _this$options = this.options,
          chunkSize = _this$options.chunkSize,
          staggerPercent = _this$options.staggerPercent;
      this._parallelUploads = [];
      var partCount = this._parallelUploadUrls != null ? this._parallelUploadUrls.length : this.options.parallelUploads; // The input file will be split into multiple slices which are uploaded in separate
      // requests. Here we generate the start and end position for the slices.

      var splitSizeFn = (_this$options$splitSi = this.options.splitSizeIntoParts) !== null && _this$options$splitSi !== void 0 ? _this$options$splitSi : splitSizeIntoParts;
      var parts = splitSizeFn(this._source.size, partCount); // Attach URLs from previous uploads, if available.

      if (this._parallelUploadUrls) {
        parts.forEach(function (part, index) {
          part.uploadUrl = _this3._parallelUploadUrls[index] || null;
        });
      } // Create an empty list for storing the upload URLs


      this._parallelUploadUrls = new Array(parts.length);
      var firstChunk = null;
      var partsChunks = null;

      if (staggerPercent !== null) {
        // Generate a promise for each chunk that will be resolved when the respective
        // upload is completed.
        var _buildChunkStaggers = buildChunkStaggers(totalSize, parts.length, chunkSize);

        var _buildChunkStaggers2 = _slicedToArray(_buildChunkStaggers, 2);

        partsChunks = _buildChunkStaggers2[0];
        firstChunk = _buildChunkStaggers2[1];
      }

      var uploads = parts.map(function (part, index) {
        var lastPartProgress = 0;
        return _this3._source.slice(part.start, part.end).then(function (_ref) {
          var value = _ref.value;
          return new Promise(function (resolve, reject) {
            // Merge with the user supplied options but overwrite some values.
            var options = _objectSpread(_objectSpread({}, _this3.options), {}, {
              // If available, the partial upload should be resumed from a previous URL.
              uploadUrl: part.uploadUrl || null,
              // We take manually care of resuming for partial uploads, so they should
              // not be stored in the URL storage.
              storeFingerprintForResuming: false,
              removeFingerprintOnSuccess: false,
              // Reset the parallelUploads option to not cause recursion.
              parallelUploads: 1,
              // Reset parallel upload options. Keep the stagger option.
              splitSizeIntoParts: null,
              // Reset metadata.
              metadata: {},
              // Add the header to indicate the this is a partial upload.
              headers: _objectSpread(_objectSpread({}, _this3.options.headers), {}, {
                'Upload-Concat': 'partial'
              }),
              // Reject or resolve the promise if the upload errors or completes.
              onSuccess: resolve,
              onError: reject,
              // Wait until every partial upload has an upload URL, so we can add
              // them to the URL storage.
              _onUploadUrlAvailable: function _onUploadUrlAvailable() {
                _this3._parallelUploadUrls[index] = upload.url; // Test if all uploads have received an URL

                if (_this3._parallelUploadUrls.filter(function (u) {
                  return Boolean(u);
                }).length === parts.length) {
                  _this3._saveUploadInUrlStorage();
                }
              }
            });

            var upload = new BaseUpload(value, options); // Finalize the partial upload fields.

            upload.options.onProgress = function (newPartProgress) {
              // Based on the progress for this partial upload, calculate the progress
              // for the entire final upload.
              //
              // NOTE: This is called for each partial upload but `_emitProgress`
              // calls the `onProgress` method for the original upload.
              totalProgress = totalProgress - lastPartProgress + newPartProgress;
              lastPartProgress = newPartProgress; // Signal to the initial `BaseUpload` object.

              _this3._emitProgress(totalProgress, totalSize); // If a chunk stagger is set, signal to the other upload when it can
              // start uploading.


              if (staggerPercent !== null) {
                // Calculate stagger using the current chunk and not the
                // current part size.
                var chunk = upload._currentChunk;
                var chunkProgress = newPartProgress - chunkSize * chunk.indexInPart;
                var chunkPercent = chunkProgress / chunkSize * 100;
                var nextChunk = chunk.nextChunkStagger;

                if (nextChunk !== null && !nextChunk.resolved && chunkPercent >= staggerPercent) {
                  // The next partial upload that should start when this partial upload
                  // reaches the stagger for a chunk.
                  nextChunk.resolve();
                  nextChunk.resolved = true;
                }
              }
            };

            upload._initialUpload = false;
            var promise = Promise.resolve();

            if (staggerPercent !== null) {
              var currentChunk = partsChunks[index][0]; // Wait for the initial stagger for this chunk before starting the part.

              promise = currentChunk.promise;
              upload._currentChunk = currentChunk;
            }

            promise.then(function () {
              return upload.start();
            }); // Store the uploads in an array, so we can later abort them if necessary.

            _this3._parallelUploads.push(upload);
          });
        });
      });

      if (staggerPercent !== null) {
        // Kick off the first upload.
        firstChunk.resolve();
      }

      var req; // Wait until all partial uploads are finished and we can send the POST request for
      // creating the final upload.

      Promise.all(uploads).then(function () {
        req = _this3._openRequest('POST', _this3.options.endpoint);
        req.setHeader('Upload-Concat', "final;".concat(_this3._parallelUploadUrls.join(' '))); // Add metadata if values have been added

        var metadata = encodeMetadata(_this3.options.metadata);

        if (metadata !== '') {
          req.setHeader('Upload-Metadata', metadata);
        }

        return _this3._sendRequest(req, null);
      }).then(function (res) {
        if (!inStatusCategory(res.getStatus(), 200)) {
          _this3._emitHttpError(req, res, 'tus: unexpected response while creating upload');

          return;
        }

        var location = res.getHeader('Location');

        if (location == null) {
          _this3._emitHttpError(req, res, 'tus: invalid or missing Location header');

          return;
        }

        _this3.url = resolveUrl(_this3.options.endpoint, location);
        (0, _logger.log)("Created upload at ".concat(_this3.url));

        _this3._emitSuccess();
      })["catch"](function (err) {
        _this3._emitError(err);
      });
    }
    /**
     * Initiate the uploading procedure for a non-parallel upload. Here the entire file is
     * uploaded in a sequential matter.
     *
     * @api private
     */

  }, {
    key: "_startSingleUpload",
    value: function _startSingleUpload() {
      // Reset the aborted flag when the upload is started or else the
      // _performUpload will stop before sending a request if the upload has been
      // aborted previously.
      this._aborted = false; // The upload had been started previously and we should reuse this URL.

      if (this.url != null) {
        (0, _logger.log)("Resuming upload from previous URL: ".concat(this.url));

        this._resumeUpload();

        return;
      } // A URL has manually been specified, so we try to resume


      if (this.options.uploadUrl != null) {
        (0, _logger.log)("Resuming upload from provided URL: ".concat(this.options.uploadUrl));
        this.url = this.options.uploadUrl;

        this._resumeUpload();

        return;
      } // An upload has not started for the file yet, so we start a new one


      (0, _logger.log)('Creating a new upload');

      this._createUpload();
    }
    /**
     * Abort any running request and stop the current upload. After abort is called, no event
     * handler will be invoked anymore. You can use the `start` method to resume the upload
     * again.
     * If `shouldTerminate` is true, the `terminate` function will be called to remove the
     * current upload from the server.
     *
     * @param {boolean} shouldTerminate True if the upload should be deleted from the server.
     * @return {Promise} The Promise will be resolved/rejected when the requests finish.
     */

  }, {
    key: "abort",
    value: function abort(shouldTerminate) {
      var _this4 = this; // Stop any parallel partial uploads, that have been started in _startParallelUploads.


      if (this._parallelUploads != null) {
        this._parallelUploads.forEach(function (upload) {
          upload.abort(shouldTerminate);
        });
      } // Stop any current running request.


      if (this._req !== null) {
        this._req.abort(); // Note: We do not close the file source here, so the user can resume in the future.

      }

      this._aborted = true; // Stop any timeout used for initiating a retry.

      if (this._retryTimeout != null) {
        clearTimeout(this._retryTimeout);
        this._retryTimeout = null;
      }

      if (!shouldTerminate || this.url == null) {
        return Promise.resolve();
      }

      return BaseUpload.terminate(this.url, this.options) // Remove entry from the URL storage since the upload URL is no longer valid.
      .then(function () {
        return _this4._removeFromUrlStorage();
      });
    }
  }, {
    key: "_emitHttpError",
    value: function _emitHttpError(req, res, message, causingErr) {
      this._emitError(new _error["default"](message, causingErr, req, res));
    }
  }, {
    key: "_emitError",
    value: function _emitError(err) {
      var _this5 = this; // Do not emit errors, e.g. from aborted HTTP requests, if the upload has been stopped.


      if (this._aborted) return; // Check if we should retry, when enabled, before sending the error to the user.

      if (this.options.retryDelays != null) {
        // We will reset the attempt counter if
        // - we were already able to connect to the server (offset != null) and
        // - we were able to upload a small chunk of data to the server
        var shouldResetDelays = this._offset != null && this._offset > this._offsetBeforeRetry;

        if (shouldResetDelays) {
          this._retryAttempt = 0;
        }

        if (shouldRetry(err, this._retryAttempt, this.options)) {
          var delay = this.options.retryDelays[this._retryAttempt++];
          this._offsetBeforeRetry = this._offset;
          this._retryTimeout = setTimeout(function () {
            _this5.start();
          }, delay);
          return;
        }
      }

      if (typeof this.options.onError === 'function') {
        this.options.onError(err);
      } else {
        throw err;
      }
    }
    /**
     * Publishes notification if the upload has been successfully completed.
     *
     * @api private
     */

  }, {
    key: "_emitSuccess",
    value: function _emitSuccess() {
      if (this.options.removeFingerprintOnSuccess) {
        // Remove stored fingerprint and corresponding endpoint. This causes
        // new uploads of the same file to be treated as a different file.
        this._removeFromUrlStorage();
      }

      if (typeof this.options.onSuccess === 'function') {
        this.options.onSuccess();
      }
    }
    /**
     * Publishes notification when data has been sent to the server. This
     * data may not have been accepted by the server yet.
     *
     * @param {number} bytesSent  Number of bytes sent to the server.
     * @param {number} bytesTotal Total number of bytes to be sent to the server.
     * @api private
     */

  }, {
    key: "_emitProgress",
    value: function _emitProgress(bytesSent, bytesTotal) {
      if (typeof this.options.onProgress === 'function') {
        this.options.onProgress(bytesSent, bytesTotal);
      }
    }
    /**
     * Publishes notification when a chunk of data has been sent to the server
     * and accepted by the server.
     * @param {number} chunkSize  Size of the chunk that was accepted by the server.
     * @param {number} bytesAccepted Total number of bytes that have been
     *                                accepted by the server.
     * @param {number} bytesTotal Total number of bytes to be sent to the server.
     * @api private
     */

  }, {
    key: "_emitChunkComplete",
    value: function _emitChunkComplete(chunkSize, bytesAccepted, bytesTotal) {
      if (typeof this.options.onChunkComplete === 'function') {
        this.options.onChunkComplete(chunkSize, bytesAccepted, bytesTotal);
      }
    }
    /**
     * Create a new upload using the creation extension by sending a POST
     * request to the endpoint. After successful creation the file will be
     * uploaded
     *
     * @api private
     */

  }, {
    key: "_createUpload",
    value: function _createUpload() {
      var _this6 = this;

      if (!this.options.endpoint) {
        this._emitError(new Error('tus: unable to create upload because no endpoint is provided'));

        return;
      }

      var req = this._openRequest('POST', this.options.endpoint);

      if (this.options.uploadLengthDeferred) {
        req.setHeader('Upload-Defer-Length', 1);
      } else {
        req.setHeader('Upload-Length', this._size);
      } // Add metadata if values have been added


      var metadata = encodeMetadata(this.options.metadata);

      if (metadata !== '') {
        req.setHeader('Upload-Metadata', metadata);
      }

      var promise;

      if (this.options.uploadDataDuringCreation && !this.options.uploadLengthDeferred) {
        this._offset = 0;
        promise = this._addChunkToRequest(req);
      } else {
        promise = this._sendRequest(req, null);
      }

      promise.then(function (res) {
        if (!inStatusCategory(res.getStatus(), 200)) {
          _this6._emitHttpError(req, res, 'tus: unexpected response while creating upload');

          return;
        }

        var location = res.getHeader('Location');

        if (location == null) {
          _this6._emitHttpError(req, res, 'tus: invalid or missing Location header');

          return;
        }

        _this6.url = resolveUrl(_this6.options.endpoint, location);
        (0, _logger.log)("Created upload at ".concat(_this6.url));

        if (typeof _this6.options._onUploadUrlAvailable === 'function') {
          _this6.options._onUploadUrlAvailable();
        }

        if (_this6._size === 0) {
          // Nothing to upload and file was successfully created
          _this6._emitSuccess();

          _this6._source.close();

          return;
        }

        _this6._saveUploadInUrlStorage().then(function () {
          if (_this6.options.uploadDataDuringCreation) {
            _this6._handleUploadResponse(req, res);
          } else {
            _this6._offset = 0;

            _this6._performUpload();
          }
        });
      })["catch"](function (err) {
        _this6._emitHttpError(req, null, 'tus: failed to create upload', err);
      });
    }
    /*
     * Try to resume an existing upload. First a HEAD request will be sent
     * to retrieve the offset. If the request fails a new upload will be
     * created. In the case of a successful response the file will be uploaded.
     *
     * @api private
     */

  }, {
    key: "_resumeUpload",
    value: function _resumeUpload() {
      var _this7 = this;

      var req = this._openRequest('HEAD', this.url);

      var promise = this._sendRequest(req, null);

      promise.then(function (res) {
        var status = res.getStatus();

        if (!inStatusCategory(status, 200)) {
          // If the upload is locked (indicated by the 423 Locked status code), we
          // emit an error instead of directly starting a new upload. This way the
          // retry logic can catch the error and will retry the upload. An upload
          // is usually locked for a short period of time and will be available
          // afterwards.
          if (status === 423) {
            _this7._emitHttpError(req, res, 'tus: upload is currently locked; retry later');

            return;
          }

          if (inStatusCategory(status, 400)) {
            // Remove stored fingerprint and corresponding endpoint,
            // on client errors since the file can not be found
            _this7._removeFromUrlStorage();
          }

          if (!_this7.options.endpoint) {
            // Don't attempt to create a new upload if no endpoint is provided.
            _this7._emitHttpError(req, res, 'tus: unable to resume upload (new upload cannot be created without an endpoint)');

            return;
          } // Try to create a new upload


          _this7.url = null;

          _this7._createUpload();

          return;
        }

        var offset = parseInt(res.getHeader('Upload-Offset'), 10);

        if (Number.isNaN(offset)) {
          _this7._emitHttpError(req, res, 'tus: invalid or missing offset value');

          return;
        }

        var length = parseInt(res.getHeader('Upload-Length'), 10);

        if (Number.isNaN(length) && !_this7.options.uploadLengthDeferred) {
          _this7._emitHttpError(req, res, 'tus: invalid or missing length value');

          return;
        }

        if (typeof _this7.options._onUploadUrlAvailable === 'function') {
          _this7.options._onUploadUrlAvailable();
        }

        _this7._saveUploadInUrlStorage().then(function () {
          // Upload has already been completed and we do not need to send additional
          // data to the server
          if (offset === length) {
            _this7._emitProgress(length, length);

            _this7._emitSuccess();

            return;
          }

          _this7._offset = offset;

          _this7._performUpload();
        });
      })["catch"](function (err) {
        _this7._emitHttpError(req, null, 'tus: failed to resume upload', err);
      });
    }
    /**
     * Start uploading the file using PATCH requests. The file will be divided
     * into chunks as specified in the chunkSize option. During the upload
     * the onProgress event handler may be invoked multiple times.
     *
     * @api private
     */

  }, {
    key: "_performUpload",
    value: function _performUpload() {
      var _this8 = this; // If the upload has been aborted, we will not send the next PATCH request.
      // This is important if the abort method was called during a callback, such
      // as onChunkComplete or onProgress.


      if (this._aborted) {
        return;
      }

      var req; // Some browser and servers may not support the PATCH method. For those
      // cases, you can tell tus-js-client to use a POST request with the
      // X-HTTP-Method-Override header for simulating a PATCH request.

      if (this.options.overridePatchMethod) {
        req = this._openRequest('POST', this.url);
        req.setHeader('X-HTTP-Method-Override', 'PATCH');
      } else {
        req = this._openRequest('PATCH', this.url);
      }

      req.setHeader('Upload-Offset', this._offset);

      var promise = this._addChunkToRequest(req);

      promise.then(function (res) {
        if (!inStatusCategory(res.getStatus(), 200)) {
          _this8._emitHttpError(req, res, 'tus: unexpected response while uploading chunk');

          return;
        }

        _this8._handleUploadResponse(req, res);
      })["catch"](function (err) {
        // Don't emit an error if the upload was aborted manually
        if (_this8._aborted) {
          return;
        }

        _this8._emitHttpError(req, null, "tus: failed to upload chunk at offset ".concat(_this8._offset), err);
      });
    }
    /**
     * _addChunktoRequest reads a chunk from the source and sends it using the
     * supplied request object. It will not handle the response.
     *
     * @api private
     */

  }, {
    key: "_addChunkToRequest",
    value: function _addChunkToRequest(req) {
      var _this9 = this;

      var start = this._offset;
      var end = this._offset + this.options.chunkSize;
      req.setProgressHandler(function (bytesSent) {
        _this9._emitProgress(start + bytesSent, _this9._size);
      });
      req.setHeader('Content-Type', 'application/offset+octet-stream'); // The specified chunkSize may be Infinity or the calcluated end position
      // may exceed the file's size. In both cases, we limit the end position to
      // the input's total size for simpler calculations and correctness.

      if ((end === Infinity || end > this._size) && !this.options.uploadLengthDeferred) {
        end = this._size;
      }

      return this._source.slice(start, end).then(function (_ref2) {
        var value = _ref2.value,
            done = _ref2.done; // If the upload length is deferred, the upload size was not specified during
        // upload creation. So, if the file reader is done reading, we know the total
        // upload size and can tell the tus server.

        if (_this9.options.uploadLengthDeferred && done) {
          _this9._size = _this9._offset + (value && value.size ? value.size : 0);
          req.setHeader('Upload-Length', _this9._size);
        }

        if (value === null) {
          return _this9._sendRequest(req);
        }

        _this9._emitProgress(_this9._offset, _this9._size);

        return _this9._sendRequest(req, value);
      });
    }
    /**
     * _handleUploadResponse is used by requests that haven been sent using _addChunkToRequest
     * and already have received a response.
     *
     * @api private
     */

  }, {
    key: "_handleUploadResponse",
    value: function _handleUploadResponse(req, res) {
      var _this10 = this;

      var offset = parseInt(res.getHeader('Upload-Offset'), 10);

      if (Number.isNaN(offset)) {
        this._emitHttpError(req, res, 'tus: invalid or missing offset value');

        return;
      }

      this._emitProgress(offset, this._size);

      this._emitChunkComplete(offset - this._offset, offset, this._size);

      this._offset = offset;

      if (offset === this._size) {
        // Yay, finally done :)
        this._emitSuccess();

        this._source.close();

        return;
      } // Not done uploading yet.


      var promise = Promise.resolve();

      if (this.options.staggerPercent !== null) {
        this._currentChunk = this._currentChunk.nextChunkInPart;

        if (this.currentChunk !== null) {
          // If the stagger is set, wait for the stagger for the current chunk.
          promise = this._currentChunk.promise;
        }
      }

      promise.then(function () {
        return _this10._performUpload();
      });
    }
    /**
     * Create a new HTTP request object with the given method and URL.
     *
     * @api private
     */

  }, {
    key: "_openRequest",
    value: function _openRequest(method, url) {
      var req = openRequest(method, url, this.options);
      this._req = req;
      return req;
    }
    /**
     * Remove the entry in the URL storage, if it has been saved before.
     *
     * @api private
     */

  }, {
    key: "_removeFromUrlStorage",
    value: function _removeFromUrlStorage() {
      var _this11 = this;

      if (!this._urlStorageKey) return;

      this._urlStorage.removeUpload(this._urlStorageKey)["catch"](function (err) {
        _this11._emitError(err);
      });

      this._urlStorageKey = null;
    }
    /**
     * Add the upload URL to the URL storage, if possible.
     *
     * @api private
     */

  }, {
    key: "_saveUploadInUrlStorage",
    value: function _saveUploadInUrlStorage() {
      var _this12 = this; // We do not store the upload URL
      // - if it was disabled in the option, or
      // - if no fingerprint was calculated for the input (i.e. a stream), or
      // - if the URL is already stored (i.e. key is set alread).


      if (!this.options.storeFingerprintForResuming || !this._fingerprint || this._urlStorageKey !== null) {
        return Promise.resolve();
      }

      var storedUpload = {
        size: this._size,
        metadata: this.options.metadata,
        creationTime: new Date().toString()
      };

      if (this._parallelUploads) {
        // Save multiple URLs if the parallelUploads option is used ...
        storedUpload.parallelUploadUrls = this._parallelUploadUrls;
      } else {
        // ... otherwise we just save the one available URL.
        storedUpload.uploadUrl = this.url;
      }

      return this._urlStorage.addUpload(this._fingerprint, storedUpload).then(function (urlStorageKey) {
        _this12._urlStorageKey = urlStorageKey;
      });
    }
    /**
     * Send a request with the provided body.
     *
     * @api private
     */

  }, {
    key: "_sendRequest",
    value: function _sendRequest(req) {
      var body = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return sendRequest(req, body, this.options);
    }
  }], [{
    key: "terminate",
    value: function terminate(url) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var req = openRequest('DELETE', url, options);
      return sendRequest(req, null, options).then(function (res) {
        // A 204 response indicates a successfull request
        if (res.getStatus() === 204) {
          return;
        }

        throw new _error["default"]('tus: unexpected response while terminating upload', null, req, res);
      })["catch"](function (err) {
        if (!(err instanceof _error["default"])) {
          err = new _error["default"]('tus: failed to terminate upload', err, req, null);
        }

        if (!shouldRetry(err, 0, options)) {
          throw err;
        } // Instead of keeping track of the retry attempts, we remove the first element from the delays
        // array. If the array is empty, all retry attempts are used up and we will bubble up the error.
        // We recursively call the terminate function will removing elements from the retryDelays array.


        var delay = options.retryDelays[0];
        var remainingDelays = options.retryDelays.slice(1);

        var newOptions = _objectSpread(_objectSpread({}, options), {}, {
          retryDelays: remainingDelays
        });

        return new Promise(function (resolve) {
          return setTimeout(resolve, delay);
        }).then(function () {
          return BaseUpload.terminate(url, newOptions);
        });
      });
    }
  }]);

  return BaseUpload;
}();

function encodeMetadata(metadata) {
  return Object.entries(metadata).map(function (_ref3) {
    var _ref4 = _slicedToArray(_ref3, 2),
        key = _ref4[0],
        value = _ref4[1];

    return "".concat(key, " ").concat(_jsBase.Base64.encode(String(value)));
  }).join(',');
}
/**
 * Checks whether a given status is in the range of the expected category.
 * For example, only a status between 200 and 299 will satisfy the category 200.
 *
 * @api private
 */


function inStatusCategory(status, category) {
  return status >= category && status < category + 100;
}
/**
 * Create a new HTTP request with the specified method and URL.
 * The necessary headers that are included in every request
 * will be added, including the request ID.
 *
 * @api private
 */


function openRequest(method, url, options) {
  var req = options.httpStack.createRequest(method, url);
  req.setHeader('Tus-Resumable', '1.0.0');
  var headers = options.headers || {};
  Object.entries(headers).forEach(function (_ref5) {
    var _ref6 = _slicedToArray(_ref5, 2),
        name = _ref6[0],
        value = _ref6[1];

    req.setHeader(name, value);
  });

  if (options.addRequestId) {
    var requestId = (0, _uuid["default"])();
    req.setHeader('X-Request-ID', requestId);
  }

  return req;
}
/**
 * Send a request with the provided body while invoking the onBeforeRequest
 * and onAfterResponse callbacks.
 *
 * @api private
 */


function sendRequest(req, body, options) {
  var onBeforeRequestPromise = typeof options.onBeforeRequest === 'function' ? Promise.resolve(options.onBeforeRequest(req)) : Promise.resolve();
  return onBeforeRequestPromise.then(function () {
    return req.send(body).then(function (res) {
      var onAfterResponsePromise = typeof options.onAfterResponse === 'function' ? Promise.resolve(options.onAfterResponse(req, res)) : Promise.resolve();
      return onAfterResponsePromise.then(function () {
        return res;
      });
    });
  });
}
/**
 * Checks whether the browser running this code has internet access.
 * This function will always return true in the node.js environment
 *
 * @api private
 */


function isOnline() {
  var online = true;

  if (typeof window !== 'undefined' && 'navigator' in window && window.navigator.onLine === false) {
    online = false;
  }

  return online;
}
/**
 * Checks whether or not it is ok to retry a request.
 * @param {Error} err the error returned from the last request
 * @param {number} retryAttempt the number of times the request has already been retried
 * @param {object} options tus Upload options
 *
 * @api private
 */


function shouldRetry(err, retryAttempt, options) {
  // We only attempt a retry if
  // - retryDelays option is set
  // - we didn't exceed the maxium number of retries, yet, and
  // - this error was caused by a request or it's response and
  // - the error is server error (i.e. not a status 4xx except a 409 or 423) or
  // a onShouldRetry is specified and returns true
  // - the browser does not indicate that we are offline
  if (options.retryDelays == null || retryAttempt >= options.retryDelays.length || err.originalRequest == null) {
    return false;
  }

  if (options && typeof options.onShouldRetry === 'function') {
    return options.onShouldRetry(err, retryAttempt, options);
  }

  var status = err.originalResponse ? err.originalResponse.getStatus() : 0;
  return (!inStatusCategory(status, 400) || status === 409 || status === 423) && isOnline();
}
/**
 * Resolve a relative link given the origin as source. For example,
 * if a HTTP request to http://example.com/files/ returns a Location
 * header with the value /upload/abc, the resolved URL will be:
 * http://example.com/upload/abc
 */


function resolveUrl(origin, link) {
  return new _urlParse["default"](link, origin).toString();
}
/**
 * Calculate the start and end positions for the parts if an upload
 * is split into multiple parallel requests.
 *
 * @param {number} totalSize The byte size of the upload, which will be split.
 * @param {number} partCount The number in how many parts the upload will be split.
 * @return {object[]}
 * @api private
 */


function splitSizeIntoParts(totalSize, partCount) {
  var partSize = Math.floor(totalSize / partCount);
  var parts = [];

  for (var i = 0; i < partCount; i++) {
    parts.push({
      start: partSize * i,
      end: partSize * (i + 1)
    });
  }

  parts[partCount - 1].end = totalSize;
  return parts;
}
/**
 * Build the chunk staggers.
 *
 * NOTE: The code that builds parts must be kept in sync with
 * `splitSizeIntoChunkAlignedParts` in skynet-js.
 */


function buildChunkStaggers(totalSize, partCount, chunkSize) {
  // Helper function to create a new chunk in partsChunks at the given part.
  function newChunk(partsChunks, partIndex) {
    var chunksForPart = partsChunks[partIndex];
    var chunkResolve;
    var promise = new Promise(function (resolve) {
      chunkResolve = resolve;
    });
    var chunk = {
      promise: promise,
      resolve: chunkResolve,
      resolved: false,
      nextChunkStagger: null,
      nextChunkInPart: null,
      indexInPart: chunksForPart.length
    }; // Previous chunk in part should point to this chunk.

    if (chunksForPart.length > 0) {
      chunksForPart[chunksForPart.length - 1].nextChunkInPart = chunk;
    } // Push chunk to part.


    chunksForPart.push(chunk);
  } // Validation.


  if (partCount < 1) {
    throw new Error("Expected option 'partCount' to be greater than or equal to 1, was type 'number', value '".concat(partCount, "'"));
  }

  if (chunkSize < 1) {
    throw new Error("Expected option 'chunkSize' to be greater than or equal to 1, was type 'number', value '".concat(chunkSize, "'"));
  } // NOTE: Unexpected code flow. `uploadLargeFileRequest` in skynet-js should
  // not enable parallel uploads for this case.


  if (totalSize <= chunkSize) {
    throw new Error("Expected parameter 'totalSize' to be greater than the size of a chunk ('".concat(chunkSize, "'), was type 'number', value '").concat(totalSize, "'"));
  } // The lists of chunks for each part. Initialize all to empty arrays.


  var partsChunks = [];

  for (var i = 0; i < partCount; i++) {
    partsChunks.push([]);
  } // Assign chunks to parts in order, looping back to the beginning if we get to
  // the end of the parts array.


  var numFullChunks = Math.floor(totalSize / chunkSize);

  for (var _i2 = 0; _i2 < numFullChunks; _i2++) {
    newChunk(partsChunks, _i2 % partCount);
  } // Whether there is any leftover that has to go in the last part.


  var hasLeftover = totalSize % chunkSize > 0; // If there is non-chunk-aligned leftover, add a chunk for it.

  if (hasLeftover) {
    // Assign the leftover to the part after the last part that was visited, or
    // the last part in the array if all parts were used.
    //
    // NOTE: We don't need to worry about empty parts, tus ignores those.
    var lastIndex = Math.min(numFullChunks, partCount - 1);
    newChunk(partsChunks, lastIndex);
  } // Now assign the stagger order. We start at the part with the most chunks, so
  // we don't end up with any final pauses.
  //
  // NOTE: The first longest part is either the first part or the last. The latter
  // can happen. when all parts have one chunk and the last part gets the extra
  // leftover. We explicitly check all parts just to be defensive/futureproof
  // against our assumptions.


  var longestPartIndex = 0;
  var longestPartLength = partsChunks[0].length;

  for (var _i3 = 1; _i3 < partsChunks.length; _i3++) {
    if (partsChunks[_i3].length > longestPartLength) {
      longestPartIndex = _i3;
      longestPartLength = partsChunks[_i3].length;
    }
  } // Get the chunk at which to start uploading.


  var firstChunk = partsChunks[longestPartIndex][0]; // Build the stagger sequence.

  var lastChunk = null; // Loop over the chunk indices for the longest part.

  for (var _i4 = 0; _i4 < longestPartLength; _i4++) {
    // Loop over the parts, starting from the longest. This keeps a stagger
    // between chunks and prevents pauses. We roll over to the first part
    // if we need to.
    for (var j = longestPartIndex; j < longestPartIndex + partCount; j++) {
      // Roll over to the first part if we need to with the modulo.
      var index = j % partCount;

      if (partsChunks[index].length > _i4) {
        var chunk = partsChunks[index][_i4]; // Last chunk in stagger order should point to this one.

        if (lastChunk !== null) {
          lastChunk.nextChunkStagger = chunk;
        }

        lastChunk = chunk;
      }
    }
  }

  return [partsChunks, firstChunk];
}

BaseUpload.defaultOptions = defaultOptions;
var _default = BaseUpload;
exports["default"] = _default;

},{"./error":12,"./logger":13,"./uuid":16,"js-base64":52,"url-parse":57}],16:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = uuid;
/**
 * Generate a UUID v4 based on random numbers. We intentioanlly use the less
 * secure Math.random function here since the more secure crypto.getRandomNumbers
 * is not available on all platforms.
 * This is not a problem for us since we use the UUID only for generating a
 * request ID, so we can correlate server logs to client errors.
 *
 * This function is taken from following site:
 * https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
 *
 * @return {string} The generate UUID
 */

function uuid() {
  /* eslint-disable no-bitwise */
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0;
    var v = c === 'x' ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
}

},{}],17:[function(require,module,exports){
module.exports = require('./lib/axios');
},{"./lib/axios":19}],18:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var settle = require('./../core/settle');
var cookies = require('./../helpers/cookies');
var buildURL = require('./../helpers/buildURL');
var buildFullPath = require('../core/buildFullPath');
var parseHeaders = require('./../helpers/parseHeaders');
var isURLSameOrigin = require('./../helpers/isURLSameOrigin');
var transitionalDefaults = require('../defaults/transitional');
var AxiosError = require('../core/AxiosError');
var CanceledError = require('../cancel/CanceledError');
var parseProtocol = require('../helpers/parseProtocol');

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;
    var responseType = config.responseType;
    var onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }

      if (config.signal) {
        config.signal.removeEventListener('abort', onCanceled);
      }
    }

    if (utils.isFormData(requestData) && utils.isStandardBrowserEnv()) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);

    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?
        request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
      var transitional = config.transitional || transitionalDefaults;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config,
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken || config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = function(cancel) {
        if (!request) {
          return;
        }
        reject(!cancel || (cancel && cancel.type) ? new CanceledError() : cancel);
        request.abort();
        request = null;
      };

      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
      }
    }

    if (!requestData) {
      requestData = null;
    }

    var protocol = parseProtocol(fullPath);

    if (protocol && [ 'http', 'https', 'file' ].indexOf(protocol) === -1) {
      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));
      return;
    }


    // Send the request
    request.send(requestData);
  });
};

},{"../cancel/CanceledError":21,"../core/AxiosError":24,"../core/buildFullPath":26,"../defaults/transitional":32,"../helpers/parseProtocol":44,"./../core/settle":29,"./../helpers/buildURL":35,"./../helpers/cookies":37,"./../helpers/isURLSameOrigin":40,"./../helpers/parseHeaders":43,"./../utils":48}],19:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var bind = require('./helpers/bind');
var Axios = require('./core/Axios');
var mergeConfig = require('./core/mergeConfig');
var defaults = require('./defaults');

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Expose Cancel & CancelToken
axios.CanceledError = require('./cancel/CanceledError');
axios.CancelToken = require('./cancel/CancelToken');
axios.isCancel = require('./cancel/isCancel');
axios.VERSION = require('./env/data').version;
axios.toFormData = require('./helpers/toFormData');

// Expose AxiosError class
axios.AxiosError = require('../lib/core/AxiosError');

// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = require('./helpers/spread');

// Expose isAxiosError
axios.isAxiosError = require('./helpers/isAxiosError');

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;

},{"../lib/core/AxiosError":24,"./cancel/CancelToken":20,"./cancel/CanceledError":21,"./cancel/isCancel":22,"./core/Axios":23,"./core/mergeConfig":28,"./defaults":31,"./env/data":33,"./helpers/bind":34,"./helpers/isAxiosError":39,"./helpers/spread":45,"./helpers/toFormData":46,"./utils":48}],20:[function(require,module,exports){
'use strict';

var CanceledError = require('./CanceledError');

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;

  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;

  // eslint-disable-next-line func-names
  this.promise.then(function(cancel) {
    if (!token._listeners) return;

    var i;
    var l = token._listeners.length;

    for (i = 0; i < l; i++) {
      token._listeners[i](cancel);
    }
    token._listeners = null;
  });

  // eslint-disable-next-line func-names
  this.promise.then = function(onfulfilled) {
    var _resolve;
    // eslint-disable-next-line func-names
    var promise = new Promise(function(resolve) {
      token.subscribe(resolve);
      _resolve = resolve;
    }).then(onfulfilled);

    promise.cancel = function reject() {
      token.unsubscribe(_resolve);
    };

    return promise;
  };

  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new CanceledError(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `CanceledError` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Subscribe to the cancel signal
 */

CancelToken.prototype.subscribe = function subscribe(listener) {
  if (this.reason) {
    listener(this.reason);
    return;
  }

  if (this._listeners) {
    this._listeners.push(listener);
  } else {
    this._listeners = [listener];
  }
};

/**
 * Unsubscribe from the cancel signal
 */

CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
  if (!this._listeners) {
    return;
  }
  var index = this._listeners.indexOf(listener);
  if (index !== -1) {
    this._listeners.splice(index, 1);
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;

},{"./CanceledError":21}],21:[function(require,module,exports){
'use strict';

var AxiosError = require('../core/AxiosError');
var utils = require('../utils');

/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function CanceledError(message) {
  // eslint-disable-next-line no-eq-null,eqeqeq
  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED);
  this.name = 'CanceledError';
}

utils.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});

module.exports = CanceledError;

},{"../core/AxiosError":24,"../utils":48}],22:[function(require,module,exports){
'use strict';

module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};

},{}],23:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var buildURL = require('../helpers/buildURL');
var InterceptorManager = require('./InterceptorManager');
var dispatchRequest = require('./dispatchRequest');
var mergeConfig = require('./mergeConfig');
var buildFullPath = require('./buildFullPath');
var validator = require('../helpers/validator');

var validators = validator.validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(configOrUrl, config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof configOrUrl === 'string') {
    config = config || {};
    config.url = configOrUrl;
  } else {
    config = configOrUrl || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  var transitional = config.transitional;

  if (transitional !== undefined) {
    validator.assertOptions(transitional, {
      silentJSONParsing: validators.transitional(validators.boolean),
      forcedJSONParsing: validators.transitional(validators.boolean),
      clarifyTimeoutError: validators.transitional(validators.boolean)
    }, false);
  }

  // filter out skipped interceptors
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
      return;
    }

    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });

  var promise;

  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest, undefined];

    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);

    promise = Promise.resolve(config);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  }


  var newConfig = config;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }

  try {
    promise = dispatchRequest(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }

  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  var fullPath = buildFullPath(config.baseURL, config.url);
  return buildURL(fullPath, config.params, config.paramsSerializer);
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/

  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method: method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url: url,
        data: data
      }));
    };
  }

  Axios.prototype[method] = generateHTTPMethod();

  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});

module.exports = Axios;

},{"../helpers/buildURL":35,"../helpers/validator":47,"./../utils":48,"./InterceptorManager":25,"./buildFullPath":26,"./dispatchRequest":27,"./mergeConfig":28}],24:[function(require,module,exports){
'use strict';

var utils = require('../utils');

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  this.message = message;
  this.name = 'AxiosError';
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}

utils.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});

var prototype = AxiosError.prototype;
var descriptors = {};

[
  'ERR_BAD_OPTION_VALUE',
  'ERR_BAD_OPTION',
  'ECONNABORTED',
  'ETIMEDOUT',
  'ERR_NETWORK',
  'ERR_FR_TOO_MANY_REDIRECTS',
  'ERR_DEPRECATED',
  'ERR_BAD_RESPONSE',
  'ERR_BAD_REQUEST',
  'ERR_CANCELED'
// eslint-disable-next-line func-names
].forEach(function(code) {
  descriptors[code] = {value: code};
});

Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, 'isAxiosError', {value: true});

// eslint-disable-next-line func-names
AxiosError.from = function(error, code, config, request, response, customProps) {
  var axiosError = Object.create(prototype);

  utils.toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  });

  AxiosError.call(axiosError, error.message, code, config, request, response);

  axiosError.name = error.name;

  customProps && Object.assign(axiosError, customProps);

  return axiosError;
};

module.exports = AxiosError;

},{"../utils":48}],25:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;

},{"./../utils":48}],26:[function(require,module,exports){
'use strict';

var isAbsoluteURL = require('../helpers/isAbsoluteURL');
var combineURLs = require('../helpers/combineURLs');

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};

},{"../helpers/combineURLs":36,"../helpers/isAbsoluteURL":38}],27:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var transformData = require('./transformData');
var isCancel = require('../cancel/isCancel');
var defaults = require('../defaults');
var CanceledError = require('../cancel/CanceledError');

/**
 * Throws a `CanceledError` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new CanceledError();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData.call(
    config,
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};

},{"../cancel/CanceledError":21,"../cancel/isCancel":22,"../defaults":31,"./../utils":48,"./transformData":30}],28:[function(require,module,exports){
'use strict';

var utils = require('../utils');

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(undefined, config2[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(prop) {
    if (prop in config2) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  var mergeMap = {
    'url': valueFromConfig2,
    'method': valueFromConfig2,
    'data': valueFromConfig2,
    'baseURL': defaultToConfig2,
    'transformRequest': defaultToConfig2,
    'transformResponse': defaultToConfig2,
    'paramsSerializer': defaultToConfig2,
    'timeout': defaultToConfig2,
    'timeoutMessage': defaultToConfig2,
    'withCredentials': defaultToConfig2,
    'adapter': defaultToConfig2,
    'responseType': defaultToConfig2,
    'xsrfCookieName': defaultToConfig2,
    'xsrfHeaderName': defaultToConfig2,
    'onUploadProgress': defaultToConfig2,
    'onDownloadProgress': defaultToConfig2,
    'decompress': defaultToConfig2,
    'maxContentLength': defaultToConfig2,
    'maxBodyLength': defaultToConfig2,
    'beforeRedirect': defaultToConfig2,
    'transport': defaultToConfig2,
    'httpAgent': defaultToConfig2,
    'httpsAgent': defaultToConfig2,
    'cancelToken': defaultToConfig2,
    'socketPath': defaultToConfig2,
    'responseEncoding': defaultToConfig2,
    'validateStatus': mergeDirectKeys
  };

  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    var merge = mergeMap[prop] || mergeDeepProperties;
    var configValue = merge(prop);
    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
  });

  return config;
};

},{"../utils":48}],29:[function(require,module,exports){
'use strict';

var AxiosError = require('./AxiosError');

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError(
      'Request failed with status code ' + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
};

},{"./AxiosError":24}],30:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var defaults = require('../defaults');

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  var context = this || defaults;
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn.call(context, data, headers);
  });

  return data;
};

},{"../defaults":31,"./../utils":48}],31:[function(require,module,exports){
(function (process){(function (){
'use strict';

var utils = require('../utils');
var normalizeHeaderName = require('../helpers/normalizeHeaderName');
var AxiosError = require('../core/AxiosError');
var transitionalDefaults = require('./transitional');
var toFormData = require('../helpers/toFormData');

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = require('../adapters/xhr');
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = require('../adapters/http');
  }
  return adapter;
}

function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

var defaults = {

  transitional: transitionalDefaults,

  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }

    var isObjectPayload = utils.isObject(data);
    var contentType = headers && headers['Content-Type'];

    var isFileList;

    if ((isFileList = utils.isFileList(data)) || (isObjectPayload && contentType === 'multipart/form-data')) {
      var _FormData = this.env && this.env.FormData;
      return toFormData(isFileList ? {'files[]': data} : data, _FormData && new _FormData());
    } else if (isObjectPayload || contentType === 'application/json') {
      setContentTypeIfUnset(headers, 'application/json');
      return stringifySafely(data);
    }

    return data;
  }],

  transformResponse: [function transformResponse(data) {
    var transitional = this.transitional || defaults.transitional;
    var silentJSONParsing = transitional && transitional.silentJSONParsing;
    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  env: {
    FormData: require('./env/FormData')
  },

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*'
    }
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;

}).call(this)}).call(this,require('_process'))

},{"../adapters/http":18,"../adapters/xhr":18,"../core/AxiosError":24,"../helpers/normalizeHeaderName":41,"../helpers/toFormData":46,"../utils":48,"./env/FormData":42,"./transitional":32,"_process":53}],32:[function(require,module,exports){
'use strict';

module.exports = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

},{}],33:[function(require,module,exports){
module.exports = {
  "version": "0.27.2"
};
},{}],34:[function(require,module,exports){
'use strict';

module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};

},{}],35:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

},{"./../utils":48}],36:[function(require,module,exports){
'use strict';

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};

},{}],37:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);

},{"./../utils":48}],38:[function(require,module,exports){
'use strict';

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
};

},{}],39:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
module.exports = function isAxiosError(payload) {
  return utils.isObject(payload) && (payload.isAxiosError === true);
};

},{"./../utils":48}],40:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);

},{"./../utils":48}],41:[function(require,module,exports){
'use strict';

var utils = require('../utils');

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

},{"../utils":48}],42:[function(require,module,exports){
// eslint-disable-next-line strict
module.exports = null;

},{}],43:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};

},{"./../utils":48}],44:[function(require,module,exports){
'use strict';

module.exports = function parseProtocol(url) {
  var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || '';
};

},{}],45:[function(require,module,exports){
'use strict';

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

},{}],46:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';

var utils = require('../utils');

/**
 * Convert a data object to FormData
 * @param {Object} obj
 * @param {?Object} [formData]
 * @returns {Object}
 **/

function toFormData(obj, formData) {
  // eslint-disable-next-line no-param-reassign
  formData = formData || new FormData();

  var stack = [];

  function convertValue(value) {
    if (value === null) return '';

    if (utils.isDate(value)) {
      return value.toISOString();
    }

    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
      return typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
    }

    return value;
  }

  function build(data, parentKey) {
    if (utils.isPlainObject(data) || utils.isArray(data)) {
      if (stack.indexOf(data) !== -1) {
        throw Error('Circular reference detected in ' + parentKey);
      }

      stack.push(data);

      utils.forEach(data, function each(value, key) {
        if (utils.isUndefined(value)) return;
        var fullKey = parentKey ? parentKey + '.' + key : key;
        var arr;

        if (value && !parentKey && typeof value === 'object') {
          if (utils.endsWith(key, '{}')) {
            // eslint-disable-next-line no-param-reassign
            value = JSON.stringify(value);
          } else if (utils.endsWith(key, '[]') && (arr = utils.toArray(value))) {
            // eslint-disable-next-line func-names
            arr.forEach(function(el) {
              !utils.isUndefined(el) && formData.append(fullKey, convertValue(el));
            });
            return;
          }
        }

        build(value, fullKey);
      });

      stack.pop();
    } else {
      formData.append(parentKey, convertValue(data));
    }
  }

  build(obj);

  return formData;
}

module.exports = toFormData;

}).call(this)}).call(this,require("buffer").Buffer)

},{"../utils":48,"buffer":50}],47:[function(require,module,exports){
'use strict';

var VERSION = require('../env/data').version;
var AxiosError = require('../core/AxiosError');

var validators = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {
  validators[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

var deprecatedWarnings = {};

/**
 * Transitional option validator
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 * @returns {function}
 */
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return function(value, opt, opts) {
    if (validator === false) {
      throw new AxiosError(
        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
        AxiosError.ERR_DEPRECATED
      );
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);
  }
  var keys = Object.keys(options);
  var i = keys.length;
  while (i-- > 0) {
    var opt = keys[i];
    var validator = schema[opt];
    if (validator) {
      var value = options[opt];
      var result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}

module.exports = {
  assertOptions: assertOptions,
  validators: validators
};

},{"../core/AxiosError":24,"../env/data":33}],48:[function(require,module,exports){
'use strict';

var bind = require('./helpers/bind');

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

// eslint-disable-next-line func-names
var kindOf = (function(cache) {
  // eslint-disable-next-line func-names
  return function(thing) {
    var str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
  };
})(Object.create(null));

function kindOfTest(type) {
  type = type.toLowerCase();
  return function isKindOf(thing) {
    return kindOf(thing) === type;
  };
}

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return Array.isArray(val);
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
var isArrayBuffer = kindOfTest('ArrayBuffer');


/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (kindOf(val) !== 'object') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
var isDate = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
var isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
var isBlob = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
var isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} thing The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(thing) {
  var pattern = '[object FormData]';
  return thing && (
    (typeof FormData === 'function' && thing instanceof FormData) ||
    toString.call(thing) === pattern ||
    (isFunction(thing.toString) && thing.toString() === pattern)
  );
}

/**
 * Determine if a value is a URLSearchParams object
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
var isURLSearchParams = kindOfTest('URLSearchParams');

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 */

function inherits(constructor, superConstructor, props, descriptors) {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  props && Object.assign(constructor.prototype, props);
}

/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function} [filter]
 * @returns {Object}
 */

function toFlatObject(sourceObj, destObj, filter) {
  var props;
  var i;
  var prop;
  var merged = {};

  destObj = destObj || {};

  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if (!merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = Object.getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

  return destObj;
}

/*
 * determines whether a string ends with the characters of a specified string
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 * @returns {boolean}
 */
function endsWith(str, searchString, position) {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  var lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
}


/**
 * Returns new array from array like object
 * @param {*} [thing]
 * @returns {Array}
 */
function toArray(thing) {
  if (!thing) return null;
  var i = thing.length;
  if (isUndefined(i)) return null;
  var arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
}

// eslint-disable-next-line func-names
var isTypedArray = (function(TypedArray) {
  // eslint-disable-next-line func-names
  return function(thing) {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== 'undefined' && Object.getPrototypeOf(Uint8Array));

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM,
  inherits: inherits,
  toFlatObject: toFlatObject,
  kindOf: kindOf,
  kindOfTest: kindOfTest,
  endsWith: endsWith,
  toArray: toArray,
  isTypedArray: isTypedArray,
  isFileList: isFileList
};

},{"./helpers/bind":34}],49:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],50:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)

},{"base64-js":49,"buffer":50,"ieee754":51}],51:[function(require,module,exports){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],52:[function(require,module,exports){
(function (global,Buffer){(function (){
//
// THIS FILE IS AUTOMATICALLY GENERATED! DO NOT EDIT BY HAND!
//
;
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined'
        ? module.exports = factory()
        : typeof define === 'function' && define.amd
            ? define(factory) :
            // cf. https://github.com/dankogai/js-base64/issues/119
            (function () {
                // existing version for noConflict()
                var _Base64 = global.Base64;
                var gBase64 = factory();
                gBase64.noConflict = function () {
                    global.Base64 = _Base64;
                    return gBase64;
                };
                if (global.Meteor) { // Meteor.js
                    Base64 = gBase64;
                }
                global.Base64 = gBase64;
            })();
}((typeof self !== 'undefined' ? self
    : typeof window !== 'undefined' ? window
        : typeof global !== 'undefined' ? global
            : this), function () {
    'use strict';
    /**
     *  base64.ts
     *
     *  Licensed under the BSD 3-Clause License.
     *    http://opensource.org/licenses/BSD-3-Clause
     *
     *  References:
     *    http://en.wikipedia.org/wiki/Base64
     *
     * @author Dan Kogai (https://github.com/dankogai)
     */
    var version = '3.7.2';
    /**
     * @deprecated use lowercase `version`.
     */
    var VERSION = version;
    var _hasatob = typeof atob === 'function';
    var _hasbtoa = typeof btoa === 'function';
    var _hasBuffer = typeof Buffer === 'function';
    var _TD = typeof TextDecoder === 'function' ? new TextDecoder() : undefined;
    var _TE = typeof TextEncoder === 'function' ? new TextEncoder() : undefined;
    var b64ch = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    var b64chs = Array.prototype.slice.call(b64ch);
    var b64tab = (function (a) {
        var tab = {};
        a.forEach(function (c, i) { return tab[c] = i; });
        return tab;
    })(b64chs);
    var b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
    var _fromCC = String.fromCharCode.bind(String);
    var _U8Afrom = typeof Uint8Array.from === 'function'
        ? Uint8Array.from.bind(Uint8Array)
        : function (it, fn) {
            if (fn === void 0) { fn = function (x) { return x; }; }
            return new Uint8Array(Array.prototype.slice.call(it, 0).map(fn));
        };
    var _mkUriSafe = function (src) { return src
        .replace(/=/g, '').replace(/[+\/]/g, function (m0) { return m0 == '+' ? '-' : '_'; }); };
    var _tidyB64 = function (s) { return s.replace(/[^A-Za-z0-9\+\/]/g, ''); };
    /**
     * polyfill version of `btoa`
     */
    var btoaPolyfill = function (bin) {
        // console.log('polyfilled');
        var u32, c0, c1, c2, asc = '';
        var pad = bin.length % 3;
        for (var i = 0; i < bin.length;) {
            if ((c0 = bin.charCodeAt(i++)) > 255 ||
                (c1 = bin.charCodeAt(i++)) > 255 ||
                (c2 = bin.charCodeAt(i++)) > 255)
                throw new TypeError('invalid character found');
            u32 = (c0 << 16) | (c1 << 8) | c2;
            asc += b64chs[u32 >> 18 & 63]
                + b64chs[u32 >> 12 & 63]
                + b64chs[u32 >> 6 & 63]
                + b64chs[u32 & 63];
        }
        return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
    };
    /**
     * does what `window.btoa` of web browsers do.
     * @param {String} bin binary string
     * @returns {string} Base64-encoded string
     */
    var _btoa = _hasbtoa ? function (bin) { return btoa(bin); }
        : _hasBuffer ? function (bin) { return Buffer.from(bin, 'binary').toString('base64'); }
            : btoaPolyfill;
    var _fromUint8Array = _hasBuffer
        ? function (u8a) { return Buffer.from(u8a).toString('base64'); }
        : function (u8a) {
            // cf. https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string/12713326#12713326
            var maxargs = 0x1000;
            var strs = [];
            for (var i = 0, l = u8a.length; i < l; i += maxargs) {
                strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
            }
            return _btoa(strs.join(''));
        };
    /**
     * converts a Uint8Array to a Base64 string.
     * @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 §5
     * @returns {string} Base64 string
     */
    var fromUint8Array = function (u8a, urlsafe) {
        if (urlsafe === void 0) { urlsafe = false; }
        return urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
    };
    // This trick is found broken https://github.com/dankogai/js-base64/issues/130
    // const utob = (src: string) => unescape(encodeURIComponent(src));
    // reverting good old fationed regexp
    var cb_utob = function (c) {
        if (c.length < 2) {
            var cc = c.charCodeAt(0);
            return cc < 0x80 ? c
                : cc < 0x800 ? (_fromCC(0xc0 | (cc >>> 6))
                    + _fromCC(0x80 | (cc & 0x3f)))
                    : (_fromCC(0xe0 | ((cc >>> 12) & 0x0f))
                        + _fromCC(0x80 | ((cc >>> 6) & 0x3f))
                        + _fromCC(0x80 | (cc & 0x3f)));
        }
        else {
            var cc = 0x10000
                + (c.charCodeAt(0) - 0xD800) * 0x400
                + (c.charCodeAt(1) - 0xDC00);
            return (_fromCC(0xf0 | ((cc >>> 18) & 0x07))
                + _fromCC(0x80 | ((cc >>> 12) & 0x3f))
                + _fromCC(0x80 | ((cc >>> 6) & 0x3f))
                + _fromCC(0x80 | (cc & 0x3f)));
        }
    };
    var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
    /**
     * @deprecated should have been internal use only.
     * @param {string} src UTF-8 string
     * @returns {string} UTF-16 string
     */
    var utob = function (u) { return u.replace(re_utob, cb_utob); };
    //
    var _encode = _hasBuffer
        ? function (s) { return Buffer.from(s, 'utf8').toString('base64'); }
        : _TE
            ? function (s) { return _fromUint8Array(_TE.encode(s)); }
            : function (s) { return _btoa(utob(s)); };
    /**
     * converts a UTF-8-encoded string to a Base64 string.
     * @param {boolean} [urlsafe] if `true` make the result URL-safe
     * @returns {string} Base64 string
     */
    var encode = function (src, urlsafe) {
        if (urlsafe === void 0) { urlsafe = false; }
        return urlsafe
            ? _mkUriSafe(_encode(src))
            : _encode(src);
    };
    /**
     * converts a UTF-8-encoded string to URL-safe Base64 RFC4648 §5.
     * @returns {string} Base64 string
     */
    var encodeURI = function (src) { return encode(src, true); };
    // This trick is found broken https://github.com/dankogai/js-base64/issues/130
    // const btou = (src: string) => decodeURIComponent(escape(src));
    // reverting good old fationed regexp
    var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
    var cb_btou = function (cccc) {
        switch (cccc.length) {
            case 4:
                var cp = ((0x07 & cccc.charCodeAt(0)) << 18)
                    | ((0x3f & cccc.charCodeAt(1)) << 12)
                    | ((0x3f & cccc.charCodeAt(2)) << 6)
                    | (0x3f & cccc.charCodeAt(3)), offset = cp - 0x10000;
                return (_fromCC((offset >>> 10) + 0xD800)
                    + _fromCC((offset & 0x3FF) + 0xDC00));
            case 3:
                return _fromCC(((0x0f & cccc.charCodeAt(0)) << 12)
                    | ((0x3f & cccc.charCodeAt(1)) << 6)
                    | (0x3f & cccc.charCodeAt(2)));
            default:
                return _fromCC(((0x1f & cccc.charCodeAt(0)) << 6)
                    | (0x3f & cccc.charCodeAt(1)));
        }
    };
    /**
     * @deprecated should have been internal use only.
     * @param {string} src UTF-16 string
     * @returns {string} UTF-8 string
     */
    var btou = function (b) { return b.replace(re_btou, cb_btou); };
    /**
     * polyfill version of `atob`
     */
    var atobPolyfill = function (asc) {
        // console.log('polyfilled');
        asc = asc.replace(/\s+/g, '');
        if (!b64re.test(asc))
            throw new TypeError('malformed base64.');
        asc += '=='.slice(2 - (asc.length & 3));
        var u24, bin = '', r1, r2;
        for (var i = 0; i < asc.length;) {
            u24 = b64tab[asc.charAt(i++)] << 18
                | b64tab[asc.charAt(i++)] << 12
                | (r1 = b64tab[asc.charAt(i++)]) << 6
                | (r2 = b64tab[asc.charAt(i++)]);
            bin += r1 === 64 ? _fromCC(u24 >> 16 & 255)
                : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255)
                    : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
        }
        return bin;
    };
    /**
     * does what `window.atob` of web browsers do.
     * @param {String} asc Base64-encoded string
     * @returns {string} binary string
     */
    var _atob = _hasatob ? function (asc) { return atob(_tidyB64(asc)); }
        : _hasBuffer ? function (asc) { return Buffer.from(asc, 'base64').toString('binary'); }
            : atobPolyfill;
    //
    var _toUint8Array = _hasBuffer
        ? function (a) { return _U8Afrom(Buffer.from(a, 'base64')); }
        : function (a) { return _U8Afrom(_atob(a), function (c) { return c.charCodeAt(0); }); };
    /**
     * converts a Base64 string to a Uint8Array.
     */
    var toUint8Array = function (a) { return _toUint8Array(_unURI(a)); };
    //
    var _decode = _hasBuffer
        ? function (a) { return Buffer.from(a, 'base64').toString('utf8'); }
        : _TD
            ? function (a) { return _TD.decode(_toUint8Array(a)); }
            : function (a) { return btou(_atob(a)); };
    var _unURI = function (a) { return _tidyB64(a.replace(/[-_]/g, function (m0) { return m0 == '-' ? '+' : '/'; })); };
    /**
     * converts a Base64 string to a UTF-8 string.
     * @param {String} src Base64 string.  Both normal and URL-safe are supported
     * @returns {string} UTF-8 string
     */
    var decode = function (src) { return _decode(_unURI(src)); };
    /**
     * check if a value is a valid Base64 string
     * @param {String} src a value to check
      */
    var isValid = function (src) {
        if (typeof src !== 'string')
            return false;
        var s = src.replace(/\s+/g, '').replace(/={0,2}$/, '');
        return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
    };
    //
    var _noEnum = function (v) {
        return {
            value: v, enumerable: false, writable: true, configurable: true
        };
    };
    /**
     * extend String.prototype with relevant methods
     */
    var extendString = function () {
        var _add = function (name, body) { return Object.defineProperty(String.prototype, name, _noEnum(body)); };
        _add('fromBase64', function () { return decode(this); });
        _add('toBase64', function (urlsafe) { return encode(this, urlsafe); });
        _add('toBase64URI', function () { return encode(this, true); });
        _add('toBase64URL', function () { return encode(this, true); });
        _add('toUint8Array', function () { return toUint8Array(this); });
    };
    /**
     * extend Uint8Array.prototype with relevant methods
     */
    var extendUint8Array = function () {
        var _add = function (name, body) { return Object.defineProperty(Uint8Array.prototype, name, _noEnum(body)); };
        _add('toBase64', function (urlsafe) { return fromUint8Array(this, urlsafe); });
        _add('toBase64URI', function () { return fromUint8Array(this, true); });
        _add('toBase64URL', function () { return fromUint8Array(this, true); });
    };
    /**
     * extend Builtin prototypes with relevant methods
     */
    var extendBuiltins = function () {
        extendString();
        extendUint8Array();
    };
    var gBase64 = {
        version: version,
        VERSION: VERSION,
        atob: _atob,
        atobPolyfill: atobPolyfill,
        btoa: _btoa,
        btoaPolyfill: btoaPolyfill,
        fromBase64: decode,
        toBase64: encode,
        encode: encode,
        encodeURI: encodeURI,
        encodeURL: encodeURI,
        utob: utob,
        btou: btou,
        decode: decode,
        isValid: isValid,
        fromUint8Array: fromUint8Array,
        toUint8Array: toUint8Array,
        extendString: extendString,
        extendUint8Array: extendUint8Array,
        extendBuiltins: extendBuiltins
    };
    //
    // export Base64 to the namespace
    //
    // ES5 is yet to have Object.assign() that may make transpilers unhappy.
    // gBase64.Base64 = Object.assign({}, gBase64);
    gBase64.Base64 = {};
    Object.keys(gBase64).forEach(function (k) { return gBase64.Base64[k] = gBase64[k]; });
    return gBase64;
}));

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)

},{"buffer":50}],53:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],54:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty
  , undef;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String|Null} The decoded string.
 * @api private
 */
function decode(input) {
  try {
    return decodeURIComponent(input.replace(/\+/g, ' '));
  } catch (e) {
    return null;
  }
}

/**
 * Attempts to encode a given input.
 *
 * @param {String} input The string that needs to be encoded.
 * @returns {String|Null} The encoded string.
 * @api private
 */
function encode(input) {
  try {
    return encodeURIComponent(input);
  } catch (e) {
    return null;
  }
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?#&]+)=?([^&]*)/g
    , result = {}
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    // In the case if failed decoding, we want to omit the key/value pairs
    // from the result.
    //
    if (key === null || value === null || key in result) continue;
    result[key] = value;
  }

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = []
    , value
    , key;

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (key in obj) {
    if (has.call(obj, key)) {
      value = obj[key];

      //
      // Edge cases where we actually want to encode the value to an empty
      // string instead of the stringified value.
      //
      if (!value && (value === null || value === undef || isNaN(value))) {
        value = '';
      }

      key = encode(key);
      value = encode(value);

      //
      // If we failed to encode the strings, we should bail out as we don't
      // want to add invalid strings to the query.
      //
      if (key === null || value === null) continue;
      pairs.push(key +'='+ value);
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;

},{}],55:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = GeneratorFunctionPrototype;
  define(Gp, "constructor", GeneratorFunctionPrototype);
  define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  });
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  define(Gp, iteratorSymbol, function() {
    return this;
  });

  define(Gp, "toString", function() {
    return "[object Generator]";
  });

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
  typeof module === "object" ? module.exports : {}
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, in modern engines
  // we can explicitly access globalThis. In older engines we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}

},{}],56:[function(require,module,exports){
'use strict';

/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};

},{}],57:[function(require,module,exports){
(function (global){(function (){
'use strict';

var required = require('requires-port')
  , qs = require('querystringify')
  , controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/
  , CRHTLF = /[\n\r\t]/g
  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//
  , port = /:\d+$/
  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i
  , windowsDriveLetter = /^[a-zA-Z]:/;

/**
 * Remove control characters and whitespace from the beginning of a string.
 *
 * @param {Object|String} str String to trim.
 * @returns {String} A new string representing `str` stripped of control
 *     characters and whitespace from its beginning.
 * @public
 */
function trimLeft(str) {
  return (str ? str : '').toString().replace(controlOrWhitespace, '');
}

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  function sanitize(address, url) {     // Sanitize what is left of the address
    return isSpecial(url.protocol) ? address.replace(/\\/g, '/') : address;
  },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d*)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
function lolcation(loc) {
  var globalVar;

  if (typeof window !== 'undefined') globalVar = window;
  else if (typeof global !== 'undefined') globalVar = global;
  else if (typeof self !== 'undefined') globalVar = self;
  else globalVar = {};

  var location = globalVar.location || {};
  loc = loc || location;

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * Check whether a protocol scheme is special.
 *
 * @param {String} The protocol scheme of the URL
 * @return {Boolean} `true` if the protocol scheme is special, else `false`
 * @private
 */
function isSpecial(scheme) {
  return (
    scheme === 'file:' ||
    scheme === 'ftp:' ||
    scheme === 'http:' ||
    scheme === 'https:' ||
    scheme === 'ws:' ||
    scheme === 'wss:'
  );
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @param {Object} location
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
function extractProtocol(address, location) {
  address = trimLeft(address);
  address = address.replace(CRHTLF, '');
  location = location || {};

  var match = protocolre.exec(address);
  var protocol = match[1] ? match[1].toLowerCase() : '';
  var forwardSlashes = !!match[2];
  var otherSlashes = !!match[3];
  var slashesCount = 0;
  var rest;

  if (forwardSlashes) {
    if (otherSlashes) {
      rest = match[2] + match[3] + match[4];
      slashesCount = match[2].length + match[3].length;
    } else {
      rest = match[2] + match[4];
      slashesCount = match[2].length;
    }
  } else {
    if (otherSlashes) {
      rest = match[3] + match[4];
      slashesCount = match[3].length;
    } else {
      rest = match[4]
    }
  }

  if (protocol === 'file:') {
    if (slashesCount >= 2) {
      rest = rest.slice(2);
    }
  } else if (isSpecial(protocol)) {
    rest = match[4];
  } else if (protocol) {
    if (forwardSlashes) {
      rest = rest.slice(2);
    }
  } else if (slashesCount >= 2 && isSpecial(location.protocol)) {
    rest = match[4];
  }

  return {
    protocol: protocol,
    slashes: forwardSlashes || isSpecial(protocol),
    slashesCount: slashesCount,
    rest: rest
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
function resolve(relative, base) {
  if (relative === '') return base;

  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} [location] Location defaults for relative paths.
 * @param {Boolean|Function} [parser] Parser for the query string.
 * @private
 */
function Url(address, location, parser) {
  address = trimLeft(address);
  address = address.replace(CRHTLF, '');

  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '', location);
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (
    extracted.protocol === 'file:' && (
      extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) ||
    (!extracted.slashes &&
      (extracted.protocol ||
        extracted.slashesCount < 2 ||
        !isSpecial(url.protocol)))
  ) {
    instructions[3] = [/(.*)/, 'pathname'];
  }

  for (; i < instructions.length; i++) {
    instruction = instructions[i];

    if (typeof instruction === 'function') {
      address = instruction(address, url);
      continue;
    }

    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      index = parse === '@'
        ? address.lastIndexOf(parse)
        : address.indexOf(parse);

      if (~index) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // Default to a / for pathname if none exists. This normalizes the URL
  // to always have a /
  //
  if (url.pathname.charAt(0) !== '/' && isSpecial(url.protocol)) {
    url.pathname = '/' + url.pathname;
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';

  if (url.auth) {
    index = url.auth.indexOf(':');

    if (~index) {
      url.username = url.auth.slice(0, index);
      url.username = encodeURIComponent(decodeURIComponent(url.username));

      url.password = url.auth.slice(index + 1);
      url.password = encodeURIComponent(decodeURIComponent(url.password))
    } else {
      url.username = encodeURIComponent(decodeURIComponent(url.auth));
    }

    url.auth = url.password ? url.username +':'+ url.password : url.username;
  }

  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (port.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    case 'username':
    case 'password':
      url[part] = encodeURIComponent(value);
      break;

    case 'auth':
      var index = value.indexOf(':');

      if (~index) {
        url.username = value.slice(0, index);
        url.username = encodeURIComponent(decodeURIComponent(url.username));

        url.password = value.slice(index + 1);
        url.password = encodeURIComponent(decodeURIComponent(url.password));
      } else {
        url.username = encodeURIComponent(decodeURIComponent(value));
      }
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.auth = url.password ? url.username +':'+ url.password : url.username;

  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , host = url.host
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result =
    protocol +
    ((url.protocol && url.slashes) || isSpecial(url.protocol) ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  } else if (url.password) {
    result += ':'+ url.password;
    result += '@';
  } else if (
    url.protocol !== 'file:' &&
    isSpecial(url.protocol) &&
    !host &&
    url.pathname !== '/'
  ) {
    //
    // Add back the empty userinfo, otherwise the original invalid URL
    // might be transformed into a valid one with `url.pathname` as host.
    //
    result += '@';
  }

  //
  // Trailing colon is removed from `url.host` when it is parsed. If it still
  // ends with a colon, then add back the trailing colon that was removed. This
  // prevents an invalid URL from being transformed into a valid one.
  //
  if (host[host.length - 1] === ':' || (port.test(url.hostname) && !url.port)) {
    host += ':';
  }

  result += host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

Url.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.trimLeft = trimLeft;
Url.qs = qs;

module.exports = Url;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"querystringify":54,"requires-port":56}],58:[function(require,module,exports){
"use strict";

require("regenerator-runtime/runtime");

// The regenerator runtime is needed since the test use functions
// with the async/await keywords. See
// https://babeljs.io/docs/en/babel-plugin-transform-regenerator
beforeEach(function () {
  // Clear localStorage before every test to prevent stored URLs to
  // interfere with our setup.
  localStorage.clear();
});

require('./test-common');

require('./test-browser-specific');

require('./test-parallel-uploads');

require('./test-parallel-stagger-uploads');

require('./test-terminate');

require('./test-end-to-end');

},{"./test-browser-specific":61,"./test-common":62,"./test-end-to-end":63,"./test-parallel-stagger-uploads":64,"./test-parallel-uploads":65,"./test-terminate":66,"regenerator-runtime/runtime":55}],59:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

module.exports = /*#__PURE__*/function () {
  var _assertUrlStorage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(urlStorage) {
    var result, key1, key2, key3;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return urlStorage.findAllUploads();

          case 2:
            result = _context.sent;
            expect(result).toEqual([]); // Add a few uploads into the storage

            _context.next = 6;
            return urlStorage.addUpload('fingerprintA', {
              id: 1
            });

          case 6:
            key1 = _context.sent;
            _context.next = 9;
            return urlStorage.addUpload('fingerprintA', {
              id: 2
            });

          case 9:
            key2 = _context.sent;
            _context.next = 12;
            return urlStorage.addUpload('fingerprintB', {
              id: 3
            });

          case 12:
            key3 = _context.sent;
            expect(/^tus::fingerprintA::/.test(key1)).toBe(true);
            expect(/^tus::fingerprintA::/.test(key2)).toBe(true);
            expect(/^tus::fingerprintB::/.test(key3)).toBe(true); // Query the just stored uploads individually

            _context.next = 18;
            return urlStorage.findUploadsByFingerprint('fingerprintA');

          case 18:
            result = _context.sent;
            sort(result);
            expect(result).toEqual([{
              id: 1,
              urlStorageKey: key1
            }, {
              id: 2,
              urlStorageKey: key2
            }]);
            _context.next = 23;
            return urlStorage.findUploadsByFingerprint('fingerprintB');

          case 23:
            result = _context.sent;
            sort(result);
            expect(result).toEqual([{
              id: 3,
              urlStorageKey: key3
            }]); // Check that we can retrieve all stored uploads

            _context.next = 28;
            return urlStorage.findAllUploads();

          case 28:
            result = _context.sent;
            sort(result);
            expect(result).toEqual([{
              id: 1,
              urlStorageKey: key1
            }, {
              id: 2,
              urlStorageKey: key2
            }, {
              id: 3,
              urlStorageKey: key3
            }]); // Check that it can remove an upload and will not return it back

            _context.next = 33;
            return urlStorage.removeUpload(key2);

          case 33:
            _context.next = 35;
            return urlStorage.removeUpload(key3);

          case 35:
            _context.next = 37;
            return urlStorage.findUploadsByFingerprint('fingerprintA');

          case 37:
            result = _context.sent;
            expect(result).toEqual([{
              id: 1,
              urlStorageKey: key1
            }]);
            _context.next = 41;
            return urlStorage.findUploadsByFingerprint('fingerprintB');

          case 41:
            result = _context.sent;
            expect(result).toEqual([]);

          case 43:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  function assertUrlStorage(_x) {
    return _assertUrlStorage.apply(this, arguments);
  }

  return assertUrlStorage;
}(); // Sort the results from the URL storage since the order in not deterministic.


function sort(result) {
  result.sort(function (a, b) {
    return a.id - b.id;
  });
}

},{}],60:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/* eslint-disable max-classes-per-file */
var isBrowser = typeof window !== 'undefined';
var isNode = !isBrowser;
/**
 * Obtain a platform specific buffer object, which can be
 * handled by tus-js-client.
 */

function getBlob(str) {
  if (isNode) {
    return Buffer.from(str);
  }

  return new Blob(str.split(''));
}
/**
 * Create a promise and obtain the resolve/reject functions
 * outside of the Promise callback.
 */


function flatPromise() {
  var resolveFn;
  var rejectFn;
  var p = new Promise(function (resolve, reject) {
    resolveFn = resolve;
    rejectFn = reject;
  });
  return [p, resolveFn, rejectFn];
}
/**
 * Create a spy-able function which resolves a Promise
 * once it is called.
 */


function waitableFunction() {
  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'func';

  var _flatPromise = flatPromise(),
      _flatPromise2 = _slicedToArray(_flatPromise, 2),
      promise = _flatPromise2[0],
      resolve = _flatPromise2[1];

  var fn = jasmine.createSpy(name, resolve).and.callThrough();
  fn.toBeCalled = promise;
  return fn;
}
/**
 * Create a Promise that resolves after the specified duration.
 */


function wait(delay) {
  return new Promise(function (resolve) {
    return setTimeout(resolve, delay, 'timed out');
  });
}
/**
 * TestHttpStack implements the HTTP stack interface for tus-js-client
 * and can be used to assert outgoing requests and respond with mock data.
 */


var TestHttpStack = /*#__PURE__*/function () {
  function TestHttpStack() {
    _classCallCheck(this, TestHttpStack);

    this._pendingRequests = [];
    this._pendingWaits = [];
  }

  _createClass(TestHttpStack, [{
    key: "createRequest",
    value: function createRequest(method, url) {
      var _this = this;

      return new TestRequest(method, url, function (req) {
        if (_this._pendingWaits.length >= 1) {
          var handler = _this._pendingWaits.shift();

          handler(req);
          return;
        }

        _this._pendingRequests.push(req);
      });
    }
  }, {
    key: "nextRequest",
    value: function nextRequest() {
      var _this2 = this;

      if (this._pendingRequests.length >= 1) {
        return Promise.resolve(this._pendingRequests.shift());
      }

      return new Promise(function (resolve) {
        _this2._pendingWaits.push(resolve);
      });
    }
  }]);

  return TestHttpStack;
}();

var TestRequest = /*#__PURE__*/function () {
  function TestRequest(method, url, onRequestSend) {
    _classCallCheck(this, TestRequest);

    this.method = method;
    this.url = url;
    this.requestHeaders = {};
    this.body = null;
    this._onRequestSend = onRequestSend;

    this._onProgress = function () {};

    var _flatPromise3 = flatPromise();

    var _flatPromise4 = _slicedToArray(_flatPromise3, 3);

    this._requestPromise = _flatPromise4[0];
    this._resolveRequest = _flatPromise4[1];
    this._rejectRequest = _flatPromise4[2];
  }

  _createClass(TestRequest, [{
    key: "getMethod",
    value: function getMethod() {
      return this.method;
    }
  }, {
    key: "getURL",
    value: function getURL() {
      return this.url;
    }
  }, {
    key: "setHeader",
    value: function setHeader(header, value) {
      this.requestHeaders[header] = value;
    }
  }, {
    key: "getHeader",
    value: function getHeader(header) {
      return this.requestHeaders[header] || null;
    }
  }, {
    key: "setProgressHandler",
    value: function setProgressHandler(progressHandler) {
      this._onProgress = progressHandler;
    }
  }, {
    key: "send",
    value: function send() {
      var body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      this.body = body;

      if (body) {
        this._onProgress(0);

        this._onProgress(body.length || body.size || 0);
      }

      this._onRequestSend(this);

      return this._requestPromise;
    }
  }, {
    key: "abort",
    value: function abort() {
      this._rejectRequest(new Error('request aborted'));
    }
  }, {
    key: "getUnderlyingObject",
    value: function getUnderlyingObject() {
      throw new Error('not implemented');
    }
  }, {
    key: "respondWith",
    value: function respondWith(resData) {
      resData.responseHeaders = resData.responseHeaders || {};
      var res = new TestResponse(resData);

      this._resolveRequest(res);
    }
  }, {
    key: "responseError",
    value: function responseError(err) {
      this._rejectRequest(err);
    }
  }]);

  return TestRequest;
}();

var TestResponse = /*#__PURE__*/function () {
  function TestResponse(res) {
    _classCallCheck(this, TestResponse);

    this._response = res;
  }

  _createClass(TestResponse, [{
    key: "getStatus",
    value: function getStatus() {
      return this._response.status;
    }
  }, {
    key: "getHeader",
    value: function getHeader(header) {
      return this._response.responseHeaders[header];
    }
  }, {
    key: "getBody",
    value: function getBody() {
      return this._response.responseText;
    }
  }, {
    key: "getUnderlyingObject",
    value: function getUnderlyingObject() {
      throw new Error('not implemented');
    }
  }]);

  return TestResponse;
}();

module.exports = {
  TestHttpStack: TestHttpStack,
  waitableFunction: waitableFunction,
  wait: wait,
  getBlob: getBlob
};

}).call(this)}).call(this,require("buffer").Buffer)

},{"buffer":50}],61:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var assertUrlStorage = require('./helpers/assertUrlStorage');

var _require = require('./helpers/utils'),
    TestHttpStack = _require.TestHttpStack,
    waitableFunction = _require.waitableFunction,
    wait = _require.wait;

var tus = require('../..');

describe('tus', function () {
  beforeEach(function () {
    localStorage.clear();
  });
  describe('#Upload', function () {
    it('should resume an upload from a stored url', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var testStack, file, options, upload, previousUploads, req;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              localStorage.setItem('tus::fingerprinted::1337', JSON.stringify({
                uploadUrl: 'http://tus.io/uploads/resuming'
              }));
              testStack = new TestHttpStack();
              file = new Blob('hello world'.split(''));
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                onProgress: function onProgress() {},
                fingerprint: function fingerprint() {}
              };
              spyOn(options, 'fingerprint').and.resolveTo('fingerprinted');
              spyOn(options, 'onProgress');
              upload = new tus.Upload(file, options);
              _context.next = 9;
              return upload.findPreviousUploads();

            case 9:
              previousUploads = _context.sent;
              expect(previousUploads).toEqual([{
                uploadUrl: 'http://tus.io/uploads/resuming',
                urlStorageKey: 'tus::fingerprinted::1337'
              }]);
              upload.resumeFromPreviousUpload(previousUploads[0]);
              upload.start();
              expect(options.fingerprint).toHaveBeenCalledWith(file, upload.options);
              _context.next = 16;
              return testStack.nextRequest();

            case 16:
              req = _context.sent;
              expect(req.url).toBe('http://tus.io/uploads/resuming');
              expect(req.method).toBe('HEAD');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Length': 11,
                  'Upload-Offset': 3
                }
              });
              _context.next = 23;
              return testStack.nextRequest();

            case 23:
              req = _context.sent;
              expect(req.url).toBe('http://tus.io/uploads/resuming');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(3);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(11 - 3);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 11
                }
              });
              expect(upload.url).toBe('http://tus.io/uploads/resuming');
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);

            case 33:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));
    describe('storing of upload urls', function () {
      var testStack = new TestHttpStack();
      var options = {
        httpStack: testStack,
        endpoint: 'http://tus.io/uploads',
        fingerprint: function fingerprint() {}
      };

      function startUpload() {
        return _startUpload.apply(this, arguments);
      }

      function _startUpload() {
        _startUpload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
          var file, upload, req;
          return _regeneratorRuntime().wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  file = new Blob('hello world'.split(''));
                  spyOn(options, 'fingerprint').and.resolveTo('fingerprinted');
                  options.onSuccess = waitableFunction('onSuccess');
                  upload = new tus.Upload(file, options);
                  upload.start();
                  expect(options.fingerprint).toHaveBeenCalled();
                  _context5.next = 8;
                  return testStack.nextRequest();

                case 8:
                  req = _context5.sent;
                  expect(req.url).toBe('http://tus.io/uploads');
                  expect(req.method).toBe('POST');
                  req.respondWith({
                    status: 201,
                    responseHeaders: {
                      Location: '/uploads/blargh'
                    }
                  }); // Wait a short delay to allow the Promises to settle

                  _context5.next = 14;
                  return wait(10);

                case 14:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5);
        }));
        return _startUpload.apply(this, arguments);
      }

      function finishUpload() {
        return _finishUpload.apply(this, arguments);
      }

      function _finishUpload() {
        _finishUpload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
          var req;
          return _regeneratorRuntime().wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  _context6.next = 2;
                  return testStack.nextRequest();

                case 2:
                  req = _context6.sent;
                  expect(req.url).toBe('http://tus.io/uploads/blargh');
                  expect(req.method).toBe('PATCH');
                  req.respondWith({
                    status: 204,
                    responseHeaders: {
                      'Upload-Offset': 11
                    }
                  });
                  _context6.next = 8;
                  return options.onSuccess.toBeCalled;

                case 8:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6);
        }));
        return _finishUpload.apply(this, arguments);
      }

      it('should store and retain with default options', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var key, storedUpload;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                options.removeFingerprintOnSuccess = false;
                _context2.next = 3;
                return startUpload();

              case 3:
                key = localStorage.key(0);
                expect(key.indexOf('tus::fingerprinted::')).toBe(0);
                storedUpload = JSON.parse(localStorage.getItem(key));
                expect(storedUpload.uploadUrl).toBe('http://tus.io/uploads/blargh');
                expect(storedUpload.size).toBe(11);
                _context2.next = 10;
                return finishUpload();

              case 10:
                expect(localStorage.getItem(key)).toBe(JSON.stringify(storedUpload));

              case 11:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      })));
      it('should store and remove with option removeFingerprintOnSuccess set', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        var key, storedUpload;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                options.removeFingerprintOnSuccess = true;
                _context3.next = 3;
                return startUpload();

              case 3:
                key = localStorage.key(0);
                expect(key.indexOf('tus::fingerprinted::')).toBe(0);
                storedUpload = JSON.parse(localStorage.getItem(key));
                expect(storedUpload.uploadUrl).toBe('http://tus.io/uploads/blargh');
                expect(storedUpload.size).toBe(11);
                _context3.next = 10;
                return finishUpload();

              case 10:
                expect(localStorage.getItem(key)).toBe(null);

              case 11:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      })));
      it('should store URLs passed in using the uploadUrl option', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
        var file, options2, upload, req, key, storedUpload;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                file = new Blob('hello world'.split(''));
                options2 = {
                  httpStack: testStack,
                  uploadUrl: 'http://tus.io/uploads/storedUrl',
                  fingerprint: function fingerprint() {},
                  onSuccess: waitableFunction('onSuccess'),
                  removeFingerprintOnSuccess: true
                };
                spyOn(options2, 'fingerprint').and.resolveTo('fingerprinted');
                upload = new tus.Upload(file, options2);
                upload.start();
                expect(options2.fingerprint).toHaveBeenCalled();
                _context4.next = 8;
                return testStack.nextRequest();

              case 8:
                req = _context4.sent;
                expect(req.url).toBe('http://tus.io/uploads/storedUrl');
                expect(req.method).toBe('HEAD');
                expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Length': 11,
                    'Upload-Offset': 3
                  }
                }); // Wait a short delay to allow the Promises to settle

                _context4.next = 15;
                return wait(10);

              case 15:
                key = localStorage.key(0);
                expect(key.indexOf('tus::fingerprinted::')).toBe(0);
                storedUpload = JSON.parse(localStorage.getItem(key));
                expect(storedUpload.uploadUrl).toBe('http://tus.io/uploads/storedUrl');
                expect(storedUpload.size).toBe(11);
                _context4.next = 22;
                return testStack.nextRequest();

              case 22:
                req = _context4.sent;
                expect(req.url).toBe('http://tus.io/uploads/storedUrl');
                expect(req.method).toBe('PATCH');
                expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
                expect(req.requestHeaders['Upload-Offset']).toBe(3);
                expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
                expect(req.body.size).toBe(11 - 3);
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 11
                  }
                });
                _context4.next = 32;
                return options2.onSuccess.toBeCalled;

              case 32:
                // Entry in localStorage should be removed after successful upload
                expect(localStorage.getItem(key)).toBe(null);

              case 33:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      })));
    });
    it('should delete upload urls on a 4XX', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
      var testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              testStack = new TestHttpStack();
              file = new Blob('hello world'.split(''));
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                fingerprint: function fingerprint() {}
              };
              spyOn(options, 'fingerprint').and.resolveTo('fingerprinted');
              upload = new tus.Upload(file, options);
              upload.resumeFromPreviousUpload({
                uploadUrl: 'http://tus.io/uploads/resuming',
                urlStorageKey: 'tus::fingerprinted::1337'
              });
              upload.start();
              _context7.next = 9;
              return testStack.nextRequest();

            case 9:
              req = _context7.sent;
              expect(req.url).toBe('http://tus.io/uploads/resuming');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 400
              });
              _context7.next = 15;
              return wait(10);

            case 15:
              expect(localStorage.getItem('tus::fingerprinted::1337')).toBe(null);

            case 16:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7);
    })));
    describe('uploading data from a Reader', function () {
      function makeReader(content) {
        var readSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : content.length;
        var reader = {
          value: content.split(''),
          read: function read() {
            var value;
            var done = false;

            if (this.value.length > 0) {
              value = this.value.slice(0, readSize);
              this.value = this.value.slice(readSize);
            } else {
              done = true;
            }

            return Promise.resolve({
              value: value,
              done: done
            });
          },
          cancel: waitableFunction('cancel')
        };
        return reader;
      }

      function assertReaderUpload(_x) {
        return _assertReaderUpload.apply(this, arguments);
      }

      function _assertReaderUpload() {
        _assertReaderUpload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(_ref6) {
          var readSize, chunkSize, reader, testStack, options, upload, req;
          return _regeneratorRuntime().wrap(function _callee14$(_context14) {
            while (1) {
              switch (_context14.prev = _context14.next) {
                case 0:
                  readSize = _ref6.readSize, chunkSize = _ref6.chunkSize;
                  reader = makeReader('hello world', readSize);
                  testStack = new TestHttpStack();
                  options = {
                    httpStack: testStack,
                    endpoint: 'http://tus.io/uploads',
                    chunkSize: chunkSize,
                    onProgress: waitableFunction('onProgress'),
                    onSuccess: waitableFunction('onSuccess'),
                    fingerprint: function fingerprint() {},
                    uploadLengthDeferred: true
                  };
                  spyOn(options, 'fingerprint').and.resolveTo('fingerprinted');
                  upload = new tus.Upload(reader, options);
                  upload.start();
                  expect(options.fingerprint).toHaveBeenCalledWith(reader, upload.options);
                  _context14.next = 10;
                  return testStack.nextRequest();

                case 10:
                  req = _context14.sent;
                  expect(req.url).toBe('http://tus.io/uploads');
                  expect(req.method).toBe('POST');
                  expect(req.requestHeaders['Upload-Length']).toBe(undefined);
                  expect(req.requestHeaders['Upload-Defer-Length']).toBe(1);
                  req.respondWith({
                    status: 201,
                    responseHeaders: {
                      Location: 'http://tus.io/uploads/blargh'
                    }
                  });
                  _context14.next = 18;
                  return testStack.nextRequest();

                case 18:
                  req = _context14.sent;
                  expect(req.url).toBe('http://tus.io/uploads/blargh');
                  expect(req.method).toBe('PATCH');
                  expect(req.requestHeaders['Upload-Offset']).toBe(0);
                  expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
                  expect(req.body.length).toBe(11);
                  req.respondWith({
                    status: 204,
                    responseHeaders: {
                      'Upload-Offset': 11
                    }
                  });
                  _context14.next = 27;
                  return options.onProgress.toBeCalled;

                case 27:
                  expect(options.onProgress).toHaveBeenCalledWith(11, null);
                  _context14.next = 30;
                  return testStack.nextRequest();

                case 30:
                  req = _context14.sent;
                  expect(req.url).toBe('http://tus.io/uploads/blargh');
                  expect(req.method).toBe('PATCH');
                  expect(req.requestHeaders['Upload-Offset']).toBe(11);
                  expect(req.requestHeaders['Upload-Length']).toBe(11);
                  expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
                  expect(req.body).toBe(null);
                  req.respondWith({
                    status: 204,
                    responseHeaders: {
                      'Upload-Offset': 11
                    }
                  });
                  _context14.next = 40;
                  return options.onSuccess.toBeCalled;

                case 40:
                  expect(upload.url).toBe('http://tus.io/uploads/blargh');
                  expect(options.onProgress).toHaveBeenCalledWith(11, 11);

                case 42:
                case "end":
                  return _context14.stop();
              }
            }
          }, _callee14);
        }));
        return _assertReaderUpload.apply(this, arguments);
      }

      it('should upload data', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return assertReaderUpload({
                  chunkSize: 100,
                  readSize: 100
                });

              case 2:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8);
      })));
      it('should read multiple times from the reader', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return assertReaderUpload({
                  chunkSize: 100,
                  readSize: 6
                });

              case 2:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9);
      })));
      it('should use multiple PATCH requests', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
        var reader, testStack, options, upload, req;
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                reader = makeReader('hello world', 1);
                testStack = new TestHttpStack();
                options = {
                  httpStack: testStack,
                  endpoint: 'http://tus.io/uploads',
                  chunkSize: 6,
                  onProgress: waitableFunction('onProgress'),
                  onSuccess: waitableFunction('onSuccess'),
                  fingerprint: function fingerprint() {},
                  uploadLengthDeferred: true
                };
                spyOn(options, 'fingerprint').and.resolveTo('fingerprinted');
                upload = new tus.Upload(reader, options);
                upload.start();
                expect(options.fingerprint).toHaveBeenCalledWith(reader, upload.options);
                _context10.next = 9;
                return testStack.nextRequest();

              case 9:
                req = _context10.sent;
                expect(req.url).toBe('http://tus.io/uploads');
                expect(req.method).toBe('POST');
                expect(req.requestHeaders['Upload-Length']).toBe(undefined);
                expect(req.requestHeaders['Upload-Defer-Length']).toBe(1);
                req.respondWith({
                  status: 201,
                  responseHeaders: {
                    Location: 'http://tus.io/uploads/blargh'
                  }
                });
                _context10.next = 17;
                return testStack.nextRequest();

              case 17:
                req = _context10.sent;
                expect(req.url).toBe('http://tus.io/uploads/blargh');
                expect(req.method).toBe('PATCH');
                expect(req.requestHeaders['Upload-Offset']).toBe(0);
                expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
                expect(req.body.length).toBe(6);
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 6
                  }
                });
                _context10.next = 26;
                return options.onProgress.toBeCalled;

              case 26:
                expect(options.onProgress).toHaveBeenCalledWith(6, null);
                _context10.next = 29;
                return testStack.nextRequest();

              case 29:
                req = _context10.sent;
                expect(req.url).toBe('http://tus.io/uploads/blargh');
                expect(req.method).toBe('PATCH');
                expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
                expect(req.requestHeaders['Upload-Offset']).toBe(6);
                expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
                expect(req.body.length).toBe(5);
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 11
                  }
                });
                _context10.next = 39;
                return testStack.nextRequest();

              case 39:
                req = _context10.sent;
                expect(req.url).toBe('http://tus.io/uploads/blargh');
                expect(req.method).toBe('PATCH');
                expect(req.requestHeaders['Upload-Offset']).toBe(11);
                expect(req.requestHeaders['Upload-Length']).toBe(11);
                expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
                expect(req.body).toBe(null);
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 11
                  }
                });
                _context10.next = 49;
                return options.onSuccess.toBeCalled;

              case 49:
                expect(upload.url).toBe('http://tus.io/uploads/blargh');
                expect(options.onProgress).toHaveBeenCalledWith(11, 11);

              case 51:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10);
      })));
      it('should retry the POST request', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
        var reader, testStack, options, upload, req;
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                reader = makeReader('hello world', 1);
                testStack = new TestHttpStack();
                options = {
                  httpStack: testStack,
                  endpoint: 'http://tus.io/files/',
                  chunkSize: 11,
                  retryDelays: [10, 10, 10],
                  onSuccess: waitableFunction('onSuccess'),
                  uploadLengthDeferred: true
                };
                upload = new tus.Upload(reader, options);
                upload.start();
                _context11.next = 7;
                return testStack.nextRequest();

              case 7:
                req = _context11.sent;
                expect(req.url).toBe('http://tus.io/files/');
                expect(req.method).toBe('POST');
                req.respondWith({
                  status: 500
                });
                _context11.next = 13;
                return testStack.nextRequest();

              case 13:
                req = _context11.sent;
                expect(req.url).toBe('http://tus.io/files/');
                expect(req.method).toBe('POST');
                req.respondWith({
                  status: 201,
                  responseHeaders: {
                    Location: '/files/foo'
                  }
                });
                _context11.next = 19;
                return testStack.nextRequest();

              case 19:
                req = _context11.sent;
                expect(req.url).toBe('http://tus.io/files/foo');
                expect(req.method).toBe('PATCH');
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 11
                  }
                });
                _context11.next = 25;
                return testStack.nextRequest();

              case 25:
                req = _context11.sent;
                expect(req.url).toBe('http://tus.io/files/foo');
                expect(req.method).toBe('PATCH');
                expect(req.requestHeaders['Upload-Length']).toBe(11);
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 11
                  }
                });
                _context11.next = 32;
                return options.onSuccess.toBeCalled;

              case 32:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11);
      })));
      it('should retry the first PATCH request', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
        var reader, testStack, options, upload, req;
        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                reader = makeReader('hello world', 1);
                testStack = new TestHttpStack();
                options = {
                  httpStack: testStack,
                  endpoint: 'http://tus.io/files/',
                  chunkSize: 11,
                  retryDelays: [10, 10, 10],
                  onSuccess: waitableFunction('onSuccess'),
                  uploadLengthDeferred: true
                };
                upload = new tus.Upload(reader, options);
                upload.start();
                _context12.next = 7;
                return testStack.nextRequest();

              case 7:
                req = _context12.sent;
                expect(req.url).toBe('http://tus.io/files/');
                expect(req.method).toBe('POST');
                req.respondWith({
                  status: 201,
                  responseHeaders: {
                    Location: '/files/foo'
                  }
                });
                _context12.next = 13;
                return testStack.nextRequest();

              case 13:
                req = _context12.sent;
                expect(req.url).toBe('http://tus.io/files/foo');
                expect(req.method).toBe('PATCH');
                req.respondWith({
                  status: 500
                });
                _context12.next = 19;
                return testStack.nextRequest();

              case 19:
                req = _context12.sent;
                expect(req.url).toBe('http://tus.io/files/foo');
                expect(req.method).toBe('HEAD');
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 0
                  }
                });
                _context12.next = 25;
                return testStack.nextRequest();

              case 25:
                req = _context12.sent;
                expect(req.url).toBe('http://tus.io/files/foo');
                expect(req.method).toBe('PATCH');
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 11
                  }
                });
                _context12.next = 31;
                return testStack.nextRequest();

              case 31:
                req = _context12.sent;
                expect(req.url).toBe('http://tus.io/files/foo');
                expect(req.method).toBe('PATCH');
                expect(req.requestHeaders['Upload-Length']).toBe(11);
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 11
                  }
                });
                _context12.next = 38;
                return options.onSuccess.toBeCalled;

              case 38:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12);
      })));
      it('should retry following PATCH requests', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {
        var reader, testStack, options, upload, req;
        return _regeneratorRuntime().wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                reader = makeReader('hello world there!');
                testStack = new TestHttpStack();
                options = {
                  httpStack: testStack,
                  endpoint: 'http://tus.io/files/',
                  chunkSize: 6,
                  retryDelays: [10, 10, 10],
                  onSuccess: function onSuccess() {},
                  uploadLengthDeferred: true
                };
                upload = new tus.Upload(reader, options);
                upload.start();
                _context13.next = 7;
                return testStack.nextRequest();

              case 7:
                req = _context13.sent;
                expect(req.url).toBe('http://tus.io/files/');
                expect(req.method).toBe('POST');
                req.respondWith({
                  status: 201,
                  responseHeaders: {
                    Location: '/files/foo'
                  }
                });
                _context13.next = 13;
                return testStack.nextRequest();

              case 13:
                req = _context13.sent;
                expect(req.url).toBe('http://tus.io/files/foo');
                expect(req.method).toBe('PATCH');
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 6
                  }
                });
                _context13.next = 19;
                return testStack.nextRequest();

              case 19:
                req = _context13.sent;
                expect(req.url).toBe('http://tus.io/files/foo');
                expect(req.method).toBe('PATCH');
                req.respondWith({
                  status: 500
                });
                _context13.next = 25;
                return testStack.nextRequest();

              case 25:
                req = _context13.sent;
                expect(req.url).toBe('http://tus.io/files/foo');
                expect(req.method).toBe('HEAD');
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 6
                  }
                });
                _context13.next = 31;
                return testStack.nextRequest();

              case 31:
                req = _context13.sent;
                expect(req.url).toBe('http://tus.io/files/foo');
                expect(req.method).toBe('PATCH');
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 12
                  }
                });
                _context13.next = 37;
                return testStack.nextRequest();

              case 37:
                req = _context13.sent;
                expect(req.url).toBe('http://tus.io/files/foo');
                expect(req.method).toBe('PATCH');
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 18
                  }
                });
                _context13.next = 43;
                return testStack.nextRequest();

              case 43:
                req = _context13.sent;
                expect(req.url).toBe('http://tus.io/files/foo');
                expect(req.method).toBe('PATCH');
                expect(req.requestHeaders['Upload-Length']).toBe(18);
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 18
                  }
                });
                _context13.next = 50;
                return options.onSuccess.toBeCalled;

              case 50:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13);
      })));
    });
    describe('resolving of URIs', function () {
      // Disable these tests for IE 10 and 11 because it's not possible to overwrite
      // the navigator.product property.
      var isIE = navigator.userAgent.indexOf('Trident/') > 0;

      if (isIE) {
        console.log('Skipping tests for React Native in Internet Explorer'); // eslint-disable-line no-console

        return;
      }

      var originalProduct = navigator.product;
      beforeEach(function () {
        jasmine.Ajax.install(); // Simulate React Native environment to enable URIs as input objects.

        Object.defineProperty(navigator, 'product', {
          value: 'ReactNative',
          configurable: true
        });
      });
      afterEach(function () {
        jasmine.Ajax.uninstall();
        Object.defineProperty(navigator, 'product', {
          value: originalProduct,
          configurable: true
        });
      });
      it('should upload a file from an URI', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {
        var file, testStack, options, upload, req;
        return _regeneratorRuntime().wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                file = {
                  uri: 'file:///my/file.dat'
                };
                testStack = new TestHttpStack();
                options = {
                  httpStack: testStack,
                  endpoint: 'http://tus.io/uploads',
                  onSuccess: waitableFunction('onSuccess')
                };
                upload = new tus.Upload(file, options);
                upload.start(); // Wait a short interval to make sure that the XHR has been sent.

                _context15.next = 7;
                return wait(0);

              case 7:
                req = jasmine.Ajax.requests.mostRecent();
                expect(req.url).toBe('file:///my/file.dat');
                expect(req.method).toBe('GET');
                expect(req.responseType).toBe('blob');
                req.respondWith({
                  status: 200,
                  responseHeaders: {
                    'Upload-Length': 11,
                    'Upload-Offset': 3
                  },
                  response: new Blob('hello world'.split(''))
                });
                _context15.next = 14;
                return testStack.nextRequest();

              case 14:
                req = _context15.sent;
                expect(req.url).toBe('http://tus.io/uploads');
                expect(req.method).toBe('POST');
                expect(req.requestHeaders['Upload-Length']).toBe(11);
                req.respondWith({
                  status: 201,
                  responseHeaders: {
                    Location: '/uploads/blargh'
                  }
                });
                _context15.next = 21;
                return testStack.nextRequest();

              case 21:
                req = _context15.sent;
                expect(req.url).toBe('http://tus.io/uploads/blargh');
                expect(req.method).toBe('PATCH');
                expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
                expect(req.requestHeaders['Upload-Offset']).toBe(0);
                expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
                expect(req.body.size).toBe(11);
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 11
                  }
                });
                _context15.next = 31;
                return options.onSuccess.toBeCalled;

              case 31:
                expect(upload.url).toBe('http://tus.io/uploads/blargh');

              case 32:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15);
      })));
      it("should emit an error if it can't resolve the URI", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {
        var file, options, upload, req;
        return _regeneratorRuntime().wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                file = {
                  uri: 'file:///my/file.dat'
                };
                options = {
                  endpoint: 'http://tus.io/uploads',
                  onError: waitableFunction('onError')
                };
                upload = new tus.Upload(file, options);
                upload.start(); // Wait a short interval to make sure that the XHR has been sent.

                _context16.next = 6;
                return wait(0);

              case 6:
                req = jasmine.Ajax.requests.mostRecent();
                expect(req.url).toBe('file:///my/file.dat');
                expect(req.method).toBe('GET');
                expect(req.responseType).toBe('blob');
                req.responseError();
                _context16.next = 13;
                return options.onError.toBeCalled;

              case 13:
                expect(options.onError).toHaveBeenCalledWith(new Error('tus: cannot fetch `file.uri` as Blob, make sure the uri is correct and accessible. [object Object]'));

              case 14:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16);
      })));
    });
  });
  describe('#LocalStorageUrlStorage', function () {
    it('should allow storing and retrieving uploads', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {
      return _regeneratorRuntime().wrap(function _callee17$(_context17) {
        while (1) {
          switch (_context17.prev = _context17.next) {
            case 0:
              _context17.next = 2;
              return assertUrlStorage(tus.defaultOptions.urlStorage);

            case 2:
            case "end":
              return _context17.stop();
          }
        }
      }, _callee17);
    })));
  });
});

},{"../..":4,"./helpers/assertUrlStorage":59,"./helpers/utils":60}],62:[function(require,module,exports){
"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var _require = require('./helpers/utils'),
    TestHttpStack = _require.TestHttpStack,
    waitableFunction = _require.waitableFunction,
    wait = _require.wait,
    getBlob = _require.getBlob;

var tus = require('../..'); // Uncomment to enable debug log from tus-js-client
// tus.enableDebugLog();


describe('tus', function () {
  describe('#isSupported', function () {
    it('should be true', function () {
      expect(tus.isSupported).toBe(true);
    });
  });
  describe('#Upload', function () {
    it('should throw if no error handler is available', function () {
      var upload = new tus.Upload(null);
      expect(upload.start.bind(upload)).toThrowError('tus: no file or stream to upload provided');
    });
    it('should throw if no endpoint and upload URL is provided', function () {
      var file = getBlob('hello world');
      var upload = new tus.Upload(file);
      expect(upload.start.bind(upload)).toThrowError('tus: neither an endpoint or an upload URL is provided');
    });
    it('should upload a file', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'https://tus.io/uploads',
                headers: {
                  Custom: 'blargh'
                },
                metadata: {
                  foo: 'hello',
                  bar: 'world',
                  nonlatin: 'słońce',
                  number: 100
                },
                withCredentials: true,
                onProgress: function onProgress() {},
                onSuccess: waitableFunction()
              };
              spyOn(options, 'onProgress');
              upload = new tus.Upload(file, options);
              upload.start();
              _context.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context.sent;
              expect(req.url).toBe('https://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(11); // if (isBrowser) expect(req.withCredentials).toBe(true);

              expect(req.requestHeaders['Upload-Metadata']).toBe('foo aGVsbG8=,bar d29ybGQ=,nonlatin c8WCb8WEY2U=,number MTAw');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'https://tus.io/uploads/blargh'
                }
              });
              _context.next = 18;
              return testStack.nextRequest();

            case 18:
              req = _context.sent;
              expect(req.url).toBe('https://tus.io/uploads/blargh');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(0);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(11); // if (isBrowser) expect(req.withCredentials).toBe(true);

              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 11
                }
              });
              _context.next = 29;
              return options.onSuccess.toBeCalled;

            case 29:
              expect(upload.url).toBe('https://tus.io/uploads/blargh');
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);

            case 31:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));
    it('should create an upload if resuming fails', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
      var testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                uploadUrl: 'http://tus.io/uploads/resuming'
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context2.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context2.sent;
              expect(req.url).toBe('http://tus.io/uploads/resuming');
              expect(req.method).toBe('HEAD');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              req.respondWith({
                status: 404
              });
              _context2.next = 14;
              return testStack.nextRequest();

            case 14:
              req = _context2.sent;
              expect(req.url).toBe('http://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(11); // The upload URL should be cleared when tus-js.client tries to create a new upload.

              expect(upload.url).toBe(null);

            case 20:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    })));
    it('should create an upload using the creation-with-data extension', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
      var testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                uploadDataDuringCreation: true,
                onProgress: function onProgress() {},
                onChunkComplete: function onChunkComplete() {},
                onSuccess: waitableFunction('onSuccess')
              };
              spyOn(options, 'onProgress');
              spyOn(options, 'onChunkComplete');
              upload = new tus.Upload(file, options);
              upload.start();
              _context3.next = 9;
              return testStack.nextRequest();

            case 9:
              req = _context3.sent;
              expect(req.url).toBe('http://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(11);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(11);
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'http://tus.io/uploads/blargh',
                  'Upload-Offset': 11
                }
              });
              _context3.next = 19;
              return options.onSuccess.toBeCalled;

            case 19:
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);
              expect(options.onChunkComplete).toHaveBeenCalledWith(11, 11, 11);
              expect(options.onSuccess).toHaveBeenCalled();
              expect(upload.url).toBe('http://tus.io/uploads/blargh');

            case 23:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    })));
    it('should create an upload with partial data and continue', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
      var testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                uploadDataDuringCreation: true,
                chunkSize: 6,
                onProgress: function onProgress() {},
                onChunkComplete: function onChunkComplete() {},
                onSuccess: waitableFunction('onSuccess')
              };
              spyOn(options, 'onProgress');
              spyOn(options, 'onChunkComplete');
              upload = new tus.Upload(file, options);
              upload.start();
              _context4.next = 9;
              return testStack.nextRequest();

            case 9:
              req = _context4.sent;
              expect(req.url).toBe('http://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(11);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(6);
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'http://tus.io/uploads/blargh',
                  'Upload-Offset': 6
                }
              });
              _context4.next = 19;
              return testStack.nextRequest();

            case 19:
              req = _context4.sent;
              // Once the second request has been sent, the progress handler must have been invoked.
              expect(options.onProgress).toHaveBeenCalledWith(6, 11);
              expect(options.onChunkComplete).toHaveBeenCalledWith(6, 6, 11);
              expect(options.onSuccess).not.toHaveBeenCalled();
              expect(upload.url).toBe('http://tus.io/uploads/blargh');
              expect(req.url).toBe('http://tus.io/uploads/blargh');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(6);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(5);
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'http://tus.io/uploads/blargh',
                  'Upload-Offset': 11
                }
              });
              _context4.next = 33;
              return options.onSuccess.toBeCalled;

            case 33:
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);
              expect(options.onChunkComplete).toHaveBeenCalledWith(5, 11, 11);
              expect(options.onSuccess).toHaveBeenCalled();

            case 36:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    })));
    it("should add the request's body and ID to errors", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
      var testStack, file, options, upload, req, reqId, err;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                addRequestId: true,
                retryDelays: null,
                onError: waitableFunction('onError')
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context5.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context5.sent;
              expect(req.url).toBe('http://tus.io/uploads');
              expect(req.method).toBe('POST');
              reqId = req.requestHeaders['X-Request-ID'];
              expect(_typeof(reqId)).toBe('string');
              expect(reqId.length).toBe(36);
              req.respondWith({
                status: 500,
                responseText: 'server_error'
              });
              _context5.next = 16;
              return options.onError.toBeCalled;

            case 16:
              err = _context5.sent;
              expect(err.message).toBe("tus: unexpected response while creating upload, originated from request (method: POST, url: http://tus.io/uploads, response code: 500, response text: server_error, request id: ".concat(reqId, ")"));
              expect(err.originalRequest).toBeDefined();
              expect(err.originalResponse).toBeDefined();

            case 20:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    })));
    it('should invoke the request and response callbacks', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
      var testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                uploadUrl: 'http://tus.io/uploads/foo',
                onBeforeRequest: function onBeforeRequest(req) {
                  expect(req.getURL()).toBe('http://tus.io/uploads/foo');
                  expect(req.getMethod()).toBe('HEAD');
                },
                onAfterResponse: function onAfterResponse(req, res) {
                  expect(req.getURL()).toBe('http://tus.io/uploads/foo');
                  expect(req.getMethod()).toBe('HEAD');
                  expect(res.getStatus()).toBe(204);
                  expect(res.getHeader('Upload-Offset')).toBe(11);
                },
                onSuccess: waitableFunction('onSuccess')
              };
              spyOn(options, 'onBeforeRequest');
              spyOn(options, 'onAfterResponse');
              upload = new tus.Upload(file, options);
              upload.start();
              _context6.next = 9;
              return testStack.nextRequest();

            case 9:
              req = _context6.sent;
              expect(req.url).toBe('http://tus.io/uploads/foo');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 11,
                  'Upload-Length': 11
                }
              });
              _context6.next = 15;
              return options.onSuccess.toBeCalled;

            case 15:
              expect(options.onBeforeRequest).toHaveBeenCalled();
              expect(options.onAfterResponse).toHaveBeenCalled();

            case 17:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    })));
    it('should throw an error if resuming fails and no endpoint is provided', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
      var testStack, file, options, upload, req, err;
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                uploadUrl: 'http://tus.io/uploads/resuming',
                onError: waitableFunction('onError')
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context7.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context7.sent;
              expect(req.url).toBe('http://tus.io/uploads/resuming');
              expect(req.method).toBe('HEAD');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              req.respondWith({
                status: 404
              });
              _context7.next = 14;
              return options.onError.toBeCalled;

            case 14:
              err = _context7.sent;
              expect(err.message).toBe('tus: unable to resume upload (new upload cannot be created without an endpoint), originated from request (method: HEAD, url: http://tus.io/uploads/resuming, response code: 404, response text: , request id: n/a)');

            case 16:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7);
    })));
    it('should resolve relative URLs', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
      var testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io:1080/files/'
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context8.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context8.sent;
              expect(req.url).toBe('http://tus.io:1080/files/');
              expect(req.method).toBe('POST');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: '//localhost/uploads/foo'
                }
              });
              _context8.next = 13;
              return testStack.nextRequest();

            case 13:
              req = _context8.sent;
              expect(req.url).toBe('http://localhost/uploads/foo');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 11
                }
              });
              expect(upload.url).toBe('http://localhost/uploads/foo');

            case 18:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8);
    })));
    it('should upload a file in chunks', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
      var testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                chunkSize: 7,
                onSuccess: waitableFunction('onSuccess'),
                onProgress: function onProgress() {},
                onChunkComplete: function onChunkComplete() {}
              };
              spyOn(options, 'onProgress');
              spyOn(options, 'onChunkComplete');
              upload = new tus.Upload(file, options);
              upload.start();
              _context9.next = 9;
              return testStack.nextRequest();

            case 9:
              req = _context9.sent;
              expect(req.url).toBe('http://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(11);
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: '/uploads/blargh'
                }
              });
              _context9.next = 17;
              return testStack.nextRequest();

            case 17:
              req = _context9.sent;
              expect(req.url).toBe('http://tus.io/uploads/blargh');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(0);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(7);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 7
                }
              });
              _context9.next = 27;
              return testStack.nextRequest();

            case 27:
              req = _context9.sent;
              expect(req.url).toBe('http://tus.io/uploads/blargh');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(7);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(4);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 11
                }
              });
              _context9.next = 37;
              return options.onSuccess.toBeCalled;

            case 37:
              expect(upload.url).toBe('http://tus.io/uploads/blargh');
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);
              expect(options.onChunkComplete).toHaveBeenCalledWith(7, 7, 11);
              expect(options.onChunkComplete).toHaveBeenCalledWith(4, 11, 11);

            case 41:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9);
    })));
    it('should add the original request to errors', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
      var testStack, file, options, upload, req, err;
      return _regeneratorRuntime().wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                retryDelays: null,
                onError: waitableFunction('onError')
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context10.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context10.sent;
              expect(req.url).toBe('http://tus.io/uploads');
              expect(req.method).toBe('POST');
              req.respondWith({
                status: 500,
                responseHeaders: {
                  Custom: 'blargh'
                }
              });
              _context10.next = 13;
              return options.onError.toBeCalled;

            case 13:
              err = _context10.sent;
              expect(upload.url).toBe(null);
              expect(err.message).toBe('tus: unexpected response while creating upload, originated from request (method: POST, url: http://tus.io/uploads, response code: 500, response text: , request id: n/a)');
              expect(err.originalRequest).toBeDefined();
              expect(err.originalResponse).toBeDefined();
              expect(err.originalResponse.getHeader('Custom')).toBe('blargh');

            case 19:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10);
    })));
    it('should only create an upload for empty files', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
      var testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                onSuccess: waitableFunction('onSuccess')
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context11.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context11.sent;
              expect(req.url).toBe('http://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(0);
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'http://tus.io/uploads/empty'
                }
              });
              _context11.next = 15;
              return options.onSuccess.toBeCalled;

            case 15:
              expect(options.onSuccess).toHaveBeenCalled();

            case 16:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11);
    })));
    it('should not resume a finished upload', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
      var testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                onProgress: function onProgress() {},
                onSuccess: waitableFunction('onSuccess'),
                uploadUrl: 'http://tus.io/uploads/resuming'
              };
              spyOn(options, 'onProgress');
              upload = new tus.Upload(file, options);
              upload.start();
              _context12.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context12.sent;
              expect(req.url).toBe('http://tus.io/uploads/resuming');
              expect(req.method).toBe('HEAD');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Length': '11',
                  'Upload-Offset': '11'
                }
              });
              _context12.next = 15;
              return options.onSuccess.toBeCalled;

            case 15:
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);
              expect(options.onSuccess).toHaveBeenCalled();

            case 17:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee12);
    })));
    it('should resume an upload from a specified url', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {
      var testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee13$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                uploadUrl: 'http://tus.io/files/upload',
                onProgress: function onProgress() {},
                onSuccess: waitableFunction('onSuccess'),
                fingerprint: function fingerprint() {}
              };
              spyOn(options, 'fingerprint').and.resolveTo('fingerprinted');
              spyOn(options, 'onProgress');
              upload = new tus.Upload(file, options);
              upload.start();
              expect(options.fingerprint).toHaveBeenCalled();
              _context13.next = 10;
              return testStack.nextRequest();

            case 10:
              req = _context13.sent;
              expect(req.url).toBe('http://tus.io/files/upload');
              expect(req.method).toBe('HEAD');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Length': 11,
                  'Upload-Offset': 3
                }
              });
              _context13.next = 17;
              return testStack.nextRequest();

            case 17:
              req = _context13.sent;
              expect(req.url).toBe('http://tus.io/files/upload');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(3);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(11 - 3);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 11
                }
              });
              _context13.next = 27;
              return options.onSuccess.toBeCalled;

            case 27:
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);
              expect(upload.url).toBe('http://tus.io/files/upload');

            case 29:
            case "end":
              return _context13.stop();
          }
        }
      }, _callee13);
    })));
    it('should resume a previously started upload', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {
      var testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee14$(_context14) {
        while (1) {
          switch (_context14.prev = _context14.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                onSuccess: waitableFunction('onSuccess'),
                onError: function onError() {}
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context14.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context14.sent;
              expect(req.url).toBe('http://tus.io/uploads');
              expect(req.method).toBe('POST');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'http://tus.io/uploads/blargh'
                }
              });
              _context14.next = 13;
              return testStack.nextRequest();

            case 13:
              req = _context14.sent;
              expect(req.url).toBe('http://tus.io/uploads/blargh');
              expect(req.method).toBe('PATCH');
              upload.abort();
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 5
                }
              });
              upload.start();
              _context14.next = 21;
              return testStack.nextRequest();

            case 21:
              req = _context14.sent;
              expect(req.url).toBe('http://tus.io/uploads/blargh');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 5,
                  'Upload-Length': 11
                }
              });
              _context14.next = 27;
              return testStack.nextRequest();

            case 27:
              req = _context14.sent;
              expect(req.url).toBe('http://tus.io/uploads/blargh');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 11
                }
              });
              _context14.next = 33;
              return options.onSuccess.toBeCalled;

            case 33:
              expect(options.onSuccess).toHaveBeenCalled();

            case 34:
            case "end":
              return _context14.stop();
          }
        }
      }, _callee14);
    })));
    it('should override the PATCH method', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {
      var testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee15$(_context15) {
        while (1) {
          switch (_context15.prev = _context15.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                uploadUrl: 'http://tus.io/files/upload',
                overridePatchMethod: true
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context15.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context15.sent;
              expect(req.url).toBe('http://tus.io/files/upload');
              expect(req.method).toBe('HEAD');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Length': 11,
                  'Upload-Offset': 3
                }
              });
              _context15.next = 14;
              return testStack.nextRequest();

            case 14:
              req = _context15.sent;
              expect(req.url).toBe('http://tus.io/files/upload');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(3);
              expect(req.requestHeaders['X-HTTP-Method-Override']).toBe('PATCH');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 11
                }
              });

            case 21:
            case "end":
              return _context15.stop();
          }
        }
      }, _callee15);
    })));
    it('should emit an error if an upload is locked', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {
      var testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee16$(_context16) {
        while (1) {
          switch (_context16.prev = _context16.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                uploadUrl: 'http://tus.io/files/upload',
                onError: waitableFunction('onError'),
                retryDelays: null
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context16.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context16.sent;
              expect(req.url).toBe('http://tus.io/files/upload');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 423 // Locked

              });
              _context16.next = 13;
              return options.onError.toBeCalled;

            case 13:
              expect(options.onError).toHaveBeenCalledWith(new Error('tus: upload is currently locked; retry later, originated from request (method: HEAD, url: http://tus.io/files/upload, response code: 423, response text: , request id: n/a)'));

            case 14:
            case "end":
              return _context16.stop();
          }
        }
      }, _callee16);
    })));
    it('should emit an error if no Location header is presented', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {
      var testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee17$(_context17) {
        while (1) {
          switch (_context17.prev = _context17.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                onError: waitableFunction('onError'),
                retryDelays: null
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context17.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context17.sent;
              expect(req.url).toBe('http://tus.io/uploads');
              expect(req.method).toBe('POST'); // The Location header is omitted on purpose here

              req.respondWith({
                status: 201
              });
              _context17.next = 13;
              return options.onError.toBeCalled;

            case 13:
              expect(options.onError).toHaveBeenCalledWith(new Error('tus: invalid or missing Location header, originated from request (method: POST, url: http://tus.io/uploads, response code: 201, response text: , request id: n/a)'));

            case 14:
            case "end":
              return _context17.stop();
          }
        }
      }, _callee17);
    })));
    it('should throw if retryDelays is not an array', function () {
      var file = getBlob('hello world');
      var upload = new tus.Upload(file, {
        endpoint: 'http://endpoint/',
        retryDelays: 44
      });
      expect(upload.start.bind(upload)).toThrowError('tus: the `retryDelays` option must either be an array or null');
    }); // This tests ensures that tus-js-client correctly retries if the
    // response has the code 500 Internal Error, 423 Locked or 409 Conflict.

    it('should retry the upload', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {
      var testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee18$(_context18) {
        while (1) {
          switch (_context18.prev = _context18.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/files/',
                retryDelays: [10, 10, 10],
                onSuccess: waitableFunction('onSuccess')
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context18.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context18.sent;
              expect(req.url).toBe('http://tus.io/files/');
              expect(req.method).toBe('POST');
              req.respondWith({
                status: 500
              });
              _context18.next = 13;
              return testStack.nextRequest();

            case 13:
              req = _context18.sent;
              expect(req.url).toBe('http://tus.io/files/');
              expect(req.method).toBe('POST');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: '/files/foo'
                }
              });
              _context18.next = 19;
              return testStack.nextRequest();

            case 19:
              req = _context18.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 423
              });
              _context18.next = 25;
              return testStack.nextRequest();

            case 25:
              req = _context18.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  'Upload-Offset': 0,
                  'Upload-Length': 11
                }
              });
              _context18.next = 31;
              return testStack.nextRequest();

            case 31:
              req = _context18.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 409
              });
              _context18.next = 37;
              return testStack.nextRequest();

            case 37:
              req = _context18.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  'Upload-Offset': 0,
                  'Upload-Length': 11
                }
              });
              _context18.next = 43;
              return testStack.nextRequest();

            case 43:
              req = _context18.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 11
                }
              });
              _context18.next = 49;
              return options.onSuccess.toBeCalled;

            case 49:
              expect(options.onSuccess).toHaveBeenCalled();

            case 50:
            case "end":
              return _context18.stop();
          }
        }
      }, _callee18);
    }))); // This tests ensures that tus-js-client correctly retries if the
    // return value of onShouldRetry is true.

    it('should retry the upload when onShouldRetry specified and returns true', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19() {
      var testStack, file, options, upload, req, _upload$_emitError$ca, _upload$_emitError$ca2, error1, _upload$_emitError$ca3, _upload$_emitError$ca4, error2;

      return _regeneratorRuntime().wrap(function _callee19$(_context19) {
        while (1) {
          switch (_context19.prev = _context19.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/files/',
                retryDelays: [10, 10, 10],
                onSuccess: waitableFunction('onSuccess'),
                onShouldRetry: function onShouldRetry() {
                  return true;
                }
              };
              spyOn(options, 'onShouldRetry').and.callThrough();
              spyOn(tus.Upload.prototype, '_emitError').and.callThrough();
              upload = new tus.Upload(file, options);
              upload.start();
              _context19.next = 9;
              return testStack.nextRequest();

            case 9:
              req = _context19.sent;
              expect(req.url).toBe('http://tus.io/files/');
              expect(req.method).toBe('POST');
              req.respondWith({
                status: 500
              });
              _context19.next = 15;
              return testStack.nextRequest();

            case 15:
              req = _context19.sent;
              expect(req.url).toBe('http://tus.io/files/');
              expect(req.method).toBe('POST');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: '/files/foo'
                }
              });
              _context19.next = 21;
              return testStack.nextRequest();

            case 21:
              req = _context19.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 423
              });
              _context19.next = 27;
              return testStack.nextRequest();

            case 27:
              req = _context19.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  'Upload-Offset': 0,
                  'Upload-Length': 11
                }
              });
              _context19.next = 33;
              return testStack.nextRequest();

            case 33:
              req = _context19.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 409
              });
              _context19.next = 39;
              return testStack.nextRequest();

            case 39:
              req = _context19.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  'Upload-Offset': 0,
                  'Upload-Length': 11
                }
              });
              _context19.next = 45;
              return testStack.nextRequest();

            case 45:
              req = _context19.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 11
                }
              });
              _context19.next = 51;
              return options.onSuccess.toBeCalled;

            case 51:
              expect(options.onSuccess).toHaveBeenCalled();
              _upload$_emitError$ca = upload._emitError.calls.argsFor(0), _upload$_emitError$ca2 = _slicedToArray(_upload$_emitError$ca, 1), error1 = _upload$_emitError$ca2[0];
              expect(options.onShouldRetry).toHaveBeenCalled();
              expect(options.onShouldRetry.calls.argsFor(0)).toEqual([error1, 0, upload.options]);
              _upload$_emitError$ca3 = upload._emitError.calls.argsFor(1), _upload$_emitError$ca4 = _slicedToArray(_upload$_emitError$ca3, 1), error2 = _upload$_emitError$ca4[0];
              expect(options.onShouldRetry.calls.argsFor(1)).toEqual([error2, 1, upload.options]);

            case 57:
            case "end":
              return _context19.stop();
          }
        }
      }, _callee19);
    }))); // This tests ensures that tus-js-client correctly aborts if the
    // return value of onShouldRetry is false.

    it('should not retry the upload when callback specified and returns false', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20() {
      var testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee20$(_context20) {
        while (1) {
          switch (_context20.prev = _context20.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/files/',
                retryDelays: [10, 10, 10],
                onSuccess: waitableFunction('onSuccess'),
                onError: waitableFunction('onError'),
                onShouldRetry: function onShouldRetry() {
                  return false;
                }
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context20.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context20.sent;
              expect(req.url).toBe('http://tus.io/files/');
              expect(req.method).toBe('POST'); // The error callback should not be invoked for the first error response.

              expect(options.onError).not.toHaveBeenCalled();
              req.respondWith({
                status: 500
              });
              _context20.next = 14;
              return options.onError.toBeCalled;

            case 14:
              expect(options.onSuccess).not.toHaveBeenCalled();
              expect(options.onError).toHaveBeenCalledTimes(1);

            case 16:
            case "end":
              return _context20.stop();
          }
        }
      }, _callee20);
    })));
    it('should not retry if the error has not been caused by a request', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21() {
      var file, options, upload, error;
      return _regeneratorRuntime().wrap(function _callee21$(_context21) {
        while (1) {
          switch (_context21.prev = _context21.next) {
            case 0:
              file = getBlob('hello world');
              options = {
                httpStack: new TestHttpStack(),
                endpoint: 'http://tus.io/files/',
                retryDelays: [10, 10, 10],
                onSuccess: function onSuccess() {},
                onError: function onError() {}
              };
              spyOn(options, 'onSuccess');
              spyOn(options, 'onError');
              upload = new tus.Upload(file, options);
              spyOn(upload, '_createUpload');
              upload.start();
              _context21.next = 9;
              return wait(200);

            case 9:
              error = new Error('custom error');

              upload._emitError(error);

              expect(upload._createUpload).toHaveBeenCalledTimes(1);
              expect(options.onError).toHaveBeenCalledWith(error);
              expect(options.onSuccess).not.toHaveBeenCalled();

            case 14:
            case "end":
              return _context21.stop();
          }
        }
      }, _callee21);
    })));
    it('should stop retrying after all delays have been used', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee22() {
      var testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee22$(_context22) {
        while (1) {
          switch (_context22.prev = _context22.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/files/',
                retryDelays: [10],
                onSuccess: function onSuccess() {},
                onError: waitableFunction('onError')
              };
              spyOn(options, 'onSuccess');
              upload = new tus.Upload(file, options);
              upload.start();
              _context22.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context22.sent;
              expect(req.url).toBe('http://tus.io/files/');
              expect(req.method).toBe('POST');
              req.respondWith({
                status: 500
              });
              _context22.next = 14;
              return testStack.nextRequest();

            case 14:
              req = _context22.sent;
              expect(req.url).toBe('http://tus.io/files/');
              expect(req.method).toBe('POST'); // The error callback should not be invoked for the first error response.

              expect(options.onError).not.toHaveBeenCalled();
              req.respondWith({
                status: 500
              });
              _context22.next = 21;
              return options.onError.toBeCalled;

            case 21:
              expect(options.onSuccess).not.toHaveBeenCalled();
              expect(options.onError).toHaveBeenCalledTimes(1);

            case 23:
            case "end":
              return _context22.stop();
          }
        }
      }, _callee22);
    })));
    it('should stop retrying when the abort function is called', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee23() {
      var testStack, file, options, upload, req, result;
      return _regeneratorRuntime().wrap(function _callee23$(_context23) {
        while (1) {
          switch (_context23.prev = _context23.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/files/',
                retryDelays: [10],
                onError: function onError() {}
              };
              spyOn(options, 'onError');
              upload = new tus.Upload(file, options);
              upload.start();
              _context23.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context23.sent;
              expect(req.url).toBe('http://tus.io/files/');
              expect(req.method).toBe('POST');
              spyOn(upload, 'start').and.callThrough();
              upload.abort();
              req.respondWith({
                status: 500
              });
              _context23.next = 16;
              return Promise.race([testStack.nextRequest(), wait(100)]);

            case 16:
              result = _context23.sent;
              expect(result).toBe('timed out');

            case 18:
            case "end":
              return _context23.stop();
          }
        }
      }, _callee23);
    })));
    it('should stop upload when the abort function is called during a callback', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee24() {
      var testStack, file, options, upload, req, result;
      return _regeneratorRuntime().wrap(function _callee24$(_context24) {
        while (1) {
          switch (_context24.prev = _context24.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/files/',
                chunkSize: 5,
                onChunkComplete: function onChunkComplete() {
                  upload.abort();
                }
              };
              spyOn(options, 'onChunkComplete').and.callThrough();
              upload = new tus.Upload(file, options);
              upload.start();
              _context24.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context24.sent;
              expect(req.url).toBe('http://tus.io/files/');
              expect(req.method).toBe('POST');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: '/files/foo'
                }
              });
              _context24.next = 14;
              return testStack.nextRequest();

            case 14:
              req = _context24.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 5
                }
              });
              _context24.next = 20;
              return Promise.race([testStack.nextRequest(), wait(200)]);

            case 20:
              result = _context24.sent;
              expect(options.onChunkComplete).toHaveBeenCalled();
              expect(result).toBe('timed out');

            case 23:
            case "end":
              return _context24.stop();
          }
        }
      }, _callee24);
    })));
    it('should stop upload when the abort function is called during the POST request', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee25() {
      var testStack, file, options, upload, req, result;
      return _regeneratorRuntime().wrap(function _callee25$(_context25) {
        while (1) {
          switch (_context25.prev = _context25.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/files/',
                onError: function onError() {}
              };
              spyOn(options, 'onError').and.callThrough();
              upload = new tus.Upload(file, options);
              upload.start();
              _context25.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context25.sent;
              expect(req.url).toBe('http://tus.io/files/');
              expect(req.method).toBe('POST');
              upload.abort();
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: '/files/foo'
                }
              });
              _context25.next = 15;
              return Promise.race([testStack.nextRequest(), wait(200)]);

            case 15:
              result = _context25.sent;
              expect(options.onError).not.toHaveBeenCalled();
              expect(result).toBe('timed out');

            case 18:
            case "end":
              return _context25.stop();
          }
        }
      }, _callee25);
    })));
    it('should reset the attempt counter if an upload proceeds', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee26() {
      var testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee26$(_context26) {
        while (1) {
          switch (_context26.prev = _context26.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/files/',
                retryDelays: [10],
                onError: function onError() {},
                onSuccess: waitableFunction('onSuccess')
              };
              spyOn(options, 'onError');
              upload = new tus.Upload(file, options);
              upload.start();
              _context26.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context26.sent;
              expect(req.url).toBe('http://tus.io/files/');
              expect(req.method).toBe('POST');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: '/files/foo'
                }
              });
              _context26.next = 14;
              return testStack.nextRequest();

            case 14:
              req = _context26.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 500
              });
              _context26.next = 20;
              return testStack.nextRequest();

            case 20:
              req = _context26.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 0,
                  'Upload-Length': 11
                }
              });
              _context26.next = 26;
              return testStack.nextRequest();

            case 26:
              req = _context26.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 5
                }
              });
              _context26.next = 32;
              return testStack.nextRequest();

            case 32:
              req = _context26.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 500
              });
              _context26.next = 38;
              return testStack.nextRequest();

            case 38:
              req = _context26.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 5,
                  'Upload-Length': 11
                }
              });
              _context26.next = 44;
              return testStack.nextRequest();

            case 44:
              req = _context26.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 11
                }
              });
              _context26.next = 50;
              return options.onSuccess.toBeCalled;

            case 50:
              expect(options.onError).not.toHaveBeenCalled();
              expect(options.onSuccess).toHaveBeenCalled();

            case 52:
            case "end":
              return _context26.stop();
          }
        }
      }, _callee26);
    })));
  });
});

},{"../..":4,"./helpers/utils":60}],63:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var axios = require('axios');

var _require = require('./helpers/utils'),
    getBlob = _require.getBlob;

var tus = require('../..'); // Test timeout for end-to-end tests when uploading to real server.


var END_TO_END_TIMEOUT = 20 * 1000;
describe('tus', function () {
  describe('end-to-end', function () {
    it('should upload to a real tus server', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", new Promise(function (resolve, reject) {
                var file = getBlob('hello world');
                var options = {
                  endpoint: 'https://tusd.tusdemo.net/files/',
                  metadata: {
                    nonlatin: 'słońce',
                    number: 100,
                    filename: 'hello.txt',
                    filetype: 'text/plain'
                  },
                  onSuccess: function onSuccess() {
                    expect(upload.url).toMatch(/^https:\/\/tusd\.tusdemo\.net\/files\//);
                    console.log('Upload URL:', upload.url); // eslint-disable-line no-console

                    resolve(upload);
                  },
                  onError: function onError(err) {
                    reject(err);
                  }
                };
                var upload = new tus.Upload(file, options);
                upload.start();
              }).then(validateUploadContent).then(function (upload) {
                return upload.abort(true).then(function () {
                  return upload;
                });
              }).then(validateUploadDeletion));

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })), END_TO_END_TIMEOUT);
    it('should upload to a real tus server with creation-with-upload', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", new Promise(function (resolve, reject) {
                var file = getBlob('hello world');
                var options = {
                  endpoint: 'https://tusd.tusdemo.net/files/',
                  metadata: {
                    nonlatin: 'słońce',
                    number: 100,
                    filename: 'hello.txt',
                    filetype: 'text/plain'
                  },
                  onSuccess: function onSuccess() {
                    expect(upload.url).toMatch(/^https:\/\/tusd\.tusdemo\.net\/files\//);
                    console.log('Upload URL:', upload.url); // eslint-disable-line no-console

                    resolve(upload);
                  },
                  onError: function onError(err) {
                    reject(err);
                  }
                };
                var upload = new tus.Upload(file, options);
                upload.start();
              }).then(validateUploadContent));

            case 1:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    })), END_TO_END_TIMEOUT);
  });
});

function validateUploadContent(upload) {
  return axios.get(upload.url).then(function (res) {
    expect(res.status).toBe(200);
    expect(res.data).toBe('hello world');
    return validateUploadMetadata(upload);
  });
}

function validateUploadMetadata(upload) {
  return axios.head(upload.url, {
    headers: {
      'Tus-Resumable': '1.0.0'
    }
  }).then(function (res) {
    expect(res.status).toBe(200);
    expect(res.data).toBe('');
    expect(res.headers['tus-resumable']).toBe('1.0.0');
    expect(res.headers['upload-offset']).toBe('11');
    expect(res.headers['upload-length']).toBe('11'); // The values in the Upload-Metadata header may not be in the same
    // order as we submitted them (the specification does not require
    // that). Therefore, we split the values and verify that each one
    // is present.

    var metadataStr = res.headers['upload-metadata'];
    expect(metadataStr).toBeTruthy();
    var metadata = metadataStr.split(',');
    expect(metadata).toContain('filename aGVsbG8udHh0');
    expect(metadata).toContain('filetype dGV4dC9wbGFpbg==');
    expect(metadata).toContain('nonlatin c8WCb8WEY2U=');
    expect(metadata).toContain('number MTAw');
    expect(metadata.length).toBe(4);
    return upload;
  });
}

function validateUploadDeletion(upload) {
  return axios.get(upload.url, {
    validateStatus: function validateStatus(status) {
      return status === 404;
    }
  }).then(function (res) {
    expect(res.status).toBe(404);
    return upload;
  });
}

},{"../..":4,"./helpers/utils":60,"axios":17}],64:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

/* eslint-disable no-lone-blocks */
var _require = require('./helpers/utils'),
    TestHttpStack = _require.TestHttpStack,
    waitableFunction = _require.waitableFunction,
    getBlob = _require.getBlob;

var tus = require('../..');

describe('tus', function () {
  describe('parallel uploading with stagger', function () {
    it('should throw if staggerPercent is passed without parallelUploads', function () {
      var file = getBlob('hello world');
      var upload = new tus.Upload(file, {
        endpoint: 'https://tus.io/uploads',
        staggerPercent: 50,
        uploadUrl: 'foo'
      });
      expect(upload.start.bind(upload)).toThrowError('tus: cannot use the staggerPercent option when parallelUploads is disabled');
    });
    it('should stagger a multi-part upload, one chunk per part', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var testStack, testUrlStorage, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              testStack = new TestHttpStack();
              testUrlStorage = {
                addUpload: function addUpload(fingerprint, upload) {
                  expect(fingerprint).toBe('fingerprinted');
                  expect(upload.uploadUrl).toBeUndefined();
                  expect(upload.size).toBe(10);
                  expect(upload.parallelUploadUrls).toEqual(['https://tus.io/uploads/upload1', 'https://tus.io/uploads/upload2']);
                  return Promise.resolve('tus::fingerprinted::1337');
                },
                removeUpload: function removeUpload(urlStorageKey) {
                  expect(urlStorageKey).toBe('tus::fingerprinted::1337');
                  return Promise.resolve();
                }
              };
              spyOn(testUrlStorage, 'removeUpload').and.callThrough();
              spyOn(testUrlStorage, 'addUpload').and.callThrough();
              file = getBlob('helloworld');
              options = {
                httpStack: testStack,
                urlStorage: testUrlStorage,
                storeFingerprintForResuming: true,
                removeFingerprintOnSuccess: true,
                chunkSize: 5,
                parallelUploads: 2,
                splitSizeIntoParts: function splitSizeIntoParts() {
                  return [{
                    start: 0,
                    end: 5
                  }, {
                    start: 5,
                    end: 10
                  }];
                },
                staggerPercent: 50,
                retryDelays: [10],
                endpoint: 'https://tus.io/uploads',
                headers: {
                  Custom: 'blargh'
                },
                metadata: {
                  foo: 'hello'
                },
                onProgress: function onProgress() {},
                onSuccess: waitableFunction(),
                fingerprint: function fingerprint() {
                  return Promise.resolve('fingerprinted');
                }
              };
              spyOn(options, 'onProgress');
              upload = new tus.Upload(file, options);
              upload.start();
              _context.next = 11;
              return testStack.nextRequest();

            case 11:
              req = _context.sent;
              expect(req.url).toBe('https://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(5);
              expect(req.requestHeaders['Upload-Concat']).toBe('partial');
              expect(req.requestHeaders['Upload-Metadata']).toBeUndefined();
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'https://tus.io/uploads/upload1'
                }
              });
              _context.next = 22;
              return testStack.nextRequest();

            case 22:
              req = _context.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload1');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(0);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(5);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 5
                }
              });
              _context.next = 33;
              return testStack.nextRequest();

            case 33:
              req = _context.sent;
              expect(req.url).toBe('https://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(5);
              expect(req.requestHeaders['Upload-Concat']).toBe('partial');
              expect(req.requestHeaders['Upload-Metadata']).toBeUndefined();
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'https://tus.io/uploads/upload2'
                }
              });
              _context.next = 44;
              return testStack.nextRequest();

            case 44:
              req = _context.sent;
              // Assert that the URLs have been stored.
              expect(testUrlStorage.addUpload).toHaveBeenCalled();
              expect(req.url).toBe('https://tus.io/uploads/upload2');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(0);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(5); // Return an error to ensure that the individual partial upload is properly retried.

              req.respondWith({
                status: 500
              });
              _context.next = 56;
              return testStack.nextRequest();

            case 56:
              req = _context.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload2');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Length': 10,
                  'Upload-Offset': 0
                }
              });
              _context.next = 62;
              return testStack.nextRequest();

            case 62:
              req = _context.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload2');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(0);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(5);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 5
                }
              });
              _context.next = 73;
              return testStack.nextRequest();

            case 73:
              req = _context.sent;
              expect(req.url).toBe('https://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBeUndefined();
              expect(req.requestHeaders['Upload-Concat']).toBe('final;https://tus.io/uploads/upload1 https://tus.io/uploads/upload2');
              expect(req.requestHeaders['Upload-Metadata']).toBe('foo aGVsbG8=');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'https://tus.io/uploads/upload3'
                }
              });
              _context.next = 84;
              return options.onSuccess.toBeCalled;

            case 84:
              expect(upload.url).toBe('https://tus.io/uploads/upload3');
              expect(options.onProgress).toHaveBeenCalledWith(5, 10);
              expect(options.onProgress).toHaveBeenCalledWith(10, 10);
              expect(testUrlStorage.removeUpload).toHaveBeenCalled();

            case 88:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));
    it('should stagger a multi-part upload, mix of chunk amounts per part', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
      var testStack, testUrlStorage, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              testStack = new TestHttpStack();
              testUrlStorage = {
                addUpload: function addUpload(fingerprint, upload) {
                  expect(fingerprint).toBe('fingerprinted');
                  expect(upload.uploadUrl).toBeUndefined();
                  expect(upload.size).toBe(15);
                  expect(upload.parallelUploadUrls).toEqual(['https://tus.io/uploads/upload1', 'https://tus.io/uploads/upload2']);
                  return Promise.resolve('tus::fingerprinted::1337');
                },
                removeUpload: function removeUpload(urlStorageKey) {
                  expect(urlStorageKey).toBe('tus::fingerprinted::1337');
                  return Promise.resolve();
                }
              };
              spyOn(testUrlStorage, 'removeUpload').and.callThrough();
              spyOn(testUrlStorage, 'addUpload').and.callThrough();
              file = getBlob('hello world1234');
              options = {
                httpStack: testStack,
                urlStorage: testUrlStorage,
                storeFingerprintForResuming: true,
                removeFingerprintOnSuccess: true,
                chunkSize: 5,
                parallelUploads: 2,
                splitSizeIntoParts: function splitSizeIntoParts() {
                  return [{
                    start: 0,
                    end: 10
                  }, {
                    start: 10,
                    end: 15
                  }];
                },
                staggerPercent: 50,
                retryDelays: [10],
                endpoint: 'https://tus.io/uploads',
                headers: {
                  Custom: 'blargh'
                },
                metadata: {
                  foo: 'hello'
                },
                onProgress: function onProgress() {},
                onSuccess: waitableFunction(),
                fingerprint: function fingerprint() {
                  return Promise.resolve('fingerprinted');
                }
              };
              spyOn(options, 'onProgress');
              upload = new tus.Upload(file, options);
              upload.start();
              _context2.next = 11;
              return testStack.nextRequest();

            case 11:
              req = _context2.sent;
              expect(req.url).toBe('https://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(10);
              expect(req.requestHeaders['Upload-Concat']).toBe('partial');
              expect(req.requestHeaders['Upload-Metadata']).toBeUndefined();
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'https://tus.io/uploads/upload1'
                }
              });
              _context2.next = 22;
              return testStack.nextRequest();

            case 22:
              req = _context2.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload1');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(0);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(5);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 5
                }
              });
              _context2.next = 33;
              return testStack.nextRequest();

            case 33:
              req = _context2.sent;
              expect(req.url).toBe('https://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(5);
              expect(req.requestHeaders['Upload-Concat']).toBe('partial');
              expect(req.requestHeaders['Upload-Metadata']).toBeUndefined();
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'https://tus.io/uploads/upload2'
                }
              });
              _context2.next = 44;
              return testStack.nextRequest();

            case 44:
              req = _context2.sent;
              // Assert that the URLs have been stored.
              expect(testUrlStorage.addUpload).toHaveBeenCalled();
              expect(req.url).toBe('https://tus.io/uploads/upload2');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(0);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(5); // Return an error to ensure that the individual partial upload is properly retried.

              req.respondWith({
                status: 500
              });
              _context2.next = 56;
              return testStack.nextRequest();

            case 56:
              req = _context2.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload1');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(5);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(5);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 10
                }
              });
              _context2.next = 67;
              return testStack.nextRequest();

            case 67:
              req = _context2.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload2');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Length': 15,
                  'Upload-Offset': 0
                }
              });
              _context2.next = 73;
              return testStack.nextRequest();

            case 73:
              req = _context2.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload2');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(0);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(5);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 5
                }
              });
              _context2.next = 84;
              return testStack.nextRequest();

            case 84:
              req = _context2.sent;
              expect(req.url).toBe('https://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBeUndefined();
              expect(req.requestHeaders['Upload-Concat']).toBe('final;https://tus.io/uploads/upload1 https://tus.io/uploads/upload2');
              expect(req.requestHeaders['Upload-Metadata']).toBe('foo aGVsbG8=');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'https://tus.io/uploads/upload3'
                }
              });
              _context2.next = 95;
              return options.onSuccess.toBeCalled;

            case 95:
              expect(upload.url).toBe('https://tus.io/uploads/upload3');
              expect(options.onProgress).toHaveBeenCalledWith(5, 15);
              expect(options.onProgress).toHaveBeenCalledWith(10, 15);
              expect(options.onProgress).toHaveBeenCalledWith(15, 15);
              expect(testUrlStorage.removeUpload).toHaveBeenCalled();

            case 100:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    })));
    it('should stagger a multi-part upload, one chunk per part, last part having leftover', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
      var testStack, testUrlStorage, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              testStack = new TestHttpStack();
              testUrlStorage = {
                addUpload: function addUpload(fingerprint, upload) {
                  expect(fingerprint).toBe('fingerprinted');
                  expect(upload.uploadUrl).toBeUndefined();
                  expect(upload.size).toBe(11);
                  expect(upload.parallelUploadUrls).toEqual(['https://tus.io/uploads/upload1', 'https://tus.io/uploads/upload2']);
                  return Promise.resolve('tus::fingerprinted::1337');
                },
                removeUpload: function removeUpload(urlStorageKey) {
                  expect(urlStorageKey).toBe('tus::fingerprinted::1337');
                  return Promise.resolve();
                }
              };
              spyOn(testUrlStorage, 'removeUpload').and.callThrough();
              spyOn(testUrlStorage, 'addUpload').and.callThrough();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                urlStorage: testUrlStorage,
                storeFingerprintForResuming: true,
                removeFingerprintOnSuccess: true,
                chunkSize: 5,
                parallelUploads: 2,
                splitSizeIntoParts: function splitSizeIntoParts() {
                  return [{
                    start: 0,
                    end: 5
                  }, {
                    start: 5,
                    end: 11
                  }];
                },
                staggerPercent: 50,
                retryDelays: [10],
                endpoint: 'https://tus.io/uploads',
                headers: {
                  Custom: 'blargh'
                },
                metadata: {
                  foo: 'hello'
                },
                onProgress: function onProgress() {},
                onSuccess: waitableFunction(),
                fingerprint: function fingerprint() {
                  return Promise.resolve('fingerprinted');
                }
              };
              spyOn(options, 'onProgress');
              upload = new tus.Upload(file, options);
              upload.start();
              _context3.next = 11;
              return testStack.nextRequest();

            case 11:
              req = _context3.sent;
              expect(req.url).toBe('https://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(6);
              expect(req.requestHeaders['Upload-Concat']).toBe('partial');
              expect(req.requestHeaders['Upload-Metadata']).toBeUndefined();
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'https://tus.io/uploads/upload2'
                }
              });
              _context3.next = 22;
              return testStack.nextRequest();

            case 22:
              req = _context3.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload2');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(0);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(5); // Return an error to ensure that the individual partial upload is properly retried.

              req.respondWith({
                status: 500
              });
              _context3.next = 33;
              return testStack.nextRequest();

            case 33:
              req = _context3.sent;
              expect(req.url).toBe('https://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(5);
              expect(req.requestHeaders['Upload-Concat']).toBe('partial');
              expect(req.requestHeaders['Upload-Metadata']).toBeUndefined();
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'https://tus.io/uploads/upload1'
                }
              });
              _context3.next = 44;
              return testStack.nextRequest();

            case 44:
              req = _context3.sent;
              // Assert that the URLs have been stored.
              expect(testUrlStorage.addUpload).toHaveBeenCalled();
              expect(req.url).toBe('https://tus.io/uploads/upload1');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(0);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(5);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 5
                }
              });
              _context3.next = 56;
              return testStack.nextRequest();

            case 56:
              req = _context3.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload2');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Length': 11,
                  'Upload-Offset': 0
                }
              });
              _context3.next = 62;
              return testStack.nextRequest();

            case 62:
              req = _context3.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload2');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(0);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(5);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 6
                }
              });
              _context3.next = 73;
              return testStack.nextRequest();

            case 73:
              req = _context3.sent;
              expect(req.url).toBe('https://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBeUndefined();
              expect(req.requestHeaders['Upload-Concat']).toBe('final;https://tus.io/uploads/upload1 https://tus.io/uploads/upload2');
              expect(req.requestHeaders['Upload-Metadata']).toBe('foo aGVsbG8=');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'https://tus.io/uploads/upload3'
                }
              });
              _context3.next = 84;
              return options.onSuccess.toBeCalled;

            case 84:
              expect(upload.url).toBe('https://tus.io/uploads/upload3');
              expect(options.onProgress).toHaveBeenCalledWith(5, 11);
              expect(options.onProgress).toHaveBeenCalledWith(10, 11);
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);
              expect(testUrlStorage.removeUpload).toHaveBeenCalled();

            case 89:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    })));
    it('should stagger a multi-part upload, mix of chunk amounts per part, last part having leftover', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
      var testStack, testUrlStorage, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              testStack = new TestHttpStack();
              testUrlStorage = {
                addUpload: function addUpload(fingerprint, upload) {
                  expect(fingerprint).toBe('fingerprinted');
                  expect(upload.uploadUrl).toBeUndefined();
                  expect(upload.size).toBe(16);
                  expect(upload.parallelUploadUrls).toEqual(['https://tus.io/uploads/upload1', 'https://tus.io/uploads/upload2']);
                  return Promise.resolve('tus::fingerprinted::1337');
                },
                removeUpload: function removeUpload(urlStorageKey) {
                  expect(urlStorageKey).toBe('tus::fingerprinted::1337');
                  return Promise.resolve();
                }
              };
              spyOn(testUrlStorage, 'removeUpload').and.callThrough();
              spyOn(testUrlStorage, 'addUpload').and.callThrough();
              file = getBlob('hello world12345');
              options = {
                httpStack: testStack,
                urlStorage: testUrlStorage,
                storeFingerprintForResuming: true,
                removeFingerprintOnSuccess: true,
                chunkSize: 5,
                parallelUploads: 2,
                splitSizeIntoParts: function splitSizeIntoParts() {
                  return [{
                    start: 0,
                    end: 10
                  }, {
                    start: 10,
                    end: 16
                  }];
                },
                staggerPercent: 50,
                retryDelays: [10],
                endpoint: 'https://tus.io/uploads',
                headers: {
                  Custom: 'blargh'
                },
                metadata: {
                  foo: 'hello'
                },
                onProgress: function onProgress() {},
                onSuccess: waitableFunction(),
                fingerprint: function fingerprint() {
                  return Promise.resolve('fingerprinted');
                }
              };
              spyOn(options, 'onProgress');
              upload = new tus.Upload(file, options);
              upload.start();
              _context4.next = 11;
              return testStack.nextRequest();

            case 11:
              req = _context4.sent;
              expect(req.url).toBe('https://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(10);
              expect(req.requestHeaders['Upload-Concat']).toBe('partial');
              expect(req.requestHeaders['Upload-Metadata']).toBeUndefined();
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'https://tus.io/uploads/upload1'
                }
              });
              _context4.next = 22;
              return testStack.nextRequest();

            case 22:
              req = _context4.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload1');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(0);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(5);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 5
                }
              });
              _context4.next = 33;
              return testStack.nextRequest();

            case 33:
              req = _context4.sent;
              expect(req.url).toBe('https://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(6);
              expect(req.requestHeaders['Upload-Concat']).toBe('partial');
              expect(req.requestHeaders['Upload-Metadata']).toBeUndefined();
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'https://tus.io/uploads/upload2'
                }
              });
              _context4.next = 44;
              return testStack.nextRequest();

            case 44:
              req = _context4.sent;
              // Assert that the URLs have been stored.
              expect(testUrlStorage.addUpload).toHaveBeenCalled();
              expect(req.url).toBe('https://tus.io/uploads/upload2');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(0);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(5); // Return an error to ensure that the individual partial upload is properly retried.

              req.respondWith({
                status: 500
              });
              _context4.next = 56;
              return testStack.nextRequest();

            case 56:
              req = _context4.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload1');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(5);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(5);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 10
                }
              });
              _context4.next = 67;
              return testStack.nextRequest();

            case 67:
              req = _context4.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload2');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Length': 15,
                  'Upload-Offset': 0
                }
              });
              _context4.next = 73;
              return testStack.nextRequest();

            case 73:
              req = _context4.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload2');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(0);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(5);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 5
                }
              });
              _context4.next = 84;
              return testStack.nextRequest();

            case 84:
              req = _context4.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload2');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(5);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(1);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 6
                }
              });
              _context4.next = 95;
              return testStack.nextRequest();

            case 95:
              req = _context4.sent;
              expect(req.url).toBe('https://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBeUndefined();
              expect(req.requestHeaders['Upload-Concat']).toBe('final;https://tus.io/uploads/upload1 https://tus.io/uploads/upload2');
              expect(req.requestHeaders['Upload-Metadata']).toBe('foo aGVsbG8=');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'https://tus.io/uploads/upload3'
                }
              });
              _context4.next = 106;
              return options.onSuccess.toBeCalled;

            case 106:
              expect(upload.url).toBe('https://tus.io/uploads/upload3');
              expect(options.onProgress).toHaveBeenCalledWith(5, 16);
              expect(options.onProgress).toHaveBeenCalledWith(10, 16);
              expect(options.onProgress).toHaveBeenCalledWith(15, 16);
              expect(options.onProgress).toHaveBeenCalledWith(16, 16);
              expect(testUrlStorage.removeUpload).toHaveBeenCalled();

            case 112:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    })));
  });
});

},{"../..":4,"./helpers/utils":60}],65:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var _require = require('./helpers/utils'),
    TestHttpStack = _require.TestHttpStack,
    waitableFunction = _require.waitableFunction,
    wait = _require.wait,
    getBlob = _require.getBlob;

var tus = require('../..');

describe('tus', function () {
  describe('parallel uploading', function () {
    it('should throw if incompatible options are used', function () {
      var file = getBlob('hello world');
      var upload = new tus.Upload(file, {
        endpoint: 'https://tus.io/uploads',
        parallelUploads: 2,
        uploadUrl: 'foo'
      });
      expect(upload.start.bind(upload)).toThrowError('tus: cannot use the uploadUrl option when parallelUploads is enabled');
    });
    it('should throw if splitSizeIntoParts is passed without parallelUploads', function () {
      var file = getBlob('hello world');
      var upload = new tus.Upload(file, {
        endpoint: 'https://tus.io/uploads',
        splitSizeIntoParts: function splitSizeIntoParts() {},
        uploadUrl: 'foo'
      });
      expect(upload.start.bind(upload)).toThrowError('tus: cannot use the splitSizeIntoParts option when parallelUploads is disabled');
    });
    it('should split a file into multiple parts and create an upload for each', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var testStack, testUrlStorage, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              testStack = new TestHttpStack();
              testUrlStorage = {
                addUpload: function addUpload(fingerprint, upload) {
                  expect(fingerprint).toBe('fingerprinted');
                  expect(upload.uploadUrl).toBeUndefined();
                  expect(upload.size).toBe(11);
                  expect(upload.parallelUploadUrls).toEqual(['https://tus.io/uploads/upload1', 'https://tus.io/uploads/upload2']);
                  return Promise.resolve('tus::fingerprinted::1337');
                },
                removeUpload: function removeUpload(urlStorageKey) {
                  expect(urlStorageKey).toBe('tus::fingerprinted::1337');
                  return Promise.resolve();
                }
              };
              spyOn(testUrlStorage, 'removeUpload').and.callThrough();
              spyOn(testUrlStorage, 'addUpload').and.callThrough();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                urlStorage: testUrlStorage,
                storeFingerprintForResuming: true,
                removeFingerprintOnSuccess: true,
                parallelUploads: 2,
                retryDelays: [10],
                endpoint: 'https://tus.io/uploads',
                headers: {
                  Custom: 'blargh'
                },
                metadata: {
                  foo: 'hello'
                },
                onProgress: function onProgress() {},
                onSuccess: waitableFunction(),
                fingerprint: function fingerprint() {
                  return Promise.resolve('fingerprinted');
                }
              };
              spyOn(options, 'onProgress');
              upload = new tus.Upload(file, options);
              upload.start();
              _context.next = 11;
              return testStack.nextRequest();

            case 11:
              req = _context.sent;
              expect(req.url).toBe('https://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(5);
              expect(req.requestHeaders['Upload-Concat']).toBe('partial');
              expect(req.requestHeaders['Upload-Metadata']).toBeUndefined();
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'https://tus.io/uploads/upload1'
                }
              });
              _context.next = 22;
              return testStack.nextRequest();

            case 22:
              req = _context.sent;
              expect(req.url).toBe('https://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(6);
              expect(req.requestHeaders['Upload-Concat']).toBe('partial');
              expect(req.requestHeaders['Upload-Metadata']).toBeUndefined();
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'https://tus.io/uploads/upload2'
                }
              });
              _context.next = 33;
              return testStack.nextRequest();

            case 33:
              req = _context.sent;
              // Assert that the URLs have been stored.
              expect(testUrlStorage.addUpload).toHaveBeenCalled();
              expect(req.url).toBe('https://tus.io/uploads/upload1');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(0);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(5);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 5
                }
              });
              _context.next = 45;
              return testStack.nextRequest();

            case 45:
              req = _context.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload2');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(0);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(6); // Return an error to ensure that the individual partial upload is properly retried.

              req.respondWith({
                status: 500
              });
              _context.next = 56;
              return testStack.nextRequest();

            case 56:
              req = _context.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload2');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Length': 11,
                  'Upload-Offset': 0
                }
              });
              _context.next = 62;
              return testStack.nextRequest();

            case 62:
              req = _context.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload2');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(0);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(6);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 6
                }
              });
              _context.next = 73;
              return testStack.nextRequest();

            case 73:
              req = _context.sent;
              expect(req.url).toBe('https://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBeUndefined();
              expect(req.requestHeaders['Upload-Concat']).toBe('final;https://tus.io/uploads/upload1 https://tus.io/uploads/upload2');
              expect(req.requestHeaders['Upload-Metadata']).toBe('foo aGVsbG8=');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'https://tus.io/uploads/upload3'
                }
              });
              _context.next = 84;
              return options.onSuccess.toBeCalled;

            case 84:
              expect(upload.url).toBe('https://tus.io/uploads/upload3');
              expect(options.onProgress).toHaveBeenCalledWith(5, 11);
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);
              expect(testUrlStorage.removeUpload).toHaveBeenCalled();

            case 88:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));
    it('should split a file into multiple parts based on custom splitSizeIntoParts', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
      var testStack, testUrlStorage, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              testStack = new TestHttpStack();
              testUrlStorage = {
                addUpload: function addUpload(fingerprint, upload) {
                  expect(fingerprint).toBe('fingerprinted');
                  expect(upload.uploadUrl).toBeUndefined();
                  expect(upload.size).toBe(11);
                  expect(upload.parallelUploadUrls).toEqual(['https://tus.io/uploads/upload1', 'https://tus.io/uploads/upload2']);
                  return Promise.resolve('tus::fingerprinted::1337');
                },
                removeUpload: function removeUpload(urlStorageKey) {
                  expect(urlStorageKey).toBe('tus::fingerprinted::1337');
                  return Promise.resolve();
                }
              };
              spyOn(testUrlStorage, 'removeUpload').and.callThrough();
              spyOn(testUrlStorage, 'addUpload').and.callThrough();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                urlStorage: testUrlStorage,
                storeFingerprintForResuming: true,
                removeFingerprintOnSuccess: true,
                parallelUploads: 2,
                // Expected output: [{ start: 0, end: 1 }, { start: 1, end: 11 }]
                splitSizeIntoParts: function splitSizeIntoParts(totalSize, partCount) {
                  var partSize = 1;
                  var parts = [];

                  for (var i = 0; i < partCount; i++) {
                    parts.push({
                      start: partSize * i,
                      end: partSize * (i + 1)
                    });
                  }

                  parts[partCount - 1].end = totalSize;
                  return parts;
                },
                retryDelays: [10],
                endpoint: 'https://tus.io/uploads',
                headers: {
                  Custom: 'blargh'
                },
                metadata: {
                  foo: 'hello'
                },
                onProgress: function onProgress() {},
                onSuccess: waitableFunction(),
                fingerprint: function fingerprint() {
                  return Promise.resolve('fingerprinted');
                }
              };
              spyOn(options, 'onProgress');
              upload = new tus.Upload(file, options);
              upload.start();
              _context2.next = 11;
              return testStack.nextRequest();

            case 11:
              req = _context2.sent;
              expect(req.url).toBe('https://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(1);
              expect(req.requestHeaders['Upload-Concat']).toBe('partial');
              expect(req.requestHeaders['Upload-Metadata']).toBeUndefined();
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'https://tus.io/uploads/upload1'
                }
              });
              _context2.next = 22;
              return testStack.nextRequest();

            case 22:
              req = _context2.sent;
              expect(req.url).toBe('https://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(10);
              expect(req.requestHeaders['Upload-Concat']).toBe('partial');
              expect(req.requestHeaders['Upload-Metadata']).toBeUndefined();
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'https://tus.io/uploads/upload2'
                }
              });
              _context2.next = 33;
              return testStack.nextRequest();

            case 33:
              req = _context2.sent;
              // Assert that the URLs have been stored.
              expect(testUrlStorage.addUpload).toHaveBeenCalled();
              expect(req.url).toBe('https://tus.io/uploads/upload1');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(0);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(1);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 1
                }
              });
              _context2.next = 45;
              return testStack.nextRequest();

            case 45:
              req = _context2.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload2');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(0);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(10); // Return an error to ensure that the individual partial upload is properly retried.

              req.respondWith({
                status: 500
              });
              _context2.next = 56;
              return testStack.nextRequest();

            case 56:
              req = _context2.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload2');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Length': 11,
                  'Upload-Offset': 0
                }
              });
              _context2.next = 62;
              return testStack.nextRequest();

            case 62:
              req = _context2.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload2');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(0);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(10);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 10
                }
              });
              _context2.next = 73;
              return testStack.nextRequest();

            case 73:
              req = _context2.sent;
              expect(req.url).toBe('https://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBeUndefined();
              expect(req.requestHeaders['Upload-Concat']).toBe('final;https://tus.io/uploads/upload1 https://tus.io/uploads/upload2');
              expect(req.requestHeaders['Upload-Metadata']).toBe('foo aGVsbG8=');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'https://tus.io/uploads/upload3'
                }
              });
              _context2.next = 84;
              return options.onSuccess.toBeCalled;

            case 84:
              expect(upload.url).toBe('https://tus.io/uploads/upload3');
              expect(options.onProgress).toHaveBeenCalledWith(1, 11);
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);
              expect(testUrlStorage.removeUpload).toHaveBeenCalled();

            case 88:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    })));
    it('should emit error from a partial upload', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
      var testStack, file, options, upload, req, err;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                parallelUploads: 2,
                retryDelays: null,
                endpoint: 'https://tus.io/uploads',
                onError: waitableFunction('onError')
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context3.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context3.sent;
              expect(req.url).toBe('https://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(5);
              req.respondWith({
                status: 500
              });
              _context3.next = 15;
              return options.onError.toBeCalled;

            case 15:
              err = _context3.sent;
              expect(err.message).toBe('tus: unexpected response while creating upload, originated from request (method: POST, url: https://tus.io/uploads, response code: 500, response text: , request id: n/a)');
              expect(err.originalRequest).toBe(req);

            case 18:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    })));
    it('should resume the partial uploads', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
      var testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                // The client should resume the parallel uploads, even if it is not
                // configured for new uploads.
                parallelUploads: 1,
                endpoint: 'https://tus.io/uploads',
                onProgress: function onProgress() {},
                onSuccess: waitableFunction()
              };
              spyOn(options, 'onProgress');
              upload = new tus.Upload(file, options);
              upload.resumeFromPreviousUpload({
                urlStorageKey: 'tus::fingerprint::1337',
                parallelUploadUrls: ['https://tus.io/uploads/upload1', 'https://tus.io/uploads/upload2']
              });
              upload.start();
              _context4.next = 9;
              return testStack.nextRequest();

            case 9:
              req = _context4.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload1');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Length': 5,
                  'Upload-Offset': 2
                }
              });
              _context4.next = 15;
              return testStack.nextRequest();

            case 15:
              req = _context4.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload2');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Length': 6,
                  'Upload-Offset': 0
                }
              });
              _context4.next = 21;
              return testStack.nextRequest();

            case 21:
              req = _context4.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload1');
              expect(req.method).toBe('PATCH');
              expect(req.body.size).toBe(3);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 5
                }
              });
              _context4.next = 28;
              return testStack.nextRequest();

            case 28:
              req = _context4.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload2');
              expect(req.method).toBe('PATCH');
              expect(req.body.size).toBe(6);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 6
                }
              });
              _context4.next = 35;
              return testStack.nextRequest();

            case 35:
              req = _context4.sent;
              expect(req.url).toBe('https://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders['Upload-Concat']).toBe('final;https://tus.io/uploads/upload1 https://tus.io/uploads/upload2');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'https://tus.io/uploads/upload3'
                }
              });
              _context4.next = 42;
              return options.onSuccess.toBeCalled;

            case 42:
              expect(upload.url).toBe('https://tus.io/uploads/upload3');
              expect(options.onProgress).toHaveBeenCalledWith(5, 11);
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);

            case 45:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    })));
    it('should abort all partial uploads and resume from them', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
      var testStack, file, options, upload, req, req1, req2, reqPromise, result;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                parallelUploads: 2,
                endpoint: 'https://tus.io/uploads',
                onProgress: function onProgress() {},
                onSuccess: waitableFunction(),
                fingerprint: function fingerprint() {
                  return Promise.resolve('fingerprinted');
                }
              };
              spyOn(options, 'onProgress');
              upload = new tus.Upload(file, options);
              upload.start();
              _context5.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context5.sent;
              expect(req.url).toBe('https://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(5);
              expect(req.requestHeaders['Upload-Concat']).toBe('partial');
              expect(req.requestHeaders['Upload-Metadata']).toBeUndefined();
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'https://tus.io/uploads/upload1'
                }
              });
              _context5.next = 18;
              return testStack.nextRequest();

            case 18:
              req = _context5.sent;
              expect(req.url).toBe('https://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(6);
              expect(req.requestHeaders['Upload-Concat']).toBe('partial');
              expect(req.requestHeaders['Upload-Metadata']).toBeUndefined();
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'https://tus.io/uploads/upload2'
                }
              });
              _context5.next = 28;
              return testStack.nextRequest();

            case 28:
              req1 = _context5.sent;
              expect(req1.url).toBe('https://tus.io/uploads/upload1');
              expect(req1.method).toBe('PATCH');
              expect(req1.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req1.requestHeaders['Upload-Offset']).toBe(0);
              expect(req1.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req1.body.size).toBe(5);
              _context5.next = 37;
              return testStack.nextRequest();

            case 37:
              req2 = _context5.sent;
              expect(req2.url).toBe('https://tus.io/uploads/upload2');
              expect(req2.method).toBe('PATCH');
              expect(req2.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req2.requestHeaders['Upload-Offset']).toBe(0);
              expect(req2.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req2.body.size).toBe(6);
              upload.abort();
              req1.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 5
                }
              });
              req2.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 6
                }
              }); // No further requests should be sent.

              reqPromise = testStack.nextRequest();
              _context5.next = 50;
              return Promise.race([reqPromise, wait(100)]);

            case 50:
              result = _context5.sent;
              expect(result).toBe('timed out'); // Restart the upload

              upload.start(); // Reuse the promise from before as it is not cancelled.

              _context5.next = 55;
              return reqPromise;

            case 55:
              req = _context5.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload1');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Length': 5,
                  'Upload-Offset': 5
                }
              });
              _context5.next = 61;
              return testStack.nextRequest();

            case 61:
              req = _context5.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload2');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Length': 6,
                  'Upload-Offset': 6
                }
              });
              _context5.next = 67;
              return testStack.nextRequest();

            case 67:
              req = _context5.sent;
              expect(req.url).toBe('https://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBeUndefined();
              expect(req.requestHeaders['Upload-Concat']).toBe('final;https://tus.io/uploads/upload1 https://tus.io/uploads/upload2');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'https://tus.io/uploads/upload3'
                }
              });
              _context5.next = 76;
              return options.onSuccess.toBeCalled;

            case 76:
              expect(upload.url).toBe('https://tus.io/uploads/upload3');
              expect(options.onProgress).toHaveBeenCalledWith(5, 11);
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);

            case 79:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    })));
  });
});

},{"../..":4,"./helpers/utils":60}],66:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var _require = require('./helpers/utils'),
    TestHttpStack = _require.TestHttpStack,
    getBlob = _require.getBlob;

var tus = require('../..');

describe('tus', function () {
  describe('terminate upload', function () {
    it('should terminate upload when abort is called with true', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var abortPromise, testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/files/',
                chunkSize: 5,
                onChunkComplete: function onChunkComplete() {
                  abortPromise = upload.abort(true);
                }
              };
              spyOn(options, 'onChunkComplete').and.callThrough();
              upload = new tus.Upload(file, options);
              upload.start();
              _context.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context.sent;
              expect(req.url).toBe('http://tus.io/files/');
              expect(req.method).toBe('POST');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: '/files/foo'
                }
              });
              _context.next = 14;
              return testStack.nextRequest();

            case 14:
              req = _context.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 5
                }
              });
              _context.next = 20;
              return testStack.nextRequest();

            case 20:
              req = _context.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('DELETE');
              req.respondWith({
                status: 204
              });
              expect(options.onChunkComplete).toHaveBeenCalled();
              _context.next = 27;
              return abortPromise;

            case 27:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));
    it('should retry terminate when an error is returned on first try', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
      var abortPromise, testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/files/',
                chunkSize: 5,
                retryDelays: [10, 10, 10],
                onChunkComplete: function onChunkComplete() {
                  abortPromise = upload.abort(true);
                }
              };
              spyOn(options, 'onChunkComplete').and.callThrough();
              upload = new tus.Upload(file, options);
              upload.start();
              _context2.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context2.sent;
              expect(req.url).toBe('http://tus.io/files/');
              expect(req.method).toBe('POST');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: '/files/foo'
                }
              });
              _context2.next = 14;
              return testStack.nextRequest();

            case 14:
              req = _context2.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 5
                }
              });
              _context2.next = 20;
              return testStack.nextRequest();

            case 20:
              req = _context2.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('DELETE');
              req.respondWith({
                status: 423
              });
              _context2.next = 26;
              return testStack.nextRequest();

            case 26:
              req = _context2.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('DELETE');
              req.respondWith({
                status: 204
              });
              _context2.next = 32;
              return abortPromise;

            case 32:
              expect(options.onChunkComplete).toHaveBeenCalled();

            case 33:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    })));
    it('should stop retrying when all delays are used up', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
      var testStack, options, terminatePromise, req;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              testStack = new TestHttpStack();
              options = {
                httpStack: testStack,
                retryDelays: [10, 10]
              };
              terminatePromise = tus.Upload.terminate('http://tus.io/files/foo', options);
              _context3.next = 5;
              return testStack.nextRequest();

            case 5:
              req = _context3.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('DELETE');
              req.respondWith({
                status: 500
              });
              _context3.next = 11;
              return testStack.nextRequest();

            case 11:
              req = _context3.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('DELETE');
              req.respondWith({
                status: 500
              });
              _context3.next = 17;
              return testStack.nextRequest();

            case 17:
              req = _context3.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('DELETE');
              req.respondWith({
                status: 500
              });
              _context3.next = 23;
              return expectAsync(terminatePromise).toBeRejectedWithError(/tus: unexpected response while terminating upload/);

            case 23:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    })));
    it('should invoke the request and response Promises', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
      var testStack, options, terminatePromise, req;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              testStack = new TestHttpStack();
              options = {
                httpStack: testStack,
                onBeforeRequest: function onBeforeRequest(req) {
                  return new Promise(function (resolve) {
                    expect(req.getURL()).toBe('http://tus.io/uploads/foo');
                    expect(req.getMethod()).toBe('DELETE');
                    resolve();
                  });
                },
                onAfterResponse: function onAfterResponse(req, res) {
                  return new Promise(function (resolve) {
                    expect(req.getURL()).toBe('http://tus.io/uploads/foo');
                    expect(req.getMethod()).toBe('DELETE');
                    expect(res.getStatus()).toBe(204);
                    resolve();
                  });
                }
              };
              spyOn(options, 'onBeforeRequest');
              spyOn(options, 'onAfterResponse');
              terminatePromise = tus.Upload.terminate('http://tus.io/uploads/foo', options);
              _context4.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context4.sent;
              expect(req.url).toBe('http://tus.io/uploads/foo');
              expect(req.method).toBe('DELETE');
              req.respondWith({
                status: 204
              });
              _context4.next = 13;
              return expectAsync(terminatePromise).toBeResolved();

            case 13:
              expect(options.onBeforeRequest).toHaveBeenCalled();
              expect(options.onAfterResponse).toHaveBeenCalled();

            case 15:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    })));
  });
});

},{"../..":4,"./helpers/utils":60}]},{},[58])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJsaWIuZXM1L2Jyb3dzZXIvZmlsZVJlYWRlci5qcyIsImxpYi5lczUvYnJvd3Nlci9maWxlU2lnbmF0dXJlLmpzIiwibGliLmVzNS9icm93c2VyL2h0dHBTdGFjay5qcyIsImxpYi5lczUvYnJvd3Nlci9pbmRleC5qcyIsImxpYi5lczUvYnJvd3Nlci9pc1JlYWN0TmF0aXZlLmpzIiwibGliLmVzNS9icm93c2VyL3NvdXJjZXMvRmlsZVNvdXJjZS5qcyIsImxpYi5lczUvYnJvd3Nlci9zb3VyY2VzL1N0cmVhbVNvdXJjZS5qcyIsImxpYi5lczUvYnJvd3Nlci9zb3VyY2VzL2lzQ29yZG92YS5qcyIsImxpYi5lczUvYnJvd3Nlci9zb3VyY2VzL3JlYWRBc0J5dGVBcnJheS5qcyIsImxpYi5lczUvYnJvd3Nlci91cmlUb0Jsb2IuanMiLCJsaWIuZXM1L2Jyb3dzZXIvdXJsU3RvcmFnZS5qcyIsImxpYi5lczUvZXJyb3IuanMiLCJsaWIuZXM1L2xvZ2dlci5qcyIsImxpYi5lczUvbm9vcFVybFN0b3JhZ2UuanMiLCJsaWIuZXM1L3VwbG9hZC5qcyIsImxpYi5lczUvdXVpZC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvYWRhcHRlcnMveGhyLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9heGlvcy5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbFRva2VuLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsZWRFcnJvci5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL2lzQ2FuY2VsLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0F4aW9zLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0F4aW9zRXJyb3IuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvSW50ZXJjZXB0b3JNYW5hZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2J1aWxkRnVsbFBhdGguanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZGlzcGF0Y2hSZXF1ZXN0LmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL21lcmdlQ29uZmlnLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3NldHRsZS5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS90cmFuc2Zvcm1EYXRhLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9kZWZhdWx0cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvZGVmYXVsdHMvdHJhbnNpdGlvbmFsLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9lbnYvZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9iaW5kLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2J1aWxkVVJMLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2NvbWJpbmVVUkxzLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2Nvb2tpZXMuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0F4aW9zRXJyb3IuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvbnVsbC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wYXJzZUhlYWRlcnMuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VQcm90b2NvbC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9zcHJlYWQuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvdG9Gb3JtRGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy92YWxpZGF0b3IuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qcy1iYXNlNjQvYmFzZTY0LmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9xdWVyeXN0cmluZ2lmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJub2RlX21vZHVsZXMvcmVxdWlyZXMtcG9ydC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy91cmwtcGFyc2UvaW5kZXguanMiLCJ0ZXN0L3NwZWMvYnJvd3Nlci1pbmRleC5qcyIsInRlc3Qvc3BlYy9oZWxwZXJzL2Fzc2VydFVybFN0b3JhZ2UuanMiLCJ0ZXN0L3NwZWMvaGVscGVycy91dGlscy5qcyIsInRlc3Qvc3BlYy90ZXN0LWJyb3dzZXItc3BlY2lmaWMuanMiLCJ0ZXN0L3NwZWMvdGVzdC1jb21tb24uanMiLCJ0ZXN0L3NwZWMvdGVzdC1lbmQtdG8tZW5kLmpzIiwidGVzdC9zcGVjL3Rlc3QtcGFyYWxsZWwtc3RhZ2dlci11cGxvYWRzLmpzIiwidGVzdC9zcGVjL3Rlc3QtcGFyYWxsZWwtdXBsb2Fkcy5qcyIsInRlc3Qvc3BlYy90ZXN0LXRlcm1pbmF0ZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBOztBQUVBLE1BQU0sQ0FBQyxjQUFQLENB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbHZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUMxa0JBOztBQUhBO0FBQ0E7QUFDQTtBQUdBLFVBQVUsQ0FBQyxZQUFNO0VBQ2Y7RUFDQTtFQUNBLFlBQVksQ0FBQyxLQUFiO0FBQ0QsQ0FKUyxDQUFWOztBQU1BLE9BQU8sQ0FBQyxlQUFELENBQVA7O0FBQ0EsT0FBTyxDQUFDLHlCQUFELENBQVA7O0FBQ0EsT0FBTyxDQUFDLHlCQUFELENBQVA7O0FBQ0EsT0FBTyxDQUFDLGlDQUFELENBQVA7O0FBQ0EsT0FBTyxDQUFDLGtC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QXBELEdBQUY7RUFxQ0QsQ0EzTE8sQ0FBUjtBQTRMRCxDQTdMTyxDQUFSIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfaXNSZWFjdE5hdGl2ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaXNSZWFjdE5hdGl2ZVwiKSk7XG5cbnZhciBfdXJpVG9CbG9iID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91cmlUb0Jsb2JcIikpO1xuXG52YXIgX0ZpbGVTb3VyY2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3NvdXJjZXMvRmlsZVNvdXJjZVwiKSk7XG5cbnZhciBfU3RyZWFtU291cmNlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9zb3VyY2VzL1N0cmVhbVNvdXJjZVwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG52YXIgRmlsZVJlYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEZpbGVSZWFkZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEZpbGVSZWFkZXIsIFt7XG4gICAga2V5OiBcIm9wZW5GaWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wZW5GaWxlKGlucHV0LCBjaHVua1NpemUpIHtcbiAgICAgIC8vIEluIFJlYWN0IE5hdGl2ZSwgd2hlbiB1c2VyIHNlbGVjdHMgYSBmaWxlLCBpbnN0ZWFkIG9mIGEgRmlsZSBvciBCbG9iLFxuICAgICAgLy8geW91IHVzdWFsbHkgZ2V0IGEgZmlsZSBvYmplY3Qge30gd2l0aCBhIHVyaSBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zXG4gICAgICAvLyBhIGxvY2FsIHBhdGggdG8gdGhlIGZpbGUuIFdlIHVzZSBYTUxIdHRwUmVxdWVzdCB0byBmZXRjaFxuICAgICAgLy8gdGhlIGZpbGUgYmxvYiwgYmVmb3JlIHVwbG9hZGluZyB3aXRoIHR1cy5cbiAgICAgIGlmICgoMCwgX2lzUmVhY3ROYXRpdmUuZGVmYXVsdCkoKSAmJiBpbnB1dCAmJiB0eXBlb2YgaW5wdXQudXJpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gKDAsIF91cmlUb0Jsb2IuZGVmYXVsdCkoaW5wdXQudXJpKS50aGVuKGZ1bmN0aW9uIChibG9iKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBfRmlsZVNvdXJjZS5kZWZhdWx0KGJsb2IpO1xuICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0dXM6IGNhbm5vdCBmZXRjaCBgZmlsZS51cmlgIGFzIEJsb2IsIG1ha2Ugc3VyZSB0aGUgdXJpIGlzIGNvcnJlY3QgYW5kIGFjY2Vzc2libGUuIFwiLmNvbmNhdChlcnIpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIFNpbmNlIHdlIGVtdWxhdGUgdGhlIEJsb2IgdHlwZSBpbiBvdXIgdGVzdHMgKG5vdCBhbGwgdGFyZ2V0IGJyb3dzZXJzXG4gICAgICAvLyBzdXBwb3J0IGl0KSwgd2UgY2Fubm90IHVzZSBgaW5zdGFuY2VvZmAgZm9yIHRlc3Rpbmcgd2hldGhlciB0aGUgaW5wdXQgdmFsdWVcbiAgICAgIC8vIGNhbiBiZSBoYW5kbGVkLiBJbnN0ZWFkLCB3ZSBzaW1wbHkgY2hlY2sgaXMgdGhlIHNsaWNlKCkgZnVuY3Rpb24gYW5kIHRoZVxuICAgICAgLy8gc2l6ZSBwcm9wZXJ0eSBhcmUgYXZhaWxhYmxlLlxuXG5cbiAgICAgIGlmICh0eXBlb2YgaW5wdXQuc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGlucHV0LnNpemUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IF9GaWxlU291cmNlLmRlZmF1bHQoaW5wdXQpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpbnB1dC5yZWFkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNodW5rU2l6ZSA9IE51bWJlcihjaHVua1NpemUpO1xuXG4gICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGNodW5rU2l6ZSkpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdjYW5ub3QgY3JlYXRlIHNvdXJjZSBmb3Igc3RyZWFtIHdpdGhvdXQgYSBmaW5pdGUgdmFsdWUgZm9yIHRoZSBgY2h1bmtTaXplYCBvcHRpb24nKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBfU3RyZWFtU291cmNlLmRlZmF1bHQoaW5wdXQsIGNodW5rU2l6ZSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdzb3VyY2Ugb2JqZWN0IG1heSBvbmx5IGJlIGFuIGluc3RhbmNlIG9mIEZpbGUsIEJsb2IsIG9yIFJlYWRlciBpbiB0aGlzIGVudmlyb25tZW50JykpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGaWxlUmVhZGVyO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBGaWxlUmVhZGVyOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZmluZ2VycHJpbnQ7XG5cbnZhciBfaXNSZWFjdE5hdGl2ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaXNSZWFjdE5hdGl2ZVwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vIFRPRE86IERpZmZlcmVuY2lhdGUgYmV0d2VlbiBpbnB1dCB0eXBlc1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgZmluZ2VycHJpbnQgZm9yIGEgZmlsZSB3aGljaCB3aWxsIGJlIHVzZWQgdGhlIHN0b3JlIHRoZSBlbmRwb2ludFxuICpcbiAqIEBwYXJhbSB7RmlsZX0gZmlsZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKi9cbmZ1bmN0aW9uIGZpbmdlcnByaW50KGZpbGUsIG9wdGlvbnMpIHtcbiAgaWYgKCgwLCBfaXNSZWFjdE5hdGl2ZS5kZWZhdWx0KSgpKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWFjdE5hdGl2ZUZpbmdlcnByaW50KGZpbGUsIG9wdGlvbnMpKTtcbiAgfVxuXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoWyd0dXMtYnInLCBmaWxlLm5hbWUsIGZpbGUudHlwZSwgZmlsZS5zaXplLCBmaWxlLmxhc3RNb2RpZmllZCwgb3B0aW9ucy5lbmRwb2ludF0uam9pbignLScpKTtcbn1cblxuZnVuY3Rpb24gcmVhY3ROYXRpdmVGaW5nZXJwcmludChmaWxlLCBvcHRpb25zKSB7XG4gIHZhciBleGlmSGFzaCA9IGZpbGUuZXhpZiA/IGhhc2hDb2RlKEpTT04uc3RyaW5naWZ5KGZpbGUuZXhpZikpIDogJ25vZXhpZic7XG4gIHJldHVybiBbJ3R1cy1ybicsIGZpbGUubmFtZSB8fCAnbm9uYW1lJywgZmlsZS5zaXplIHx8ICdub3NpemUnLCBleGlmSGFzaCwgb3B0aW9ucy5lbmRwb2ludF0uam9pbignLycpO1xufVxuXG5mdW5jdGlvbiBoYXNoQ29kZShzdHIpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuICAvLyBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS84ODMxOTM3LzE1MTY2NlxuICB2YXIgaGFzaCA9IDA7XG5cbiAgaWYgKHN0ci5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gaGFzaDtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9jaGFyID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgX2NoYXI7XG4gICAgaGFzaCAmPSBoYXNoOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgfVxuXG4gIHJldHVybiBoYXNoO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbi8qIGVzbGludC1kaXNhYmxlIG1heC1jbGFzc2VzLXBlci1maWxlICovXG5cblxudmFyIFhIUkh0dHBTdGFjayA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFhIUkh0dHBTdGFjaygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgWEhSSHR0cFN0YWNrKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhYSFJIdHRwU3RhY2ssIFt7XG4gICAga2V5OiBcImNyZWF0ZVJlcXVlc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlUmVxdWVzdChtZXRob2QsIHVybCkge1xuICAgICAgcmV0dXJuIG5ldyBSZXF1ZXN0KG1ldGhvZCwgdXJsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TmFtZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROYW1lKCkge1xuICAgICAgcmV0dXJuICdYSFJIdHRwU3RhY2snO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBYSFJIdHRwU3RhY2s7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFhIUkh0dHBTdGFjaztcblxudmFyIFJlcXVlc3QgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSZXF1ZXN0KG1ldGhvZCwgdXJsKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlcXVlc3QpO1xuXG4gICAgdGhpcy5feGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICB0aGlzLl94aHIub3BlbihtZXRob2QsIHVybCwgdHJ1ZSk7XG5cbiAgICB0aGlzLl9tZXRob2QgPSBtZXRob2Q7XG4gICAgdGhpcy5fdXJsID0gdXJsO1xuICAgIHRoaXMuX2hlYWRlcnMgPSB7fTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhSZXF1ZXN0LCBbe1xuICAgIGtleTogXCJnZXRNZXRob2RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWV0aG9kKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21ldGhvZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VVJMXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFVSTCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl91cmw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldEhlYWRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRIZWFkZXIoaGVhZGVyLCB2YWx1ZSkge1xuICAgICAgdGhpcy5feGhyLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyLCB2YWx1ZSk7XG5cbiAgICAgIHRoaXMuX2hlYWRlcnNbaGVhZGVyXSA9IHZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRIZWFkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SGVhZGVyKGhlYWRlcikge1xuICAgICAgcmV0dXJuIHRoaXMuX2hlYWRlcnNbaGVhZGVyXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0UHJvZ3Jlc3NIYW5kbGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFByb2dyZXNzSGFuZGxlcihwcm9ncmVzc0hhbmRsZXIpIHtcbiAgICAgIC8vIFRlc3Qgc3VwcG9ydCBmb3IgcHJvZ3Jlc3MgZXZlbnRzIGJlZm9yZSBhdHRhY2hpbmcgYW4gZXZlbnQgbGlzdGVuZXJcbiAgICAgIGlmICghKCd1cGxvYWQnIGluIHRoaXMuX3hocikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl94aHIudXBsb2FkLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoIWUubGVuZ3RoQ29tcHV0YWJsZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb2dyZXNzSGFuZGxlcihlLmxvYWRlZCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbmQoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgYm9keSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIF90aGlzLl94aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJlc29sdmUobmV3IFJlc3BvbnNlKF90aGlzLl94aHIpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy5feGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH07XG5cbiAgICAgICAgX3RoaXMuX3hoci5zZW5kKGJvZHkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFib3J0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgICAgdGhpcy5feGhyLmFib3J0KCk7XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VW5kZXJseWluZ09iamVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRVbmRlcmx5aW5nT2JqZWN0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3hocjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmVxdWVzdDtcbn0oKTtcblxudmFyIFJlc3BvbnNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVzcG9uc2UoeGhyKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlc3BvbnNlKTtcblxuICAgIHRoaXMuX3hociA9IHhocjtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhSZXNwb25zZSwgW3tcbiAgICBrZXk6IFwiZ2V0U3RhdHVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN0YXR1cygpIHtcbiAgICAgIHJldHVybiB0aGlzLl94aHIuc3RhdHVzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRIZWFkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SGVhZGVyKGhlYWRlcikge1xuICAgICAgcmV0dXJuIHRoaXMuX3hoci5nZXRSZXNwb25zZUhlYWRlcihoZWFkZXIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRCb2R5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJvZHkoKSB7XG4gICAgICByZXR1cm4gdGhpcy5feGhyLnJlc3BvbnNlVGV4dDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VW5kZXJseWluZ09iamVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRVbmRlcmx5aW5nT2JqZWN0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3hocjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmVzcG9uc2U7XG59KCk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEZWZhdWx0SHR0cFN0YWNrXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9odHRwU3RhY2suZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEZXRhaWxlZEVycm9yXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9lcnJvci5kZWZhdWx0O1xuICB9XG59KTtcbmV4cG9ydHMuVXBsb2FkID0gdm9pZCAwO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY2FuU3RvcmVVUkxzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91cmxTdG9yYWdlLmNhblN0b3JlVVJMcztcbiAgfVxufSk7XG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gdm9pZCAwO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5hYmxlRGVidWdMb2dcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2xvZ2dlci5lbmFibGVEZWJ1Z0xvZztcbiAgfVxufSk7XG5leHBvcnRzLmlzU3VwcG9ydGVkID0gdm9pZCAwO1xuXG52YXIgX3VwbG9hZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3VwbG9hZFwiKSk7XG5cbnZhciBfbm9vcFVybFN0b3JhZ2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9ub29wVXJsU3RvcmFnZVwiKSk7XG5cbnZhciBfbG9nZ2VyID0gcmVxdWlyZShcIi4uL2xvZ2dlclwiKTtcblxudmFyIF9lcnJvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2Vycm9yXCIpKTtcblxudmFyIF91cmxTdG9yYWdlID0gcmVxdWlyZShcIi4vdXJsU3RvcmFnZVwiKTtcblxudmFyIF9odHRwU3RhY2sgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2h0dHBTdGFja1wiKSk7XG5cbnZhciBfZmlsZVJlYWRlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vZmlsZVJlYWRlclwiKSk7XG5cbnZhciBfZmlsZVNpZ25hdHVyZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vZmlsZVNpZ25hdHVyZVwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgfSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICB9LCBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSxcbiAgICAgICAgcmVzdWx0O1xuXG4gICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG5cbiAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7XG4gIH1cblxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxudmFyIGRlZmF1bHRPcHRpb25zID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBfdXBsb2FkLmRlZmF1bHQuZGVmYXVsdE9wdGlvbnMpLCB7fSwge1xuICBodHRwU3RhY2s6IG5ldyBfaHR0cFN0YWNrLmRlZmF1bHQoKSxcbiAgZmlsZVJlYWRlcjogbmV3IF9maWxlUmVhZGVyLmRlZmF1bHQoKSxcbiAgdXJsU3RvcmFnZTogX3VybFN0b3JhZ2UuY2FuU3RvcmVVUkxzID8gbmV3IF91cmxTdG9yYWdlLldlYlN0b3JhZ2VVcmxTdG9yYWdlKCkgOiBuZXcgX25vb3BVcmxTdG9yYWdlLmRlZmF1bHQoKSxcbiAgZmluZ2VycHJpbnQ6IF9maWxlU2lnbmF0dXJlLmRlZmF1bHRcbn0pO1xuXG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG5cbnZhciBVcGxvYWQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlVXBsb2FkKSB7XG4gIF9pbmhlcml0cyhVcGxvYWQsIF9CYXNlVXBsb2FkKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFVwbG9hZCk7XG5cbiAgZnVuY3Rpb24gVXBsb2FkKCkge1xuICAgIHZhciBmaWxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBVcGxvYWQpO1xuXG4gICAgb3B0aW9ucyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdE9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgZmlsZSwgb3B0aW9ucyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVXBsb2FkLCBudWxsLCBbe1xuICAgIGtleTogXCJ0ZXJtaW5hdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGVybWluYXRlKHVybCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgb3B0aW9ucyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdE9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBfdXBsb2FkLmRlZmF1bHQudGVybWluYXRlKHVybCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFVwbG9hZDtcbn0oX3VwbG9hZC5kZWZhdWx0KTtcblxuZXhwb3J0cy5VcGxvYWQgPSBVcGxvYWQ7XG52YXIgX3dpbmRvdyA9IHdpbmRvdyxcbiAgICBYTUxIdHRwUmVxdWVzdCA9IF93aW5kb3cuWE1MSHR0cFJlcXVlc3QsXG4gICAgQmxvYiA9IF93aW5kb3cuQmxvYjtcbnZhciBpc1N1cHBvcnRlZCA9IFhNTEh0dHBSZXF1ZXN0ICYmIEJsb2IgJiYgdHlwZW9mIEJsb2IucHJvdG90eXBlLnNsaWNlID09PSAnZnVuY3Rpb24nO1xuZXhwb3J0cy5pc1N1cHBvcnRlZCA9IGlzU3VwcG9ydGVkOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgaXNSZWFjdE5hdGl2ZSA9IGZ1bmN0aW9uIGlzUmVhY3ROYXRpdmUoKSB7XG4gIHJldHVybiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdzdHJpbmcnICYmIG5hdmlnYXRvci5wcm9kdWN0LnRvTG93ZXJDYXNlKCkgPT09ICdyZWFjdG5hdGl2ZSc7XG59O1xuXG52YXIgX2RlZmF1bHQgPSBpc1JlYWN0TmF0aXZlO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfaXNDb3Jkb3ZhID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pc0NvcmRvdmFcIikpO1xuXG52YXIgX3JlYWRBc0J5dGVBcnJheSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcmVhZEFzQnl0ZUFycmF5XCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbnZhciBGaWxlU291cmNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLy8gTWFrZSB0aGlzLnNpemUgYSBtZXRob2RcbiAgZnVuY3Rpb24gRmlsZVNvdXJjZShmaWxlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZpbGVTb3VyY2UpO1xuXG4gICAgdGhpcy5fZmlsZSA9IGZpbGU7XG4gICAgdGhpcy5zaXplID0gZmlsZS5zaXplO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEZpbGVTb3VyY2UsIFt7XG4gICAga2V5OiBcInNsaWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICAgIC8vIEluIEFwYWNoZSBDb3Jkb3ZhIGFwcGxpY2F0aW9ucywgYSBGaWxlIG11c3QgYmUgcmVzb2x2ZWQgdXNpbmdcbiAgICAgIC8vIEZpbGVSZWFkZXIgaW5zdGFuY2VzLCBzZWVcbiAgICAgIC8vIGh0dHBzOi8vY29yZG92YS5hcGFjaGUub3JnL2RvY3MvZW4vOC54L3JlZmVyZW5jZS9jb3Jkb3ZhLXBsdWdpbi1maWxlL2luZGV4Lmh0bWwjcmVhZC1hLWZpbGVcbiAgICAgIGlmICgoMCwgX2lzQ29yZG92YS5kZWZhdWx0KSgpKSB7XG4gICAgICAgIHJldHVybiAoMCwgX3JlYWRBc0J5dGVBcnJheS5kZWZhdWx0KSh0aGlzLl9maWxlLnNsaWNlKHN0YXJ0LCBlbmQpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlID0gdGhpcy5fZmlsZS5zbGljZShzdGFydCwgZW5kKTtcblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKCkgey8vIE5vdGhpbmcgdG8gZG8gaGVyZSBzaW5jZSB3ZSBkb24ndCBuZWVkIHRvIHJlbGVhc2UgYW55IHJlc291cmNlcy5cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRmlsZVNvdXJjZTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gRmlsZVNvdXJjZTsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIGxlbihibG9iT3JBcnJheSkge1xuICBpZiAoYmxvYk9yQXJyYXkgPT09IHVuZGVmaW5lZCkgcmV0dXJuIDA7XG4gIGlmIChibG9iT3JBcnJheS5zaXplICE9PSB1bmRlZmluZWQpIHJldHVybiBibG9iT3JBcnJheS5zaXplO1xuICByZXR1cm4gYmxvYk9yQXJyYXkubGVuZ3RoO1xufVxuLypcbiAgVHlwZWQgYXJyYXlzIGFuZCBibG9icyBkb24ndCBoYXZlIGEgY29uY2F0IG1ldGhvZC5cbiAgVGhpcyBmdW5jdGlvbiBoZWxwcyBTdHJlYW1Tb3VyY2UgYWNjdW11bGF0ZSBkYXRhIHRvIHJlYWNoIGNodW5rU2l6ZS5cbiovXG5cblxuZnVuY3Rpb24gY29uY2F0KGEsIGIpIHtcbiAgaWYgKGEuY29uY2F0KSB7XG4gICAgLy8gSXMgYGFgIGFuIEFycmF5P1xuICAgIHJldHVybiBhLmNvbmNhdChiKTtcbiAgfVxuXG4gIGlmIChhIGluc3RhbmNlb2YgQmxvYikge1xuICAgIHJldHVybiBuZXcgQmxvYihbYSwgYl0sIHtcbiAgICAgIHR5cGU6IGEudHlwZVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKGEuc2V0KSB7XG4gICAgLy8gSXMgYGFgIGEgdHlwZWQgYXJyYXk/XG4gICAgdmFyIGMgPSBuZXcgYS5jb25zdHJ1Y3RvcihhLmxlbmd0aCArIGIubGVuZ3RoKTtcbiAgICBjLnNldChhKTtcbiAgICBjLnNldChiLCBhLmxlbmd0aCk7XG4gICAgcmV0dXJuIGM7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZGF0YSB0eXBlJyk7XG59XG5cbnZhciBTdHJlYW1Tb3VyY2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdHJlYW1Tb3VyY2UocmVhZGVyKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0cmVhbVNvdXJjZSk7XG5cbiAgICB0aGlzLl9idWZmZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fYnVmZmVyT2Zmc2V0ID0gMDtcbiAgICB0aGlzLl9yZWFkZXIgPSByZWFkZXI7XG4gICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFN0cmVhbVNvdXJjZSwgW3tcbiAgICBrZXk6IFwic2xpY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgICAgaWYgKHN0YXJ0IDwgdGhpcy5fYnVmZmVyT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJSZXF1ZXN0ZWQgZGF0YSBpcyBiZWZvcmUgdGhlIHJlYWRlcidzIGN1cnJlbnQgb2Zmc2V0XCIpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3JlYWRVbnRpbEVub3VnaERhdGFPckRvbmUoc3RhcnQsIGVuZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9yZWFkVW50aWxFbm91Z2hEYXRhT3JEb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWFkVW50aWxFbm91Z2hEYXRhT3JEb25lKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBoYXNFbm91Z2hEYXRhID0gZW5kIDw9IHRoaXMuX2J1ZmZlck9mZnNldCArIGxlbih0aGlzLl9idWZmZXIpO1xuXG4gICAgICBpZiAodGhpcy5fZG9uZSB8fCBoYXNFbm91Z2hEYXRhKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2dldERhdGFGcm9tQnVmZmVyKHN0YXJ0LCBlbmQpO1xuXG4gICAgICAgIHZhciBkb25lID0gdmFsdWUgPT0gbnVsbCA/IHRoaXMuX2RvbmUgOiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIGRvbmU6IGRvbmVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gX3JlZi52YWx1ZSxcbiAgICAgICAgICAgIGRvbmUgPSBfcmVmLmRvbmU7XG5cbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICBfdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoX3RoaXMuX2J1ZmZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgX3RoaXMuX2J1ZmZlciA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzLl9idWZmZXIgPSBjb25jYXQoX3RoaXMuX2J1ZmZlciwgdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF90aGlzLl9yZWFkVW50aWxFbm91Z2hEYXRhT3JEb25lKHN0YXJ0LCBlbmQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXREYXRhRnJvbUJ1ZmZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGF0YUZyb21CdWZmZXIoc3RhcnQsIGVuZCkge1xuICAgICAgLy8gUmVtb3ZlIGRhdGEgZnJvbSBidWZmZXIgYmVmb3JlIGBzdGFydGAuXG4gICAgICAvLyBEYXRhIG1pZ2h0IGJlIHJlcmVhZCBmcm9tIHRoZSBidWZmZXIgaWYgYW4gdXBsb2FkIGZhaWxzLCBzbyB3ZSBjYW4gb25seVxuICAgICAgLy8gc2FmZWx5IGRlbGV0ZSBkYXRhIHdoZW4gaXQgY29tZXMgKmJlZm9yZSogd2hhdCBpcyBjdXJyZW50bHkgYmVpbmcgcmVhZC5cbiAgICAgIGlmIChzdGFydCA+IHRoaXMuX2J1ZmZlck9mZnNldCkge1xuICAgICAgICB0aGlzLl9idWZmZXIgPSB0aGlzLl9idWZmZXIuc2xpY2Uoc3RhcnQgLSB0aGlzLl9idWZmZXJPZmZzZXQpO1xuICAgICAgICB0aGlzLl9idWZmZXJPZmZzZXQgPSBzdGFydDtcbiAgICAgIH0gLy8gSWYgdGhlIGJ1ZmZlciBpcyBlbXB0eSBhZnRlciByZW1vdmluZyBvbGQgZGF0YSwgYWxsIGRhdGEgaGFzIGJlZW4gcmVhZC5cblxuXG4gICAgICB2YXIgaGFzQWxsRGF0YUJlZW5SZWFkID0gbGVuKHRoaXMuX2J1ZmZlcikgPT09IDA7XG5cbiAgICAgIGlmICh0aGlzLl9kb25lICYmIGhhc0FsbERhdGFCZWVuUmVhZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gLy8gV2UgYWxyZWFkeSByZW1vdmVkIGRhdGEgYmVmb3JlIGBzdGFydGAsIHNvIHdlIGp1c3QgcmV0dXJuIHRoZSBmaXJzdFxuICAgICAgLy8gY2h1bmsgZnJvbSB0aGUgYnVmZmVyLlxuXG5cbiAgICAgIHJldHVybiB0aGlzLl9idWZmZXIuc2xpY2UoMCwgZW5kIC0gc3RhcnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgIGlmICh0aGlzLl9yZWFkZXIuY2FuY2VsKSB7XG4gICAgICAgIHRoaXMuX3JlYWRlci5jYW5jZWwoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3RyZWFtU291cmNlO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBTdHJlYW1Tb3VyY2U7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBpc0NvcmRvdmEgPSBmdW5jdGlvbiBpc0NvcmRvdmEoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAodHlwZW9mIHdpbmRvdy5QaG9uZUdhcCAhPT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHdpbmRvdy5Db3Jkb3ZhICE9PSAndW5kZWZpbmVkJyB8fCB0eXBlb2Ygd2luZG93LmNvcmRvdmEgIT09ICd1bmRlZmluZWQnKTtcbn07XG5cbnZhciBfZGVmYXVsdCA9IGlzQ29yZG92YTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gcmVhZEFzQnl0ZUFycmF5O1xuXG4vKipcbiAqIHJlYWRBc0J5dGVBcnJheSBjb252ZXJ0cyBhIEZpbGUgb2JqZWN0IHRvIGEgVWludDhBcnJheS5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgb25seSB1c2VkIG9uIHRoZSBBcGFjaGUgQ29yZG92YSBwbGF0Zm9ybS5cbiAqIFNlZSBodHRwczovL2NvcmRvdmEuYXBhY2hlLm9yZy9kb2NzL2VuL2xhdGVzdC9yZWZlcmVuY2UvY29yZG92YS1wbHVnaW4tZmlsZS9pbmRleC5odG1sI3JlYWQtYS1maWxlXG4gKi9cbmZ1bmN0aW9uIHJlYWRBc0J5dGVBcnJheShjaHVuaykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXG4gICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IG5ldyBVaW50OEFycmF5KHJlYWRlci5yZXN1bHQpO1xuICAgICAgcmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfTtcblxuICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihjaHVuayk7XG4gIH0pO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdXJpVG9CbG9iO1xuXG4vKipcbiAqIHVyaVRvQmxvYiByZXNvbHZlcyBhIFVSSSB0byBhIEJsb2Igb2JqZWN0LiBUaGlzIGlzIHVzZWQgZm9yXG4gKiBSZWFjdCBOYXRpdmUgdG8gcmV0cmlldmUgYSBmaWxlIChpZGVudGlmaWVkIGJ5IGEgZmlsZTovL1xuICogVVJJKSBhcyBhIGJsb2IuXG4gKi9cbmZ1bmN0aW9uIHVyaVRvQmxvYih1cmkpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdibG9iJztcblxuICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYmxvYiA9IHhoci5yZXNwb25zZTtcbiAgICAgIHJlc29sdmUoYmxvYik7XG4gICAgfTtcblxuICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfTtcblxuICAgIHhoci5vcGVuKCdHRVQnLCB1cmkpO1xuICAgIHhoci5zZW5kKCk7XG4gIH0pO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jYW5TdG9yZVVSTHMgPSBleHBvcnRzLldlYlN0b3JhZ2VVcmxTdG9yYWdlID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxudmFyIGhhc1N0b3JhZ2UgPSBmYWxzZTtcblxudHJ5IHtcbiAgaGFzU3RvcmFnZSA9ICdsb2NhbFN0b3JhZ2UnIGluIHdpbmRvdzsgLy8gQXR0ZW1wdCB0byBzdG9yZSBhbmQgcmVhZCBlbnRyaWVzIGZyb20gdGhlIGxvY2FsIHN0b3JhZ2UgdG8gZGV0ZWN0IFByaXZhdGVcbiAgLy8gTW9kZSBvbiBTYWZhcmkgb24gaU9TIChzZWUgIzQ5KVxuXG4gIHZhciBrZXkgPSAndHVzU3VwcG9ydCc7XG4gIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KSk7XG59IGNhdGNoIChlKSB7XG4gIC8vIElmIHdlIHRyeSB0byBhY2Nlc3MgbG9jYWxTdG9yYWdlIGluc2lkZSBhIHNhbmRib3hlZCBpZnJhbWUsIGEgU2VjdXJpdHlFcnJvclxuICAvLyBpcyB0aHJvd24uIFdoZW4gaW4gcHJpdmF0ZSBtb2RlIG9uIGlPUyBTYWZhcmksIGEgUXVvdGFFeGNlZWRlZEVycm9yIGlzXG4gIC8vIHRocm93biAoc2VlICM0OSlcbiAgaWYgKGUuY29kZSA9PT0gZS5TRUNVUklUWV9FUlIgfHwgZS5jb2RlID09PSBlLlFVT1RBX0VYQ0VFREVEX0VSUikge1xuICAgIGhhc1N0b3JhZ2UgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBlO1xuICB9XG59XG5cbnZhciBjYW5TdG9yZVVSTHMgPSBoYXNTdG9yYWdlO1xuZXhwb3J0cy5jYW5TdG9yZVVSTHMgPSBjYW5TdG9yZVVSTHM7XG5cbnZhciBXZWJTdG9yYWdlVXJsU3RvcmFnZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFdlYlN0b3JhZ2VVcmxTdG9yYWdlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXZWJTdG9yYWdlVXJsU3RvcmFnZSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoV2ViU3RvcmFnZVVybFN0b3JhZ2UsIFt7XG4gICAga2V5OiBcImZpbmRBbGxVcGxvYWRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRBbGxVcGxvYWRzKCkge1xuICAgICAgdmFyIHJlc3VsdHMgPSB0aGlzLl9maW5kRW50cmllcygndHVzOjonKTtcblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmluZFVwbG9hZHNCeUZpbmdlcnByaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRVcGxvYWRzQnlGaW5nZXJwcmludChmaW5nZXJwcmludCkge1xuICAgICAgdmFyIHJlc3VsdHMgPSB0aGlzLl9maW5kRW50cmllcyhcInR1czo6XCIuY29uY2F0KGZpbmdlcnByaW50LCBcIjo6XCIpKTtcblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlVXBsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZVVwbG9hZCh1cmxTdG9yYWdlS2V5KSB7XG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh1cmxTdG9yYWdlS2V5KTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkVXBsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFVwbG9hZChmaW5nZXJwcmludCwgdXBsb2FkKSB7XG4gICAgICB2YXIgaWQgPSBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAxZTEyKTtcbiAgICAgIHZhciBrZXkgPSBcInR1czo6XCIuY29uY2F0KGZpbmdlcnByaW50LCBcIjo6XCIpLmNvbmNhdChpZCk7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIEpTT04uc3RyaW5naWZ5KHVwbG9hZCkpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShrZXkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZmluZEVudHJpZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRFbnRyaWVzKHByZWZpeCkge1xuICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2NhbFN0b3JhZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIF9rZXkgPSBsb2NhbFN0b3JhZ2Uua2V5KGkpO1xuXG4gICAgICAgIGlmIChfa2V5LmluZGV4T2YocHJlZml4KSAhPT0gMCkgY29udGludWU7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgdXBsb2FkID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShfa2V5KSk7XG4gICAgICAgICAgdXBsb2FkLnVybFN0b3JhZ2VLZXkgPSBfa2V5O1xuICAgICAgICAgIHJlc3VsdHMucHVzaCh1cGxvYWQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7Ly8gVGhlIEpTT04gcGFyc2UgZXJyb3IgaXMgaW50ZW50aW9uYWxseSBpZ25vcmVkIGhlcmUsIHNvIGEgbWFsZm9ybWVkXG4gICAgICAgICAgLy8gZW50cnkgaW4gdGhlIHN0b3JhZ2UgY2Fubm90IHByZXZlbnQgYW4gdXBsb2FkLlxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBXZWJTdG9yYWdlVXJsU3RvcmFnZTtcbn0oKTtcblxuZXhwb3J0cy5XZWJTdG9yYWdlVXJsU3RvcmFnZSA9IFdlYlN0b3JhZ2VVcmxTdG9yYWdlOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gIH0gOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgfSwgX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLFxuICAgICAgICByZXN1bHQ7XG5cbiAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcblxuICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgfVxuXG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gIHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgTWFwKCkgOiB1bmRlZmluZWQ7XG5cbiAgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgICBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzO1xuXG4gICAgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBfY2FjaGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpO1xuXG4gICAgICBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBXcmFwcGVyKCkge1xuICAgICAgcmV0dXJuIF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTtcbiAgICB9XG5cbiAgICBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogV3JhcHBlcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTtcbiAgfTtcblxuICByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7XG4gICAgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0LmJpbmQoKTtcbiAgfSBlbHNlIHtcbiAgICBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gICAgICB2YXIgYSA9IFtudWxsXTtcbiAgICAgIGEucHVzaC5hcHBseShhLCBhcmdzKTtcbiAgICAgIHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTtcbiAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpO1xuICAgICAgaWYgKENsYXNzKSBfc2V0UHJvdG90eXBlT2YoaW5zdGFuY2UsIENsYXNzLnByb3RvdHlwZSk7XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcblxuICB0cnkge1xuICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikge1xuICByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikgIT09IC0xO1xufVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbnZhciBEZXRhaWxlZEVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXJyb3IpIHtcbiAgX2luaGVyaXRzKERldGFpbGVkRXJyb3IsIF9FcnJvcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihEZXRhaWxlZEVycm9yKTtcblxuICBmdW5jdGlvbiBEZXRhaWxlZEVycm9yKG1lc3NhZ2UpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICB2YXIgY2F1c2luZ0VyciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgICB2YXIgcmVxID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuICAgIHZhciByZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGV0YWlsZWRFcnJvcik7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgIF90aGlzLm9yaWdpbmFsUmVxdWVzdCA9IHJlcTtcbiAgICBfdGhpcy5vcmlnaW5hbFJlc3BvbnNlID0gcmVzO1xuICAgIF90aGlzLmNhdXNpbmdFcnJvciA9IGNhdXNpbmdFcnI7XG5cbiAgICBpZiAoY2F1c2luZ0VyciAhPSBudWxsKSB7XG4gICAgICBtZXNzYWdlICs9IFwiLCBjYXVzZWQgYnkgXCIuY29uY2F0KGNhdXNpbmdFcnIudG9TdHJpbmcoKSk7XG4gICAgfVxuXG4gICAgaWYgKHJlcSAhPSBudWxsKSB7XG4gICAgICB2YXIgcmVxdWVzdElkID0gcmVxLmdldEhlYWRlcignWC1SZXF1ZXN0LUlEJykgfHwgJ24vYSc7XG4gICAgICB2YXIgbWV0aG9kID0gcmVxLmdldE1ldGhvZCgpO1xuICAgICAgdmFyIHVybCA9IHJlcS5nZXRVUkwoKTtcbiAgICAgIHZhciBzdGF0dXMgPSByZXMgPyByZXMuZ2V0U3RhdHVzKCkgOiAnbi9hJztcbiAgICAgIHZhciBib2R5ID0gcmVzID8gcmVzLmdldEJvZHkoKSB8fCAnJyA6ICduL2EnO1xuICAgICAgbWVzc2FnZSArPSBcIiwgb3JpZ2luYXRlZCBmcm9tIHJlcXVlc3QgKG1ldGhvZDogXCIuY29uY2F0KG1ldGhvZCwgXCIsIHVybDogXCIpLmNvbmNhdCh1cmwsIFwiLCByZXNwb25zZSBjb2RlOiBcIikuY29uY2F0KHN0YXR1cywgXCIsIHJlc3BvbnNlIHRleHQ6IFwiKS5jb25jYXQoYm9keSwgXCIsIHJlcXVlc3QgaWQ6IFwiKS5jb25jYXQocmVxdWVzdElkLCBcIilcIik7XG4gICAgfVxuXG4gICAgX3RoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhEZXRhaWxlZEVycm9yKTtcbn0oIC8qI19fUFVSRV9fKi9fd3JhcE5hdGl2ZVN1cGVyKEVycm9yKSk7XG5cbnZhciBfZGVmYXVsdCA9IERldGFpbGVkRXJyb3I7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZW5hYmxlRGVidWdMb2cgPSBlbmFibGVEZWJ1Z0xvZztcbmV4cG9ydHMubG9nID0gbG9nO1xuXG4vKiBlc2xpbnQgbm8tY29uc29sZTogXCJvZmZcIiAqL1xudmFyIGlzRW5hYmxlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBlbmFibGVEZWJ1Z0xvZygpIHtcbiAgaXNFbmFibGVkID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gbG9nKG1zZykge1xuICBpZiAoIWlzRW5hYmxlZCkgcmV0dXJuO1xuICBjb25zb2xlLmxvZyhtc2cpO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogXCJvZmZcIiAqL1xuXG5cbnZhciBOb29wVXJsU3RvcmFnZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE5vb3BVcmxTdG9yYWdlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb29wVXJsU3RvcmFnZSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTm9vcFVybFN0b3JhZ2UsIFt7XG4gICAga2V5OiBcImxpc3RBbGxVcGxvYWRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpc3RBbGxVcGxvYWRzKCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpbmRVcGxvYWRzQnlGaW5nZXJwcmludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kVXBsb2Fkc0J5RmluZ2VycHJpbnQoZmluZ2VycHJpbnQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVVcGxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlVXBsb2FkKHVybFN0b3JhZ2VLZXkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkVXBsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFVwbG9hZChmaW5nZXJwcmludCwgdXBsb2FkKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBOb29wVXJsU3RvcmFnZTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gTm9vcFVybFN0b3JhZ2U7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfanNCYXNlID0gcmVxdWlyZShcImpzLWJhc2U2NFwiKTtcblxudmFyIF91cmxQYXJzZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInVybC1wYXJzZVwiKSk7XG5cbnZhciBfZXJyb3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Vycm9yXCIpKTtcblxudmFyIF9sb2dnZXIgPSByZXF1aXJlKFwiLi9sb2dnZXJcIik7XG5cbnZhciBfdXVpZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXVpZFwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyMltpXSA9IGFycltpXTtcbiAgfVxuXG4gIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIHZhciBfaSA9IGFyciA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTtcblxuICBpZiAoX2kgPT0gbnVsbCkgcmV0dXJuO1xuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcblxuICB2YXIgX3MsIF9lO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaSA9IF9pLmNhbGwoYXJyKTsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2QgPSB0cnVlO1xuICAgIF9lID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9hcnI7XG59XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgZW5kcG9pbnQ6IG51bGwsXG4gIHVwbG9hZFVybDogbnVsbCxcbiAgbWV0YWRhdGE6IHt9LFxuICBmaW5nZXJwcmludDogbnVsbCxcbiAgdXBsb2FkU2l6ZTogbnVsbCxcbiAgb25Qcm9ncmVzczogbnVsbCxcbiAgb25DaHVua0NvbXBsZXRlOiBudWxsLFxuICBvblN1Y2Nlc3M6IG51bGwsXG4gIG9uRXJyb3I6IG51bGwsXG4gIF9vblVwbG9hZFVybEF2YWlsYWJsZTogbnVsbCxcbiAgb3ZlcnJpZGVQYXRjaE1ldGhvZDogZmFsc2UsXG4gIGhlYWRlcnM6IHt9LFxuICBhZGRSZXF1ZXN0SWQ6IGZhbHNlLFxuICBvbkJlZm9yZVJlcXVlc3Q6IG51bGwsXG4gIG9uQWZ0ZXJSZXNwb25zZTogbnVsbCxcbiAgb25TaG91bGRSZXRyeTogbnVsbCxcbiAgY2h1bmtTaXplOiBJbmZpbml0eSxcbiAgcmV0cnlEZWxheXM6IFswLCAxMDAwLCAzMDAwLCA1MDAwXSxcbiAgcGFyYWxsZWxVcGxvYWRzOiAxLFxuICBzcGxpdFNpemVJbnRvUGFydHM6IG51bGwsXG4gIC8vIElmIHNldCwgd2FpdCBmb3Igb25lIHBhcnRpYWwgcGFyYWxsZWwgdXBsb2FkIGNodW5rIHRvIHJlYWNoIHRoaXMgcGVyY2VudGFnZVxuICAvLyBiZWZvcmUgcmVzdW1pbmcgdGhlIG5leHQgcGFydGlhbCB1cGxvYWQuXG4gIHN0YWdnZXJQZXJjZW50OiBudWxsLFxuICBzdG9yZUZpbmdlcnByaW50Rm9yUmVzdW1pbmc6IHRydWUsXG4gIHJlbW92ZUZpbmdlcnByaW50T25TdWNjZXNzOiBmYWxzZSxcbiAgdXBsb2FkTGVuZ3RoRGVmZXJyZWQ6IGZhbHNlLFxuICB1cGxvYWREYXRhRHVyaW5nQ3JlYXRpb246IGZhbHNlLFxuICB1cmxTdG9yYWdlOiBudWxsLFxuICBmaWxlUmVhZGVyOiBudWxsLFxuICBodHRwU3RhY2s6IG51bGxcbn07XG5cbnZhciBCYXNlVXBsb2FkID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQmFzZVVwbG9hZChmaWxlLCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhc2VVcGxvYWQpOyAvLyBXYXJuIGFib3V0IHJlbW92ZWQgb3B0aW9ucyBmcm9tIHByZXZpb3VzIHZlcnNpb25zXG5cblxuICAgIGlmICgncmVzdW1lJyBpbiBvcHRpb25zKSB7XG4gICAgICBjb25zb2xlLmxvZygndHVzOiBUaGUgYHJlc3VtZWAgb3B0aW9uIGhhcyBiZWVuIHJlbW92ZWQgaW4gdHVzLWpzLWNsaWVudCB2Mi4gUGxlYXNlIHVzZSB0aGUgVVJMIHN0b3JhZ2UgQVBJIGluc3RlYWQuJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgIH0gLy8gVGhlIGRlZmF1bHQgb3B0aW9ucyB3aWxsIGFscmVhZHkgYmUgYWRkZWQgZnJvbSB0aGUgd3JhcHBlciBjbGFzc2VzLlxuXG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zOyAvLyBDYXN0IGNodW5rU2l6ZSB0byBpbnRlZ2VyXG5cbiAgICB0aGlzLm9wdGlvbnMuY2h1bmtTaXplID0gTnVtYmVyKHRoaXMub3B0aW9ucy5jaHVua1NpemUpOyAvLyBUaGUgc3RvcmFnZSBtb2R1bGUgdXNlZCB0byBzdG9yZSBVUkxzXG5cbiAgICB0aGlzLl91cmxTdG9yYWdlID0gdGhpcy5vcHRpb25zLnVybFN0b3JhZ2U7IC8vIFRoZSB1bmRlcmx5aW5nIEZpbGUvQmxvYiBvYmplY3RcblxuICAgIHRoaXMuZmlsZSA9IGZpbGU7IC8vIFRoZSBVUkwgYWdhaW5zdCB3aGljaCB0aGUgZmlsZSB3aWxsIGJlIHVwbG9hZGVkXG5cbiAgICB0aGlzLnVybCA9IG51bGw7IC8vIFRoZSB1bmRlcmx5aW5nIHJlcXVlc3Qgb2JqZWN0IGZvciB0aGUgY3VycmVudCBQQVRDSCByZXF1ZXN0XG5cbiAgICB0aGlzLl9yZXEgPSBudWxsOyAvLyBUaGUgZmluZ2VycGlucnQgZm9yIHRoZSBjdXJyZW50IGZpbGUgKHNldCBhZnRlciBzdGFydCgpKVxuXG4gICAgdGhpcy5fZmluZ2VycHJpbnQgPSBudWxsOyAvLyBUaGUga2V5IHRoYXQgdGhlIFVSTCBzdG9yYWdlIHJldHVybmVkIHdoZW4gc2F2aW5nIGFuIFVSTCB3aXRoIGEgZmluZ2VycHJpbnQsXG5cbiAgICB0aGlzLl91cmxTdG9yYWdlS2V5ID0gbnVsbDsgLy8gVGhlIG9mZnNldCB1c2VkIGluIHRoZSBjdXJyZW50IFBBVENIIHJlcXVlc3RcblxuICAgIHRoaXMuX29mZnNldCA9IG51bGw7IC8vIFRydWUgaWYgdGhlIGN1cnJlbnQgUEFUQ0ggcmVxdWVzdCBoYXMgYmVlbiBhYm9ydGVkXG5cbiAgICB0aGlzLl9hYm9ydGVkID0gZmFsc2U7IC8vIFRoZSBmaWxlJ3Mgc2l6ZSBpbiBieXRlc1xuXG4gICAgdGhpcy5fc2l6ZSA9IG51bGw7IC8vIFRoZSBTb3VyY2Ugb2JqZWN0IHdoaWNoIHdpbGwgd3JhcCBhcm91bmQgdGhlIGdpdmVuIGZpbGUgYW5kIHByb3ZpZGVzIHVzXG4gICAgLy8gd2l0aCBhIHVuaWZpZWQgaW50ZXJmYWNlIGZvciBnZXR0aW5nIGl0cyBzaXplIGFuZCBzbGljZSBjaHVua3MgZnJvbSBpdHNcbiAgICAvLyBjb250ZW50IGFsbG93aW5nIHVzIHRvIGVhc2lseSBoYW5kbGUgRmlsZXMsIEJsb2JzLCBCdWZmZXJzIGFuZCBTdHJlYW1zLlxuXG4gICAgdGhpcy5fc291cmNlID0gbnVsbDsgLy8gVGhlIGN1cnJlbnQgY291bnQgb2YgYXR0ZW1wdHMgd2hpY2ggaGF2ZSBiZWVuIG1hZGUuIFplcm8gaW5kaWNhdGVzIG5vbmUuXG5cbiAgICB0aGlzLl9yZXRyeUF0dGVtcHQgPSAwOyAvLyBUaGUgdGltZW91dCdzIElEIHdoaWNoIGlzIHVzZWQgdG8gZGVsYXkgdGhlIG5leHQgcmV0cnlcblxuICAgIHRoaXMuX3JldHJ5VGltZW91dCA9IG51bGw7IC8vIFRoZSBvZmZzZXQgb2YgdGhlIHJlbW90ZSB1cGxvYWQgYmVmb3JlIHRoZSBsYXRlc3QgYXR0ZW1wdCB3YXMgc3RhcnRlZC5cblxuICAgIHRoaXMuX29mZnNldEJlZm9yZVJldHJ5ID0gMDsgLy8gQW4gYXJyYXkgb2YgQmFzZVVwbG9hZCBpbnN0YW5jZXMgd2hpY2ggYXJlIHVzZWQgZm9yIHVwbG9hZGluZyB0aGUgZGlmZmVyZW50XG4gICAgLy8gcGFydHMsIGlmIHRoZSBwYXJhbGxlbFVwbG9hZHMgb3B0aW9uIGlzIHVzZWQuXG5cbiAgICB0aGlzLl9wYXJhbGxlbFVwbG9hZHMgPSBudWxsOyAvLyBBIGN1c3RvbSBmdW5jdGlvbiBmb3Igc3BsaXR0aW5nIHRoZSB1cGxvYWQgc2l6ZSBpbnRvIHBhcnRzLCBpZiB0aGVcbiAgICAvLyBwYXJhbGxlbFVwbG9hZHMgb3B0aW9uIGlzIHVzZWQuXG5cbiAgICB0aGlzLl9zcGxpdFNpemVJbnRvUGFydHMgPSBudWxsOyAvLyBBbiBhcnJheSBvZiB1cGxvYWQgVVJMcyB3aGljaCBhcmUgdXNlZCBmb3IgdXBsb2FkaW5nIHRoZSBkaWZmZXJlbnRcbiAgICAvLyBwYXJ0cywgaWYgdGhlIHBhcmFsbGVsVXBsb2FkcyBvcHRpb24gaXMgdXNlZC5cblxuICAgIHRoaXMuX3BhcmFsbGVsVXBsb2FkVXJscyA9IG51bGw7IC8vIElmIGEgcGFydGlhbCB1cGxvYWQsIHRoZSBjdXJyZW50IGNodW5rIG9iamVjdCB0aGF0IHRoaXMgcGFydGlhbCB1cGxvYWQgaXNcbiAgICAvLyB1cGxvYWRpbmcuXG5cbiAgICB0aGlzLl9jdXJyZW50Q2h1bmsgPSBudWxsOyAvLyBXaGV0aGVyIHRoaXMgaXMgYW4gaW5pdGlhbCB1cGxvYWQsIG9yIHN1YnRhc2tzIGluaXRpYXRlZCBpblxuICAgIC8vIF9zdGFydFBhcmFsbGVsVXBsb2FkLlxuXG4gICAgdGhpcy5faW5pdGlhbFVwbG9hZCA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFVzZSB0aGUgVGVybWluYXRpb24gZXh0ZW5zaW9uIHRvIGRlbGV0ZSBhbiB1cGxvYWQgZnJvbSB0aGUgc2VydmVyIGJ5IHNlbmRpbmcgYSBERUxFVEVcbiAgICogcmVxdWVzdCB0byB0aGUgc3BlY2lmaWVkIHVwbG9hZCBVUkwuIFRoaXMgaXMgb25seSBwb3NzaWJsZSBpZiB0aGUgc2VydmVyIHN1cHBvcnRzIHRoZVxuICAgKiBUZXJtaW5hdGlvbiBleHRlbnNpb24uIElmIHRoZSBgb3B0aW9ucy5yZXRyeURlbGF5c2AgcHJvcGVydHkgaXMgc2V0LCB0aGUgbWV0aG9kIHdpbGxcbiAgICogYWxzbyByZXRyeSBpZiBhbiBlcnJvciBvY3VycnMuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIHVwbG9hZCdzIFVSTCB3aGljaCB3aWxsIGJlIHRlcm1pbmF0ZWQuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIE9wdGlvbmFsIG9wdGlvbnMgZm9yIGluZmx1ZW5jaW5nIEhUVFAgcmVxdWVzdHMuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFRoZSBQcm9taXNlIHdpbGwgYmUgcmVzb2x2ZWQvcmVqZWN0ZWQgd2hlbiB0aGUgcmVxdWVzdHMgZmluaXNoLlxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhCYXNlVXBsb2FkLCBbe1xuICAgIGtleTogXCJmaW5kUHJldmlvdXNVcGxvYWRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRQcmV2aW91c1VwbG9hZHMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmZpbmdlcnByaW50KHRoaXMuZmlsZSwgdGhpcy5vcHRpb25zKS50aGVuKGZ1bmN0aW9uIChmaW5nZXJwcmludCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuX3VybFN0b3JhZ2UuZmluZFVwbG9hZHNCeUZpbmdlcnByaW50KGZpbmdlcnByaW50KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXN1bWVGcm9tUHJldmlvdXNVcGxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzdW1lRnJvbVByZXZpb3VzVXBsb2FkKHByZXZpb3VzVXBsb2FkKSB7XG4gICAgICB0aGlzLnVybCA9IHByZXZpb3VzVXBsb2FkLnVwbG9hZFVybCB8fCBudWxsO1xuICAgICAgdGhpcy5fcGFyYWxsZWxVcGxvYWRVcmxzID0gcHJldmlvdXNVcGxvYWQucGFyYWxsZWxVcGxvYWRVcmxzIHx8IG51bGw7XG4gICAgICB0aGlzLl91cmxTdG9yYWdlS2V5ID0gcHJldmlvdXNVcGxvYWQudXJsU3RvcmFnZUtleTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGZpbGUgPSB0aGlzLmZpbGU7XG5cbiAgICAgIGlmICghZmlsZSkge1xuICAgICAgICB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCd0dXM6IG5vIGZpbGUgb3Igc3RyZWFtIHRvIHVwbG9hZCBwcm92aWRlZCcpKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmVuZHBvaW50ICYmICF0aGlzLm9wdGlvbnMudXBsb2FkVXJsICYmICF0aGlzLnVybCkge1xuICAgICAgICB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCd0dXM6IG5laXRoZXIgYW4gZW5kcG9pbnQgb3IgYW4gdXBsb2FkIFVSTCBpcyBwcm92aWRlZCcpKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciByZXRyeURlbGF5cyA9IHRoaXMub3B0aW9ucy5yZXRyeURlbGF5cztcblxuICAgICAgaWYgKHJldHJ5RGVsYXlzICE9IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHJldHJ5RGVsYXlzKSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCd0dXM6IHRoZSBgcmV0cnlEZWxheXNgIG9wdGlvbiBtdXN0IGVpdGhlciBiZSBhbiBhcnJheSBvciBudWxsJykpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5wYXJhbGxlbFVwbG9hZHMgPiAxKSB7XG4gICAgICAgIC8vIFRlc3Qgd2hpY2ggb3B0aW9ucyBhcmUgaW5jb21wYXRpYmxlIHdpdGggcGFyYWxsZWwgdXBsb2Fkcy5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYXJyID0gWyd1cGxvYWRVcmwnLCAndXBsb2FkU2l6ZScsICd1cGxvYWRMZW5ndGhEZWZlcnJlZCddOyBfaSA8IF9hcnIubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgdmFyIG9wdGlvbk5hbWUgPSBfYXJyW19pXTtcblxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNbb3B0aW9uTmFtZV0pIHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoXCJ0dXM6IGNhbm5vdCB1c2UgdGhlIFwiLmNvbmNhdChvcHRpb25OYW1lLCBcIiBvcHRpb24gd2hlbiBwYXJhbGxlbFVwbG9hZHMgaXMgZW5hYmxlZFwiKSkpO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RhZ2dlclBlcmNlbnQgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHRoaXMuX2luaXRpYWxVcGxvYWQgJiYgdGhpcy5vcHRpb25zLnBhcmFsbGVsVXBsb2FkcyA8PSAxKSB7XG4gICAgICAgICAgdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcihcInR1czogY2Fubm90IHVzZSB0aGUgc3RhZ2dlclBlcmNlbnQgb3B0aW9uIHdoZW4gcGFyYWxsZWxVcGxvYWRzIGlzIGRpc2FibGVkXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNwbGl0U2l6ZUludG9QYXJ0cyAhPT0gbnVsbCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBhcmFsbGVsVXBsb2FkcyA8PSAxKSB7XG4gICAgICAgICAgdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcihcInR1czogY2Fubm90IHVzZSB0aGUgc3BsaXRTaXplSW50b1BhcnRzIG9wdGlvbiB3aGVuIHBhcmFsbGVsVXBsb2FkcyBpcyBkaXNhYmxlZFwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5vcHRpb25zLmZpbmdlcnByaW50KGZpbGUsIHRoaXMub3B0aW9ucykudGhlbihmdW5jdGlvbiAoZmluZ2VycHJpbnQpIHtcbiAgICAgICAgaWYgKGZpbmdlcnByaW50ID09IG51bGwpIHtcbiAgICAgICAgICAoMCwgX2xvZ2dlci5sb2cpKCdObyBmaW5nZXJwcmludCB3YXMgY2FsY3VsYXRlZCBtZWFuaW5nIHRoYXQgdGhlIHVwbG9hZCBjYW5ub3QgYmUgc3RvcmVkIGluIHRoZSBVUkwgc3RvcmFnZS4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAoMCwgX2xvZ2dlci5sb2cpKFwiQ2FsY3VsYXRlZCBmaW5nZXJwcmludDogXCIuY29uY2F0KGZpbmdlcnByaW50KSk7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczIuX2ZpbmdlcnByaW50ID0gZmluZ2VycHJpbnQ7XG5cbiAgICAgICAgaWYgKF90aGlzMi5fc291cmNlKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5fc291cmNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF90aGlzMi5vcHRpb25zLmZpbGVSZWFkZXIub3BlbkZpbGUoZmlsZSwgX3RoaXMyLm9wdGlvbnMuY2h1bmtTaXplKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICBfdGhpczIuX3NvdXJjZSA9IHNvdXJjZTsgLy8gRmlyc3QsIHdlIGxvb2sgYXQgdGhlIHVwbG9hZExlbmd0aERlZmVycmVkIG9wdGlvbi5cbiAgICAgICAgLy8gTmV4dCwgd2UgY2hlY2sgaWYgdGhlIGNhbGxlciBoYXMgc3VwcGxpZWQgYSBtYW51YWwgdXBsb2FkIHNpemUuXG4gICAgICAgIC8vIEZpbmFsbHksIHdlIHRyeSB0byB1c2UgdGhlIGNhbGN1bGF0ZWQgc2l6ZSBmcm9tIHRoZSBzb3VyY2Ugb2JqZWN0LlxuXG4gICAgICAgIGlmIChfdGhpczIub3B0aW9ucy51cGxvYWRMZW5ndGhEZWZlcnJlZCkge1xuICAgICAgICAgIF90aGlzMi5fc2l6ZSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoX3RoaXMyLm9wdGlvbnMudXBsb2FkU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgICAgX3RoaXMyLl9zaXplID0gTnVtYmVyKF90aGlzMi5vcHRpb25zLnVwbG9hZFNpemUpO1xuXG4gICAgICAgICAgaWYgKE51bWJlci5pc05hTihfdGhpczIuX3NpemUpKSB7XG4gICAgICAgICAgICBfdGhpczIuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ3R1czogY2Fubm90IGNvbnZlcnQgYHVwbG9hZFNpemVgIG9wdGlvbiBpbnRvIGEgbnVtYmVyJykpO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzMi5fc2l6ZSA9IF90aGlzMi5fc291cmNlLnNpemU7XG5cbiAgICAgICAgICBpZiAoX3RoaXMyLl9zaXplID09IG51bGwpIHtcbiAgICAgICAgICAgIF90aGlzMi5fZW1pdEVycm9yKG5ldyBFcnJvcihcInR1czogY2Fubm90IGF1dG9tYXRpY2FsbHkgZGVyaXZlIHVwbG9hZCdzIHNpemUgZnJvbSBpbnB1dC4gU3BlY2lmeSBpdCBtYW51YWxseSB1c2luZyB0aGUgYHVwbG9hZFNpemVgIG9wdGlvbiBvciB1c2UgdGhlIGB1cGxvYWRMZW5ndGhEZWZlcnJlZGAgb3B0aW9uXCIpKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBJZiB0aGUgdXBsb2FkIHdhcyBjb25maWd1cmVkIHRvIHVzZSBtdWx0aXBsZSByZXF1ZXN0cyBvciBpZiB3ZSByZXN1bWUgZnJvbVxuICAgICAgICAvLyBhbiB1cGxvYWQgd2hpY2ggdXNlZCBtdWx0aXBsZSByZXF1ZXN0cywgd2Ugc3RhcnQgYSBwYXJhbGxlbCB1cGxvYWQuXG5cblxuICAgICAgICBpZiAoX3RoaXMyLm9wdGlvbnMucGFyYWxsZWxVcGxvYWRzID4gMSB8fCBfdGhpczIuX3BhcmFsbGVsVXBsb2FkVXJscyAhPSBudWxsKSB7XG4gICAgICAgICAgX3RoaXMyLl9zdGFydFBhcmFsbGVsVXBsb2FkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMyLl9zdGFydFNpbmdsZVVwbG9hZCgpO1xuICAgICAgICB9XG4gICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgX3RoaXMyLl9lbWl0RXJyb3IoZXJyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWF0ZSB0aGUgdXBsb2FkaW5nIHByb2NlZHVyZSBmb3IgYSBwYXJhbGxlbGl6ZWQgdXBsb2FkLCB3aGVyZSBvbmUgZmlsZSBpcyBzcGxpdCBpbnRvXG4gICAgICogbXVsdGlwbGUgcmVxdWVzdCB3aGljaCBhcmUgcnVuIGluIHBhcmFsbGVsLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc3RhcnRQYXJhbGxlbFVwbG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc3RhcnRQYXJhbGxlbFVwbG9hZCgpIHtcbiAgICAgIHZhciBfdGhpcyRvcHRpb25zJHNwbGl0U2ksXG4gICAgICAgICAgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIHRvdGFsU2l6ZSA9IHRoaXMuX3NpemU7XG4gICAgICB2YXIgdG90YWxQcm9ncmVzcyA9IDA7XG4gICAgICB2YXIgX3RoaXMkb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICBjaHVua1NpemUgPSBfdGhpcyRvcHRpb25zLmNodW5rU2l6ZSxcbiAgICAgICAgICBzdGFnZ2VyUGVyY2VudCA9IF90aGlzJG9wdGlvbnMuc3RhZ2dlclBlcmNlbnQ7XG4gICAgICB0aGlzLl9wYXJhbGxlbFVwbG9hZHMgPSBbXTtcbiAgICAgIHZhciBwYXJ0Q291bnQgPSB0aGlzLl9wYXJhbGxlbFVwbG9hZFVybHMgIT0gbnVsbCA/IHRoaXMuX3BhcmFsbGVsVXBsb2FkVXJscy5sZW5ndGggOiB0aGlzLm9wdGlvbnMucGFyYWxsZWxVcGxvYWRzOyAvLyBUaGUgaW5wdXQgZmlsZSB3aWxsIGJlIHNwbGl0IGludG8gbXVsdGlwbGUgc2xpY2VzIHdoaWNoIGFyZSB1cGxvYWRlZCBpbiBzZXBhcmF0ZVxuICAgICAgLy8gcmVxdWVzdHMuIEhlcmUgd2UgZ2VuZXJhdGUgdGhlIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb24gZm9yIHRoZSBzbGljZXMuXG5cbiAgICAgIHZhciBzcGxpdFNpemVGbiA9IChfdGhpcyRvcHRpb25zJHNwbGl0U2kgPSB0aGlzLm9wdGlvbnMuc3BsaXRTaXplSW50b1BhcnRzKSAhPT0gbnVsbCAmJiBfdGhpcyRvcHRpb25zJHNwbGl0U2kgIT09IHZvaWQgMCA/IF90aGlzJG9wdGlvbnMkc3BsaXRTaSA6IHNwbGl0U2l6ZUludG9QYXJ0cztcbiAgICAgIHZhciBwYXJ0cyA9IHNwbGl0U2l6ZUZuKHRoaXMuX3NvdXJjZS5zaXplLCBwYXJ0Q291bnQpOyAvLyBBdHRhY2ggVVJMcyBmcm9tIHByZXZpb3VzIHVwbG9hZHMsIGlmIGF2YWlsYWJsZS5cblxuICAgICAgaWYgKHRoaXMuX3BhcmFsbGVsVXBsb2FkVXJscykge1xuICAgICAgICBwYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0LCBpbmRleCkge1xuICAgICAgICAgIHBhcnQudXBsb2FkVXJsID0gX3RoaXMzLl9wYXJhbGxlbFVwbG9hZFVybHNbaW5kZXhdIHx8IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBDcmVhdGUgYW4gZW1wdHkgbGlzdCBmb3Igc3RvcmluZyB0aGUgdXBsb2FkIFVSTHNcblxuXG4gICAgICB0aGlzLl9wYXJhbGxlbFVwbG9hZFVybHMgPSBuZXcgQXJyYXkocGFydHMubGVuZ3RoKTtcbiAgICAgIHZhciBmaXJzdENodW5rID0gbnVsbDtcbiAgICAgIHZhciBwYXJ0c0NodW5rcyA9IG51bGw7XG5cbiAgICAgIGlmIChzdGFnZ2VyUGVyY2VudCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBHZW5lcmF0ZSBhIHByb21pc2UgZm9yIGVhY2ggY2h1bmsgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdoZW4gdGhlIHJlc3BlY3RpdmVcbiAgICAgICAgLy8gdXBsb2FkIGlzIGNvbXBsZXRlZC5cbiAgICAgICAgdmFyIF9idWlsZENodW5rU3RhZ2dlcnMgPSBidWlsZENodW5rU3RhZ2dlcnModG90YWxTaXplLCBwYXJ0cy5sZW5ndGgsIGNodW5rU2l6ZSk7XG5cbiAgICAgICAgdmFyIF9idWlsZENodW5rU3RhZ2dlcnMyID0gX3NsaWNlZFRvQXJyYXkoX2J1aWxkQ2h1bmtTdGFnZ2VycywgMik7XG5cbiAgICAgICAgcGFydHNDaHVua3MgPSBfYnVpbGRDaHVua1N0YWdnZXJzMlswXTtcbiAgICAgICAgZmlyc3RDaHVuayA9IF9idWlsZENodW5rU3RhZ2dlcnMyWzFdO1xuICAgICAgfVxuXG4gICAgICB2YXIgdXBsb2FkcyA9IHBhcnRzLm1hcChmdW5jdGlvbiAocGFydCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGxhc3RQYXJ0UHJvZ3Jlc3MgPSAwO1xuICAgICAgICByZXR1cm4gX3RoaXMzLl9zb3VyY2Uuc2xpY2UocGFydC5zdGFydCwgcGFydC5lbmQpLnRoZW4oZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBfcmVmLnZhbHVlO1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAvLyBNZXJnZSB3aXRoIHRoZSB1c2VyIHN1cHBsaWVkIG9wdGlvbnMgYnV0IG92ZXJ3cml0ZSBzb21lIHZhbHVlcy5cbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBfdGhpczMub3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgICAgIC8vIElmIGF2YWlsYWJsZSwgdGhlIHBhcnRpYWwgdXBsb2FkIHNob3VsZCBiZSByZXN1bWVkIGZyb20gYSBwcmV2aW91cyBVUkwuXG4gICAgICAgICAgICAgIHVwbG9hZFVybDogcGFydC51cGxvYWRVcmwgfHwgbnVsbCxcbiAgICAgICAgICAgICAgLy8gV2UgdGFrZSBtYW51YWxseSBjYXJlIG9mIHJlc3VtaW5nIGZvciBwYXJ0aWFsIHVwbG9hZHMsIHNvIHRoZXkgc2hvdWxkXG4gICAgICAgICAgICAgIC8vIG5vdCBiZSBzdG9yZWQgaW4gdGhlIFVSTCBzdG9yYWdlLlxuICAgICAgICAgICAgICBzdG9yZUZpbmdlcnByaW50Rm9yUmVzdW1pbmc6IGZhbHNlLFxuICAgICAgICAgICAgICByZW1vdmVGaW5nZXJwcmludE9uU3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBwYXJhbGxlbFVwbG9hZHMgb3B0aW9uIHRvIG5vdCBjYXVzZSByZWN1cnNpb24uXG4gICAgICAgICAgICAgIHBhcmFsbGVsVXBsb2FkczogMSxcbiAgICAgICAgICAgICAgLy8gUmVzZXQgcGFyYWxsZWwgdXBsb2FkIG9wdGlvbnMuIEtlZXAgdGhlIHN0YWdnZXIgb3B0aW9uLlxuICAgICAgICAgICAgICBzcGxpdFNpemVJbnRvUGFydHM6IG51bGwsXG4gICAgICAgICAgICAgIC8vIFJlc2V0IG1ldGFkYXRhLlxuICAgICAgICAgICAgICBtZXRhZGF0YToge30sXG4gICAgICAgICAgICAgIC8vIEFkZCB0aGUgaGVhZGVyIHRvIGluZGljYXRlIHRoZSB0aGlzIGlzIGEgcGFydGlhbCB1cGxvYWQuXG4gICAgICAgICAgICAgIGhlYWRlcnM6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgX3RoaXMzLm9wdGlvbnMuaGVhZGVycyksIHt9LCB7XG4gICAgICAgICAgICAgICAgJ1VwbG9hZC1Db25jYXQnOiAncGFydGlhbCdcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIC8vIFJlamVjdCBvciByZXNvbHZlIHRoZSBwcm9taXNlIGlmIHRoZSB1cGxvYWQgZXJyb3JzIG9yIGNvbXBsZXRlcy5cbiAgICAgICAgICAgICAgb25TdWNjZXNzOiByZXNvbHZlLFxuICAgICAgICAgICAgICBvbkVycm9yOiByZWplY3QsXG4gICAgICAgICAgICAgIC8vIFdhaXQgdW50aWwgZXZlcnkgcGFydGlhbCB1cGxvYWQgaGFzIGFuIHVwbG9hZCBVUkwsIHNvIHdlIGNhbiBhZGRcbiAgICAgICAgICAgICAgLy8gdGhlbSB0byB0aGUgVVJMIHN0b3JhZ2UuXG4gICAgICAgICAgICAgIF9vblVwbG9hZFVybEF2YWlsYWJsZTogZnVuY3Rpb24gX29uVXBsb2FkVXJsQXZhaWxhYmxlKCkge1xuICAgICAgICAgICAgICAgIF90aGlzMy5fcGFyYWxsZWxVcGxvYWRVcmxzW2luZGV4XSA9IHVwbG9hZC51cmw7IC8vIFRlc3QgaWYgYWxsIHVwbG9hZHMgaGF2ZSByZWNlaXZlZCBhbiBVUkxcblxuICAgICAgICAgICAgICAgIGlmIChfdGhpczMuX3BhcmFsbGVsVXBsb2FkVXJscy5maWx0ZXIoZnVuY3Rpb24gKHUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBCb29sZWFuKHUpO1xuICAgICAgICAgICAgICAgIH0pLmxlbmd0aCA9PT0gcGFydHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICBfdGhpczMuX3NhdmVVcGxvYWRJblVybFN0b3JhZ2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgdXBsb2FkID0gbmV3IEJhc2VVcGxvYWQodmFsdWUsIG9wdGlvbnMpOyAvLyBGaW5hbGl6ZSB0aGUgcGFydGlhbCB1cGxvYWQgZmllbGRzLlxuXG4gICAgICAgICAgICB1cGxvYWQub3B0aW9ucy5vblByb2dyZXNzID0gZnVuY3Rpb24gKG5ld1BhcnRQcm9ncmVzcykge1xuICAgICAgICAgICAgICAvLyBCYXNlZCBvbiB0aGUgcHJvZ3Jlc3MgZm9yIHRoaXMgcGFydGlhbCB1cGxvYWQsIGNhbGN1bGF0ZSB0aGUgcHJvZ3Jlc3NcbiAgICAgICAgICAgICAgLy8gZm9yIHRoZSBlbnRpcmUgZmluYWwgdXBsb2FkLlxuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAvLyBOT1RFOiBUaGlzIGlzIGNhbGxlZCBmb3IgZWFjaCBwYXJ0aWFsIHVwbG9hZCBidXQgYF9lbWl0UHJvZ3Jlc3NgXG4gICAgICAgICAgICAgIC8vIGNhbGxzIHRoZSBgb25Qcm9ncmVzc2AgbWV0aG9kIGZvciB0aGUgb3JpZ2luYWwgdXBsb2FkLlxuICAgICAgICAgICAgICB0b3RhbFByb2dyZXNzID0gdG90YWxQcm9ncmVzcyAtIGxhc3RQYXJ0UHJvZ3Jlc3MgKyBuZXdQYXJ0UHJvZ3Jlc3M7XG4gICAgICAgICAgICAgIGxhc3RQYXJ0UHJvZ3Jlc3MgPSBuZXdQYXJ0UHJvZ3Jlc3M7IC8vIFNpZ25hbCB0byB0aGUgaW5pdGlhbCBgQmFzZVVwbG9hZGAgb2JqZWN0LlxuXG4gICAgICAgICAgICAgIF90aGlzMy5fZW1pdFByb2dyZXNzKHRvdGFsUHJvZ3Jlc3MsIHRvdGFsU2l6ZSk7IC8vIElmIGEgY2h1bmsgc3RhZ2dlciBpcyBzZXQsIHNpZ25hbCB0byB0aGUgb3RoZXIgdXBsb2FkIHdoZW4gaXQgY2FuXG4gICAgICAgICAgICAgIC8vIHN0YXJ0IHVwbG9hZGluZy5cblxuXG4gICAgICAgICAgICAgIGlmIChzdGFnZ2VyUGVyY2VudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBzdGFnZ2VyIHVzaW5nIHRoZSBjdXJyZW50IGNodW5rIGFuZCBub3QgdGhlXG4gICAgICAgICAgICAgICAgLy8gY3VycmVudCBwYXJ0IHNpemUuXG4gICAgICAgICAgICAgICAgdmFyIGNodW5rID0gdXBsb2FkLl9jdXJyZW50Q2h1bms7XG4gICAgICAgICAgICAgICAgdmFyIGNodW5rUHJvZ3Jlc3MgPSBuZXdQYXJ0UHJvZ3Jlc3MgLSBjaHVua1NpemUgKiBjaHVuay5pbmRleEluUGFydDtcbiAgICAgICAgICAgICAgICB2YXIgY2h1bmtQZXJjZW50ID0gY2h1bmtQcm9ncmVzcyAvIGNodW5rU2l6ZSAqIDEwMDtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dENodW5rID0gY2h1bmsubmV4dENodW5rU3RhZ2dlcjtcblxuICAgICAgICAgICAgICAgIGlmIChuZXh0Q2h1bmsgIT09IG51bGwgJiYgIW5leHRDaHVuay5yZXNvbHZlZCAmJiBjaHVua1BlcmNlbnQgPj0gc3RhZ2dlclBlcmNlbnQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBuZXh0IHBhcnRpYWwgdXBsb2FkIHRoYXQgc2hvdWxkIHN0YXJ0IHdoZW4gdGhpcyBwYXJ0aWFsIHVwbG9hZFxuICAgICAgICAgICAgICAgICAgLy8gcmVhY2hlcyB0aGUgc3RhZ2dlciBmb3IgYSBjaHVuay5cbiAgICAgICAgICAgICAgICAgIG5leHRDaHVuay5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICBuZXh0Q2h1bmsucmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdXBsb2FkLl9pbml0aWFsVXBsb2FkID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuXG4gICAgICAgICAgICBpZiAoc3RhZ2dlclBlcmNlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdmFyIGN1cnJlbnRDaHVuayA9IHBhcnRzQ2h1bmtzW2luZGV4XVswXTsgLy8gV2FpdCBmb3IgdGhlIGluaXRpYWwgc3RhZ2dlciBmb3IgdGhpcyBjaHVuayBiZWZvcmUgc3RhcnRpbmcgdGhlIHBhcnQuXG5cbiAgICAgICAgICAgICAgcHJvbWlzZSA9IGN1cnJlbnRDaHVuay5wcm9taXNlO1xuICAgICAgICAgICAgICB1cGxvYWQuX2N1cnJlbnRDaHVuayA9IGN1cnJlbnRDaHVuaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVwbG9hZC5zdGFydCgpO1xuICAgICAgICAgICAgfSk7IC8vIFN0b3JlIHRoZSB1cGxvYWRzIGluIGFuIGFycmF5LCBzbyB3ZSBjYW4gbGF0ZXIgYWJvcnQgdGhlbSBpZiBuZWNlc3NhcnkuXG5cbiAgICAgICAgICAgIF90aGlzMy5fcGFyYWxsZWxVcGxvYWRzLnB1c2godXBsb2FkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHN0YWdnZXJQZXJjZW50ICE9PSBudWxsKSB7XG4gICAgICAgIC8vIEtpY2sgb2ZmIHRoZSBmaXJzdCB1cGxvYWQuXG4gICAgICAgIGZpcnN0Q2h1bmsucmVzb2x2ZSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVxOyAvLyBXYWl0IHVudGlsIGFsbCBwYXJ0aWFsIHVwbG9hZHMgYXJlIGZpbmlzaGVkIGFuZCB3ZSBjYW4gc2VuZCB0aGUgUE9TVCByZXF1ZXN0IGZvclxuICAgICAgLy8gY3JlYXRpbmcgdGhlIGZpbmFsIHVwbG9hZC5cblxuICAgICAgUHJvbWlzZS5hbGwodXBsb2FkcykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlcSA9IF90aGlzMy5fb3BlblJlcXVlc3QoJ1BPU1QnLCBfdGhpczMub3B0aW9ucy5lbmRwb2ludCk7XG4gICAgICAgIHJlcS5zZXRIZWFkZXIoJ1VwbG9hZC1Db25jYXQnLCBcImZpbmFsO1wiLmNvbmNhdChfdGhpczMuX3BhcmFsbGVsVXBsb2FkVXJscy5qb2luKCcgJykpKTsgLy8gQWRkIG1ldGFkYXRhIGlmIHZhbHVlcyBoYXZlIGJlZW4gYWRkZWRcblxuICAgICAgICB2YXIgbWV0YWRhdGEgPSBlbmNvZGVNZXRhZGF0YShfdGhpczMub3B0aW9ucy5tZXRhZGF0YSk7XG5cbiAgICAgICAgaWYgKG1ldGFkYXRhICE9PSAnJykge1xuICAgICAgICAgIHJlcS5zZXRIZWFkZXIoJ1VwbG9hZC1NZXRhZGF0YScsIG1ldGFkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfdGhpczMuX3NlbmRSZXF1ZXN0KHJlcSwgbnVsbCk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgaWYgKCFpblN0YXR1c0NhdGVnb3J5KHJlcy5nZXRTdGF0dXMoKSwgMjAwKSkge1xuICAgICAgICAgIF90aGlzMy5fZW1pdEh0dHBFcnJvcihyZXEsIHJlcywgJ3R1czogdW5leHBlY3RlZCByZXNwb25zZSB3aGlsZSBjcmVhdGluZyB1cGxvYWQnKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2NhdGlvbiA9IHJlcy5nZXRIZWFkZXIoJ0xvY2F0aW9uJyk7XG5cbiAgICAgICAgaWYgKGxvY2F0aW9uID09IG51bGwpIHtcbiAgICAgICAgICBfdGhpczMuX2VtaXRIdHRwRXJyb3IocmVxLCByZXMsICd0dXM6IGludmFsaWQgb3IgbWlzc2luZyBMb2NhdGlvbiBoZWFkZXInKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzMy51cmwgPSByZXNvbHZlVXJsKF90aGlzMy5vcHRpb25zLmVuZHBvaW50LCBsb2NhdGlvbik7XG4gICAgICAgICgwLCBfbG9nZ2VyLmxvZykoXCJDcmVhdGVkIHVwbG9hZCBhdCBcIi5jb25jYXQoX3RoaXMzLnVybCkpO1xuXG4gICAgICAgIF90aGlzMy5fZW1pdFN1Y2Nlc3MoKTtcbiAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICBfdGhpczMuX2VtaXRFcnJvcihlcnIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYXRlIHRoZSB1cGxvYWRpbmcgcHJvY2VkdXJlIGZvciBhIG5vbi1wYXJhbGxlbCB1cGxvYWQuIEhlcmUgdGhlIGVudGlyZSBmaWxlIGlzXG4gICAgICogdXBsb2FkZWQgaW4gYSBzZXF1ZW50aWFsIG1hdHRlci5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3N0YXJ0U2luZ2xlVXBsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zdGFydFNpbmdsZVVwbG9hZCgpIHtcbiAgICAgIC8vIFJlc2V0IHRoZSBhYm9ydGVkIGZsYWcgd2hlbiB0aGUgdXBsb2FkIGlzIHN0YXJ0ZWQgb3IgZWxzZSB0aGVcbiAgICAgIC8vIF9wZXJmb3JtVXBsb2FkIHdpbGwgc3RvcCBiZWZvcmUgc2VuZGluZyBhIHJlcXVlc3QgaWYgdGhlIHVwbG9hZCBoYXMgYmVlblxuICAgICAgLy8gYWJvcnRlZCBwcmV2aW91c2x5LlxuICAgICAgdGhpcy5fYWJvcnRlZCA9IGZhbHNlOyAvLyBUaGUgdXBsb2FkIGhhZCBiZWVuIHN0YXJ0ZWQgcHJldmlvdXNseSBhbmQgd2Ugc2hvdWxkIHJldXNlIHRoaXMgVVJMLlxuXG4gICAgICBpZiAodGhpcy51cmwgIT0gbnVsbCkge1xuICAgICAgICAoMCwgX2xvZ2dlci5sb2cpKFwiUmVzdW1pbmcgdXBsb2FkIGZyb20gcHJldmlvdXMgVVJMOiBcIi5jb25jYXQodGhpcy51cmwpKTtcblxuICAgICAgICB0aGlzLl9yZXN1bWVVcGxvYWQoKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIEEgVVJMIGhhcyBtYW51YWxseSBiZWVuIHNwZWNpZmllZCwgc28gd2UgdHJ5IHRvIHJlc3VtZVxuXG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudXBsb2FkVXJsICE9IG51bGwpIHtcbiAgICAgICAgKDAsIF9sb2dnZXIubG9nKShcIlJlc3VtaW5nIHVwbG9hZCBmcm9tIHByb3ZpZGVkIFVSTDogXCIuY29uY2F0KHRoaXMub3B0aW9ucy51cGxvYWRVcmwpKTtcbiAgICAgICAgdGhpcy51cmwgPSB0aGlzLm9wdGlvbnMudXBsb2FkVXJsO1xuXG4gICAgICAgIHRoaXMuX3Jlc3VtZVVwbG9hZCgpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gQW4gdXBsb2FkIGhhcyBub3Qgc3RhcnRlZCBmb3IgdGhlIGZpbGUgeWV0LCBzbyB3ZSBzdGFydCBhIG5ldyBvbmVcblxuXG4gICAgICAoMCwgX2xvZ2dlci5sb2cpKCdDcmVhdGluZyBhIG5ldyB1cGxvYWQnKTtcblxuICAgICAgdGhpcy5fY3JlYXRlVXBsb2FkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFib3J0IGFueSBydW5uaW5nIHJlcXVlc3QgYW5kIHN0b3AgdGhlIGN1cnJlbnQgdXBsb2FkLiBBZnRlciBhYm9ydCBpcyBjYWxsZWQsIG5vIGV2ZW50XG4gICAgICogaGFuZGxlciB3aWxsIGJlIGludm9rZWQgYW55bW9yZS4gWW91IGNhbiB1c2UgdGhlIGBzdGFydGAgbWV0aG9kIHRvIHJlc3VtZSB0aGUgdXBsb2FkXG4gICAgICogYWdhaW4uXG4gICAgICogSWYgYHNob3VsZFRlcm1pbmF0ZWAgaXMgdHJ1ZSwgdGhlIGB0ZXJtaW5hdGVgIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHRvIHJlbW92ZSB0aGVcbiAgICAgKiBjdXJyZW50IHVwbG9hZCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFRlcm1pbmF0ZSBUcnVlIGlmIHRoZSB1cGxvYWQgc2hvdWxkIGJlIGRlbGV0ZWQgZnJvbSB0aGUgc2VydmVyLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRoZSBQcm9taXNlIHdpbGwgYmUgcmVzb2x2ZWQvcmVqZWN0ZWQgd2hlbiB0aGUgcmVxdWVzdHMgZmluaXNoLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWJvcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWJvcnQoc2hvdWxkVGVybWluYXRlKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpczsgLy8gU3RvcCBhbnkgcGFyYWxsZWwgcGFydGlhbCB1cGxvYWRzLCB0aGF0IGhhdmUgYmVlbiBzdGFydGVkIGluIF9zdGFydFBhcmFsbGVsVXBsb2Fkcy5cblxuXG4gICAgICBpZiAodGhpcy5fcGFyYWxsZWxVcGxvYWRzICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5fcGFyYWxsZWxVcGxvYWRzLmZvckVhY2goZnVuY3Rpb24gKHVwbG9hZCkge1xuICAgICAgICAgIHVwbG9hZC5hYm9ydChzaG91bGRUZXJtaW5hdGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gLy8gU3RvcCBhbnkgY3VycmVudCBydW5uaW5nIHJlcXVlc3QuXG5cblxuICAgICAgaWYgKHRoaXMuX3JlcSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9yZXEuYWJvcnQoKTsgLy8gTm90ZTogV2UgZG8gbm90IGNsb3NlIHRoZSBmaWxlIHNvdXJjZSBoZXJlLCBzbyB0aGUgdXNlciBjYW4gcmVzdW1lIGluIHRoZSBmdXR1cmUuXG5cbiAgICAgIH1cblxuICAgICAgdGhpcy5fYWJvcnRlZCA9IHRydWU7IC8vIFN0b3AgYW55IHRpbWVvdXQgdXNlZCBmb3IgaW5pdGlhdGluZyBhIHJldHJ5LlxuXG4gICAgICBpZiAodGhpcy5fcmV0cnlUaW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3JldHJ5VGltZW91dCk7XG4gICAgICAgIHRoaXMuX3JldHJ5VGltZW91dCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICghc2hvdWxkVGVybWluYXRlIHx8IHRoaXMudXJsID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQmFzZVVwbG9hZC50ZXJtaW5hdGUodGhpcy51cmwsIHRoaXMub3B0aW9ucykgLy8gUmVtb3ZlIGVudHJ5IGZyb20gdGhlIFVSTCBzdG9yYWdlIHNpbmNlIHRoZSB1cGxvYWQgVVJMIGlzIG5vIGxvbmdlciB2YWxpZC5cbiAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNC5fcmVtb3ZlRnJvbVVybFN0b3JhZ2UoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZW1pdEh0dHBFcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZW1pdEh0dHBFcnJvcihyZXEsIHJlcywgbWVzc2FnZSwgY2F1c2luZ0Vycikge1xuICAgICAgdGhpcy5fZW1pdEVycm9yKG5ldyBfZXJyb3IuZGVmYXVsdChtZXNzYWdlLCBjYXVzaW5nRXJyLCByZXEsIHJlcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZW1pdEVycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9lbWl0RXJyb3IoZXJyKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpczsgLy8gRG8gbm90IGVtaXQgZXJyb3JzLCBlLmcuIGZyb20gYWJvcnRlZCBIVFRQIHJlcXVlc3RzLCBpZiB0aGUgdXBsb2FkIGhhcyBiZWVuIHN0b3BwZWQuXG5cblxuICAgICAgaWYgKHRoaXMuX2Fib3J0ZWQpIHJldHVybjsgLy8gQ2hlY2sgaWYgd2Ugc2hvdWxkIHJldHJ5LCB3aGVuIGVuYWJsZWQsIGJlZm9yZSBzZW5kaW5nIHRoZSBlcnJvciB0byB0aGUgdXNlci5cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZXRyeURlbGF5cyAhPSBudWxsKSB7XG4gICAgICAgIC8vIFdlIHdpbGwgcmVzZXQgdGhlIGF0dGVtcHQgY291bnRlciBpZlxuICAgICAgICAvLyAtIHdlIHdlcmUgYWxyZWFkeSBhYmxlIHRvIGNvbm5lY3QgdG8gdGhlIHNlcnZlciAob2Zmc2V0ICE9IG51bGwpIGFuZFxuICAgICAgICAvLyAtIHdlIHdlcmUgYWJsZSB0byB1cGxvYWQgYSBzbWFsbCBjaHVuayBvZiBkYXRhIHRvIHRoZSBzZXJ2ZXJcbiAgICAgICAgdmFyIHNob3VsZFJlc2V0RGVsYXlzID0gdGhpcy5fb2Zmc2V0ICE9IG51bGwgJiYgdGhpcy5fb2Zmc2V0ID4gdGhpcy5fb2Zmc2V0QmVmb3JlUmV0cnk7XG5cbiAgICAgICAgaWYgKHNob3VsZFJlc2V0RGVsYXlzKSB7XG4gICAgICAgICAgdGhpcy5fcmV0cnlBdHRlbXB0ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaG91bGRSZXRyeShlcnIsIHRoaXMuX3JldHJ5QXR0ZW1wdCwgdGhpcy5vcHRpb25zKSkge1xuICAgICAgICAgIHZhciBkZWxheSA9IHRoaXMub3B0aW9ucy5yZXRyeURlbGF5c1t0aGlzLl9yZXRyeUF0dGVtcHQrK107XG4gICAgICAgICAgdGhpcy5fb2Zmc2V0QmVmb3JlUmV0cnkgPSB0aGlzLl9vZmZzZXQ7XG4gICAgICAgICAgdGhpcy5fcmV0cnlUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczUuc3RhcnQoKTtcbiAgICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLm9uRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm9uRXJyb3IoZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVibGlzaGVzIG5vdGlmaWNhdGlvbiBpZiB0aGUgdXBsb2FkIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBjb21wbGV0ZWQuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9lbWl0U3VjY2Vzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZW1pdFN1Y2Nlc3MoKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJlbW92ZUZpbmdlcnByaW50T25TdWNjZXNzKSB7XG4gICAgICAgIC8vIFJlbW92ZSBzdG9yZWQgZmluZ2VycHJpbnQgYW5kIGNvcnJlc3BvbmRpbmcgZW5kcG9pbnQuIFRoaXMgY2F1c2VzXG4gICAgICAgIC8vIG5ldyB1cGxvYWRzIG9mIHRoZSBzYW1lIGZpbGUgdG8gYmUgdHJlYXRlZCBhcyBhIGRpZmZlcmVudCBmaWxlLlxuICAgICAgICB0aGlzLl9yZW1vdmVGcm9tVXJsU3RvcmFnZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5vblN1Y2Nlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm9uU3VjY2VzcygpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaXNoZXMgbm90aWZpY2F0aW9uIHdoZW4gZGF0YSBoYXMgYmVlbiBzZW50IHRvIHRoZSBzZXJ2ZXIuIFRoaXNcbiAgICAgKiBkYXRhIG1heSBub3QgaGF2ZSBiZWVuIGFjY2VwdGVkIGJ5IHRoZSBzZXJ2ZXIgeWV0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVzU2VudCAgTnVtYmVyIG9mIGJ5dGVzIHNlbnQgdG8gdGhlIHNlcnZlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYnl0ZXNUb3RhbCBUb3RhbCBudW1iZXIgb2YgYnl0ZXMgdG8gYmUgc2VudCB0byB0aGUgc2VydmVyLlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2VtaXRQcm9ncmVzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZW1pdFByb2dyZXNzKGJ5dGVzU2VudCwgYnl0ZXNUb3RhbCkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMub25Qcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLm9wdGlvbnMub25Qcm9ncmVzcyhieXRlc1NlbnQsIGJ5dGVzVG90YWwpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaXNoZXMgbm90aWZpY2F0aW9uIHdoZW4gYSBjaHVuayBvZiBkYXRhIGhhcyBiZWVuIHNlbnQgdG8gdGhlIHNlcnZlclxuICAgICAqIGFuZCBhY2NlcHRlZCBieSB0aGUgc2VydmVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjaHVua1NpemUgIFNpemUgb2YgdGhlIGNodW5rIHRoYXQgd2FzIGFjY2VwdGVkIGJ5IHRoZSBzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVzQWNjZXB0ZWQgVG90YWwgbnVtYmVyIG9mIGJ5dGVzIHRoYXQgaGF2ZSBiZWVuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY2VwdGVkIGJ5IHRoZSBzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVzVG90YWwgVG90YWwgbnVtYmVyIG9mIGJ5dGVzIHRvIGJlIHNlbnQgdG8gdGhlIHNlcnZlci5cbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9lbWl0Q2h1bmtDb21wbGV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZW1pdENodW5rQ29tcGxldGUoY2h1bmtTaXplLCBieXRlc0FjY2VwdGVkLCBieXRlc1RvdGFsKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5vbkNodW5rQ29tcGxldGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm9uQ2h1bmtDb21wbGV0ZShjaHVua1NpemUsIGJ5dGVzQWNjZXB0ZWQsIGJ5dGVzVG90YWwpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgdXBsb2FkIHVzaW5nIHRoZSBjcmVhdGlvbiBleHRlbnNpb24gYnkgc2VuZGluZyBhIFBPU1RcbiAgICAgKiByZXF1ZXN0IHRvIHRoZSBlbmRwb2ludC4gQWZ0ZXIgc3VjY2Vzc2Z1bCBjcmVhdGlvbiB0aGUgZmlsZSB3aWxsIGJlXG4gICAgICogdXBsb2FkZWRcbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZVVwbG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlVXBsb2FkKCkge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmVuZHBvaW50KSB7XG4gICAgICAgIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ3R1czogdW5hYmxlIHRvIGNyZWF0ZSB1cGxvYWQgYmVjYXVzZSBubyBlbmRwb2ludCBpcyBwcm92aWRlZCcpKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciByZXEgPSB0aGlzLl9vcGVuUmVxdWVzdCgnUE9TVCcsIHRoaXMub3B0aW9ucy5lbmRwb2ludCk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudXBsb2FkTGVuZ3RoRGVmZXJyZWQpIHtcbiAgICAgICAgcmVxLnNldEhlYWRlcignVXBsb2FkLURlZmVyLUxlbmd0aCcsIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxLnNldEhlYWRlcignVXBsb2FkLUxlbmd0aCcsIHRoaXMuX3NpemUpO1xuICAgICAgfSAvLyBBZGQgbWV0YWRhdGEgaWYgdmFsdWVzIGhhdmUgYmVlbiBhZGRlZFxuXG5cbiAgICAgIHZhciBtZXRhZGF0YSA9IGVuY29kZU1ldGFkYXRhKHRoaXMub3B0aW9ucy5tZXRhZGF0YSk7XG5cbiAgICAgIGlmIChtZXRhZGF0YSAhPT0gJycpIHtcbiAgICAgICAgcmVxLnNldEhlYWRlcignVXBsb2FkLU1ldGFkYXRhJywgbWV0YWRhdGEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvbWlzZTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy51cGxvYWREYXRhRHVyaW5nQ3JlYXRpb24gJiYgIXRoaXMub3B0aW9ucy51cGxvYWRMZW5ndGhEZWZlcnJlZCkge1xuICAgICAgICB0aGlzLl9vZmZzZXQgPSAwO1xuICAgICAgICBwcm9taXNlID0gdGhpcy5fYWRkQ2h1bmtUb1JlcXVlc3QocmVxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2UgPSB0aGlzLl9zZW5kUmVxdWVzdChyZXEsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICBpZiAoIWluU3RhdHVzQ2F0ZWdvcnkocmVzLmdldFN0YXR1cygpLCAyMDApKSB7XG4gICAgICAgICAgX3RoaXM2Ll9lbWl0SHR0cEVycm9yKHJlcSwgcmVzLCAndHVzOiB1bmV4cGVjdGVkIHJlc3BvbnNlIHdoaWxlIGNyZWF0aW5nIHVwbG9hZCcpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvY2F0aW9uID0gcmVzLmdldEhlYWRlcignTG9jYXRpb24nKTtcblxuICAgICAgICBpZiAobG9jYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgIF90aGlzNi5fZW1pdEh0dHBFcnJvcihyZXEsIHJlcywgJ3R1czogaW52YWxpZCBvciBtaXNzaW5nIExvY2F0aW9uIGhlYWRlcicpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXM2LnVybCA9IHJlc29sdmVVcmwoX3RoaXM2Lm9wdGlvbnMuZW5kcG9pbnQsIGxvY2F0aW9uKTtcbiAgICAgICAgKDAsIF9sb2dnZXIubG9nKShcIkNyZWF0ZWQgdXBsb2FkIGF0IFwiLmNvbmNhdChfdGhpczYudXJsKSk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBfdGhpczYub3B0aW9ucy5fb25VcGxvYWRVcmxBdmFpbGFibGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBfdGhpczYub3B0aW9ucy5fb25VcGxvYWRVcmxBdmFpbGFibGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfdGhpczYuX3NpemUgPT09IDApIHtcbiAgICAgICAgICAvLyBOb3RoaW5nIHRvIHVwbG9hZCBhbmQgZmlsZSB3YXMgc3VjY2Vzc2Z1bGx5IGNyZWF0ZWRcbiAgICAgICAgICBfdGhpczYuX2VtaXRTdWNjZXNzKCk7XG5cbiAgICAgICAgICBfdGhpczYuX3NvdXJjZS5jbG9zZSgpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXM2Ll9zYXZlVXBsb2FkSW5VcmxTdG9yYWdlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKF90aGlzNi5vcHRpb25zLnVwbG9hZERhdGFEdXJpbmdDcmVhdGlvbikge1xuICAgICAgICAgICAgX3RoaXM2Ll9oYW5kbGVVcGxvYWRSZXNwb25zZShyZXEsIHJlcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzNi5fb2Zmc2V0ID0gMDtcblxuICAgICAgICAgICAgX3RoaXM2Ll9wZXJmb3JtVXBsb2FkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICBfdGhpczYuX2VtaXRIdHRwRXJyb3IocmVxLCBudWxsLCAndHVzOiBmYWlsZWQgdG8gY3JlYXRlIHVwbG9hZCcsIGVycik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLypcbiAgICAgKiBUcnkgdG8gcmVzdW1lIGFuIGV4aXN0aW5nIHVwbG9hZC4gRmlyc3QgYSBIRUFEIHJlcXVlc3Qgd2lsbCBiZSBzZW50XG4gICAgICogdG8gcmV0cmlldmUgdGhlIG9mZnNldC4gSWYgdGhlIHJlcXVlc3QgZmFpbHMgYSBuZXcgdXBsb2FkIHdpbGwgYmVcbiAgICAgKiBjcmVhdGVkLiBJbiB0aGUgY2FzZSBvZiBhIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgdGhlIGZpbGUgd2lsbCBiZSB1cGxvYWRlZC5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3Jlc3VtZVVwbG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzdW1lVXBsb2FkKCkge1xuICAgICAgdmFyIF90aGlzNyA9IHRoaXM7XG5cbiAgICAgIHZhciByZXEgPSB0aGlzLl9vcGVuUmVxdWVzdCgnSEVBRCcsIHRoaXMudXJsKTtcblxuICAgICAgdmFyIHByb21pc2UgPSB0aGlzLl9zZW5kUmVxdWVzdChyZXEsIG51bGwpO1xuXG4gICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICB2YXIgc3RhdHVzID0gcmVzLmdldFN0YXR1cygpO1xuXG4gICAgICAgIGlmICghaW5TdGF0dXNDYXRlZ29yeShzdGF0dXMsIDIwMCkpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgdXBsb2FkIGlzIGxvY2tlZCAoaW5kaWNhdGVkIGJ5IHRoZSA0MjMgTG9ja2VkIHN0YXR1cyBjb2RlKSwgd2VcbiAgICAgICAgICAvLyBlbWl0IGFuIGVycm9yIGluc3RlYWQgb2YgZGlyZWN0bHkgc3RhcnRpbmcgYSBuZXcgdXBsb2FkLiBUaGlzIHdheSB0aGVcbiAgICAgICAgICAvLyByZXRyeSBsb2dpYyBjYW4gY2F0Y2ggdGhlIGVycm9yIGFuZCB3aWxsIHJldHJ5IHRoZSB1cGxvYWQuIEFuIHVwbG9hZFxuICAgICAgICAgIC8vIGlzIHVzdWFsbHkgbG9ja2VkIGZvciBhIHNob3J0IHBlcmlvZCBvZiB0aW1lIGFuZCB3aWxsIGJlIGF2YWlsYWJsZVxuICAgICAgICAgIC8vIGFmdGVyd2FyZHMuXG4gICAgICAgICAgaWYgKHN0YXR1cyA9PT0gNDIzKSB7XG4gICAgICAgICAgICBfdGhpczcuX2VtaXRIdHRwRXJyb3IocmVxLCByZXMsICd0dXM6IHVwbG9hZCBpcyBjdXJyZW50bHkgbG9ja2VkOyByZXRyeSBsYXRlcicpO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGluU3RhdHVzQ2F0ZWdvcnkoc3RhdHVzLCA0MDApKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgc3RvcmVkIGZpbmdlcnByaW50IGFuZCBjb3JyZXNwb25kaW5nIGVuZHBvaW50LFxuICAgICAgICAgICAgLy8gb24gY2xpZW50IGVycm9ycyBzaW5jZSB0aGUgZmlsZSBjYW4gbm90IGJlIGZvdW5kXG4gICAgICAgICAgICBfdGhpczcuX3JlbW92ZUZyb21VcmxTdG9yYWdlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFfdGhpczcub3B0aW9ucy5lbmRwb2ludCkge1xuICAgICAgICAgICAgLy8gRG9uJ3QgYXR0ZW1wdCB0byBjcmVhdGUgYSBuZXcgdXBsb2FkIGlmIG5vIGVuZHBvaW50IGlzIHByb3ZpZGVkLlxuICAgICAgICAgICAgX3RoaXM3Ll9lbWl0SHR0cEVycm9yKHJlcSwgcmVzLCAndHVzOiB1bmFibGUgdG8gcmVzdW1lIHVwbG9hZCAobmV3IHVwbG9hZCBjYW5ub3QgYmUgY3JlYXRlZCB3aXRob3V0IGFuIGVuZHBvaW50KScpO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSAvLyBUcnkgdG8gY3JlYXRlIGEgbmV3IHVwbG9hZFxuXG5cbiAgICAgICAgICBfdGhpczcudXJsID0gbnVsbDtcblxuICAgICAgICAgIF90aGlzNy5fY3JlYXRlVXBsb2FkKCk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb2Zmc2V0ID0gcGFyc2VJbnQocmVzLmdldEhlYWRlcignVXBsb2FkLU9mZnNldCcpLCAxMCk7XG5cbiAgICAgICAgaWYgKE51bWJlci5pc05hTihvZmZzZXQpKSB7XG4gICAgICAgICAgX3RoaXM3Ll9lbWl0SHR0cEVycm9yKHJlcSwgcmVzLCAndHVzOiBpbnZhbGlkIG9yIG1pc3Npbmcgb2Zmc2V0IHZhbHVlJyk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVuZ3RoID0gcGFyc2VJbnQocmVzLmdldEhlYWRlcignVXBsb2FkLUxlbmd0aCcpLCAxMCk7XG5cbiAgICAgICAgaWYgKE51bWJlci5pc05hTihsZW5ndGgpICYmICFfdGhpczcub3B0aW9ucy51cGxvYWRMZW5ndGhEZWZlcnJlZCkge1xuICAgICAgICAgIF90aGlzNy5fZW1pdEh0dHBFcnJvcihyZXEsIHJlcywgJ3R1czogaW52YWxpZCBvciBtaXNzaW5nIGxlbmd0aCB2YWx1ZScpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBfdGhpczcub3B0aW9ucy5fb25VcGxvYWRVcmxBdmFpbGFibGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBfdGhpczcub3B0aW9ucy5fb25VcGxvYWRVcmxBdmFpbGFibGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzNy5fc2F2ZVVwbG9hZEluVXJsU3RvcmFnZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFVwbG9hZCBoYXMgYWxyZWFkeSBiZWVuIGNvbXBsZXRlZCBhbmQgd2UgZG8gbm90IG5lZWQgdG8gc2VuZCBhZGRpdGlvbmFsXG4gICAgICAgICAgLy8gZGF0YSB0byB0aGUgc2VydmVyXG4gICAgICAgICAgaWYgKG9mZnNldCA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICBfdGhpczcuX2VtaXRQcm9ncmVzcyhsZW5ndGgsIGxlbmd0aCk7XG5cbiAgICAgICAgICAgIF90aGlzNy5fZW1pdFN1Y2Nlc3MoKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzNy5fb2Zmc2V0ID0gb2Zmc2V0O1xuXG4gICAgICAgICAgX3RoaXM3Ll9wZXJmb3JtVXBsb2FkKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIF90aGlzNy5fZW1pdEh0dHBFcnJvcihyZXEsIG51bGwsICd0dXM6IGZhaWxlZCB0byByZXN1bWUgdXBsb2FkJywgZXJyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydCB1cGxvYWRpbmcgdGhlIGZpbGUgdXNpbmcgUEFUQ0ggcmVxdWVzdHMuIFRoZSBmaWxlIHdpbGwgYmUgZGl2aWRlZFxuICAgICAqIGludG8gY2h1bmtzIGFzIHNwZWNpZmllZCBpbiB0aGUgY2h1bmtTaXplIG9wdGlvbi4gRHVyaW5nIHRoZSB1cGxvYWRcbiAgICAgKiB0aGUgb25Qcm9ncmVzcyBldmVudCBoYW5kbGVyIG1heSBiZSBpbnZva2VkIG11bHRpcGxlIHRpbWVzLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcGVyZm9ybVVwbG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGVyZm9ybVVwbG9hZCgpIHtcbiAgICAgIHZhciBfdGhpczggPSB0aGlzOyAvLyBJZiB0aGUgdXBsb2FkIGhhcyBiZWVuIGFib3J0ZWQsIHdlIHdpbGwgbm90IHNlbmQgdGhlIG5leHQgUEFUQ0ggcmVxdWVzdC5cbiAgICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IGlmIHRoZSBhYm9ydCBtZXRob2Qgd2FzIGNhbGxlZCBkdXJpbmcgYSBjYWxsYmFjaywgc3VjaFxuICAgICAgLy8gYXMgb25DaHVua0NvbXBsZXRlIG9yIG9uUHJvZ3Jlc3MuXG5cblxuICAgICAgaWYgKHRoaXMuX2Fib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVxOyAvLyBTb21lIGJyb3dzZXIgYW5kIHNlcnZlcnMgbWF5IG5vdCBzdXBwb3J0IHRoZSBQQVRDSCBtZXRob2QuIEZvciB0aG9zZVxuICAgICAgLy8gY2FzZXMsIHlvdSBjYW4gdGVsbCB0dXMtanMtY2xpZW50IHRvIHVzZSBhIFBPU1QgcmVxdWVzdCB3aXRoIHRoZVxuICAgICAgLy8gWC1IVFRQLU1ldGhvZC1PdmVycmlkZSBoZWFkZXIgZm9yIHNpbXVsYXRpbmcgYSBQQVRDSCByZXF1ZXN0LlxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLm92ZXJyaWRlUGF0Y2hNZXRob2QpIHtcbiAgICAgICAgcmVxID0gdGhpcy5fb3BlblJlcXVlc3QoJ1BPU1QnLCB0aGlzLnVybCk7XG4gICAgICAgIHJlcS5zZXRIZWFkZXIoJ1gtSFRUUC1NZXRob2QtT3ZlcnJpZGUnLCAnUEFUQ0gnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcSA9IHRoaXMuX29wZW5SZXF1ZXN0KCdQQVRDSCcsIHRoaXMudXJsKTtcbiAgICAgIH1cblxuICAgICAgcmVxLnNldEhlYWRlcignVXBsb2FkLU9mZnNldCcsIHRoaXMuX29mZnNldCk7XG5cbiAgICAgIHZhciBwcm9taXNlID0gdGhpcy5fYWRkQ2h1bmtUb1JlcXVlc3QocmVxKTtcblxuICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgaWYgKCFpblN0YXR1c0NhdGVnb3J5KHJlcy5nZXRTdGF0dXMoKSwgMjAwKSkge1xuICAgICAgICAgIF90aGlzOC5fZW1pdEh0dHBFcnJvcihyZXEsIHJlcywgJ3R1czogdW5leHBlY3RlZCByZXNwb25zZSB3aGlsZSB1cGxvYWRpbmcgY2h1bmsnKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzOC5faGFuZGxlVXBsb2FkUmVzcG9uc2UocmVxLCByZXMpO1xuICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIC8vIERvbid0IGVtaXQgYW4gZXJyb3IgaWYgdGhlIHVwbG9hZCB3YXMgYWJvcnRlZCBtYW51YWxseVxuICAgICAgICBpZiAoX3RoaXM4Ll9hYm9ydGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXM4Ll9lbWl0SHR0cEVycm9yKHJlcSwgbnVsbCwgXCJ0dXM6IGZhaWxlZCB0byB1cGxvYWQgY2h1bmsgYXQgb2Zmc2V0IFwiLmNvbmNhdChfdGhpczguX29mZnNldCksIGVycik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogX2FkZENodW5rdG9SZXF1ZXN0IHJlYWRzIGEgY2h1bmsgZnJvbSB0aGUgc291cmNlIGFuZCBzZW5kcyBpdCB1c2luZyB0aGVcbiAgICAgKiBzdXBwbGllZCByZXF1ZXN0IG9iamVjdC4gSXQgd2lsbCBub3QgaGFuZGxlIHRoZSByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2FkZENodW5rVG9SZXF1ZXN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRDaHVua1RvUmVxdWVzdChyZXEpIHtcbiAgICAgIHZhciBfdGhpczkgPSB0aGlzO1xuXG4gICAgICB2YXIgc3RhcnQgPSB0aGlzLl9vZmZzZXQ7XG4gICAgICB2YXIgZW5kID0gdGhpcy5fb2Zmc2V0ICsgdGhpcy5vcHRpb25zLmNodW5rU2l6ZTtcbiAgICAgIHJlcS5zZXRQcm9ncmVzc0hhbmRsZXIoZnVuY3Rpb24gKGJ5dGVzU2VudCkge1xuICAgICAgICBfdGhpczkuX2VtaXRQcm9ncmVzcyhzdGFydCArIGJ5dGVzU2VudCwgX3RoaXM5Ll9zaXplKTtcbiAgICAgIH0pO1xuICAgICAgcmVxLnNldEhlYWRlcignQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW0nKTsgLy8gVGhlIHNwZWNpZmllZCBjaHVua1NpemUgbWF5IGJlIEluZmluaXR5IG9yIHRoZSBjYWxjbHVhdGVkIGVuZCBwb3NpdGlvblxuICAgICAgLy8gbWF5IGV4Y2VlZCB0aGUgZmlsZSdzIHNpemUuIEluIGJvdGggY2FzZXMsIHdlIGxpbWl0IHRoZSBlbmQgcG9zaXRpb24gdG9cbiAgICAgIC8vIHRoZSBpbnB1dCdzIHRvdGFsIHNpemUgZm9yIHNpbXBsZXIgY2FsY3VsYXRpb25zIGFuZCBjb3JyZWN0bmVzcy5cblxuICAgICAgaWYgKChlbmQgPT09IEluZmluaXR5IHx8IGVuZCA+IHRoaXMuX3NpemUpICYmICF0aGlzLm9wdGlvbnMudXBsb2FkTGVuZ3RoRGVmZXJyZWQpIHtcbiAgICAgICAgZW5kID0gdGhpcy5fc2l6ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZS5zbGljZShzdGFydCwgZW5kKS50aGVuKGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICB2YXIgdmFsdWUgPSBfcmVmMi52YWx1ZSxcbiAgICAgICAgICAgIGRvbmUgPSBfcmVmMi5kb25lOyAvLyBJZiB0aGUgdXBsb2FkIGxlbmd0aCBpcyBkZWZlcnJlZCwgdGhlIHVwbG9hZCBzaXplIHdhcyBub3Qgc3BlY2lmaWVkIGR1cmluZ1xuICAgICAgICAvLyB1cGxvYWQgY3JlYXRpb24uIFNvLCBpZiB0aGUgZmlsZSByZWFkZXIgaXMgZG9uZSByZWFkaW5nLCB3ZSBrbm93IHRoZSB0b3RhbFxuICAgICAgICAvLyB1cGxvYWQgc2l6ZSBhbmQgY2FuIHRlbGwgdGhlIHR1cyBzZXJ2ZXIuXG5cbiAgICAgICAgaWYgKF90aGlzOS5vcHRpb25zLnVwbG9hZExlbmd0aERlZmVycmVkICYmIGRvbmUpIHtcbiAgICAgICAgICBfdGhpczkuX3NpemUgPSBfdGhpczkuX29mZnNldCArICh2YWx1ZSAmJiB2YWx1ZS5zaXplID8gdmFsdWUuc2l6ZSA6IDApO1xuICAgICAgICAgIHJlcS5zZXRIZWFkZXIoJ1VwbG9hZC1MZW5ndGgnLCBfdGhpczkuX3NpemUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzOS5fc2VuZFJlcXVlc3QocmVxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzOS5fZW1pdFByb2dyZXNzKF90aGlzOS5fb2Zmc2V0LCBfdGhpczkuX3NpemUpO1xuXG4gICAgICAgIHJldHVybiBfdGhpczkuX3NlbmRSZXF1ZXN0KHJlcSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIF9oYW5kbGVVcGxvYWRSZXNwb25zZSBpcyB1c2VkIGJ5IHJlcXVlc3RzIHRoYXQgaGF2ZW4gYmVlbiBzZW50IHVzaW5nIF9hZGRDaHVua1RvUmVxdWVzdFxuICAgICAqIGFuZCBhbHJlYWR5IGhhdmUgcmVjZWl2ZWQgYSByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2hhbmRsZVVwbG9hZFJlc3BvbnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVVcGxvYWRSZXNwb25zZShyZXEsIHJlcykge1xuICAgICAgdmFyIF90aGlzMTAgPSB0aGlzO1xuXG4gICAgICB2YXIgb2Zmc2V0ID0gcGFyc2VJbnQocmVzLmdldEhlYWRlcignVXBsb2FkLU9mZnNldCcpLCAxMCk7XG5cbiAgICAgIGlmIChOdW1iZXIuaXNOYU4ob2Zmc2V0KSkge1xuICAgICAgICB0aGlzLl9lbWl0SHR0cEVycm9yKHJlcSwgcmVzLCAndHVzOiBpbnZhbGlkIG9yIG1pc3Npbmcgb2Zmc2V0IHZhbHVlJyk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9lbWl0UHJvZ3Jlc3Mob2Zmc2V0LCB0aGlzLl9zaXplKTtcblxuICAgICAgdGhpcy5fZW1pdENodW5rQ29tcGxldGUob2Zmc2V0IC0gdGhpcy5fb2Zmc2V0LCBvZmZzZXQsIHRoaXMuX3NpemUpO1xuXG4gICAgICB0aGlzLl9vZmZzZXQgPSBvZmZzZXQ7XG5cbiAgICAgIGlmIChvZmZzZXQgPT09IHRoaXMuX3NpemUpIHtcbiAgICAgICAgLy8gWWF5LCBmaW5hbGx5IGRvbmUgOilcbiAgICAgICAgdGhpcy5fZW1pdFN1Y2Nlc3MoKTtcblxuICAgICAgICB0aGlzLl9zb3VyY2UuY2xvc2UoKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIE5vdCBkb25lIHVwbG9hZGluZyB5ZXQuXG5cblxuICAgICAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGFnZ2VyUGVyY2VudCAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9jdXJyZW50Q2h1bmsgPSB0aGlzLl9jdXJyZW50Q2h1bmsubmV4dENodW5rSW5QYXJ0O1xuXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRDaHVuayAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIElmIHRoZSBzdGFnZ2VyIGlzIHNldCwgd2FpdCBmb3IgdGhlIHN0YWdnZXIgZm9yIHRoZSBjdXJyZW50IGNodW5rLlxuICAgICAgICAgIHByb21pc2UgPSB0aGlzLl9jdXJyZW50Q2h1bmsucHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMxMC5fcGVyZm9ybVVwbG9hZCgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBIVFRQIHJlcXVlc3Qgb2JqZWN0IHdpdGggdGhlIGdpdmVuIG1ldGhvZCBhbmQgVVJMLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfb3BlblJlcXVlc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29wZW5SZXF1ZXN0KG1ldGhvZCwgdXJsKSB7XG4gICAgICB2YXIgcmVxID0gb3BlblJlcXVlc3QobWV0aG9kLCB1cmwsIHRoaXMub3B0aW9ucyk7XG4gICAgICB0aGlzLl9yZXEgPSByZXE7XG4gICAgICByZXR1cm4gcmVxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIGVudHJ5IGluIHRoZSBVUkwgc3RvcmFnZSwgaWYgaXQgaGFzIGJlZW4gc2F2ZWQgYmVmb3JlLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcmVtb3ZlRnJvbVVybFN0b3JhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZUZyb21VcmxTdG9yYWdlKCkge1xuICAgICAgdmFyIF90aGlzMTEgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRoaXMuX3VybFN0b3JhZ2VLZXkpIHJldHVybjtcblxuICAgICAgdGhpcy5fdXJsU3RvcmFnZS5yZW1vdmVVcGxvYWQodGhpcy5fdXJsU3RvcmFnZUtleSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIF90aGlzMTEuX2VtaXRFcnJvcihlcnIpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX3VybFN0b3JhZ2VLZXkgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgdGhlIHVwbG9hZCBVUkwgdG8gdGhlIFVSTCBzdG9yYWdlLCBpZiBwb3NzaWJsZS5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NhdmVVcGxvYWRJblVybFN0b3JhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NhdmVVcGxvYWRJblVybFN0b3JhZ2UoKSB7XG4gICAgICB2YXIgX3RoaXMxMiA9IHRoaXM7IC8vIFdlIGRvIG5vdCBzdG9yZSB0aGUgdXBsb2FkIFVSTFxuICAgICAgLy8gLSBpZiBpdCB3YXMgZGlzYWJsZWQgaW4gdGhlIG9wdGlvbiwgb3JcbiAgICAgIC8vIC0gaWYgbm8gZmluZ2VycHJpbnQgd2FzIGNhbGN1bGF0ZWQgZm9yIHRoZSBpbnB1dCAoaS5lLiBhIHN0cmVhbSksIG9yXG4gICAgICAvLyAtIGlmIHRoZSBVUkwgaXMgYWxyZWFkeSBzdG9yZWQgKGkuZS4ga2V5IGlzIHNldCBhbHJlYWQpLlxuXG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnN0b3JlRmluZ2VycHJpbnRGb3JSZXN1bWluZyB8fCAhdGhpcy5fZmluZ2VycHJpbnQgfHwgdGhpcy5fdXJsU3RvcmFnZUtleSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdG9yZWRVcGxvYWQgPSB7XG4gICAgICAgIHNpemU6IHRoaXMuX3NpemUsXG4gICAgICAgIG1ldGFkYXRhOiB0aGlzLm9wdGlvbnMubWV0YWRhdGEsXG4gICAgICAgIGNyZWF0aW9uVGltZTogbmV3IERhdGUoKS50b1N0cmluZygpXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5fcGFyYWxsZWxVcGxvYWRzKSB7XG4gICAgICAgIC8vIFNhdmUgbXVsdGlwbGUgVVJMcyBpZiB0aGUgcGFyYWxsZWxVcGxvYWRzIG9wdGlvbiBpcyB1c2VkIC4uLlxuICAgICAgICBzdG9yZWRVcGxvYWQucGFyYWxsZWxVcGxvYWRVcmxzID0gdGhpcy5fcGFyYWxsZWxVcGxvYWRVcmxzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gLi4uIG90aGVyd2lzZSB3ZSBqdXN0IHNhdmUgdGhlIG9uZSBhdmFpbGFibGUgVVJMLlxuICAgICAgICBzdG9yZWRVcGxvYWQudXBsb2FkVXJsID0gdGhpcy51cmw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl91cmxTdG9yYWdlLmFkZFVwbG9hZCh0aGlzLl9maW5nZXJwcmludCwgc3RvcmVkVXBsb2FkKS50aGVuKGZ1bmN0aW9uICh1cmxTdG9yYWdlS2V5KSB7XG4gICAgICAgIF90aGlzMTIuX3VybFN0b3JhZ2VLZXkgPSB1cmxTdG9yYWdlS2V5O1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgYSByZXF1ZXN0IHdpdGggdGhlIHByb3ZpZGVkIGJvZHkuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zZW5kUmVxdWVzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2VuZFJlcXVlc3QocmVxKSB7XG4gICAgICB2YXIgYm9keSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgICAgIHJldHVybiBzZW5kUmVxdWVzdChyZXEsIGJvZHksIHRoaXMub3B0aW9ucyk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwidGVybWluYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRlcm1pbmF0ZSh1cmwpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHZhciByZXEgPSBvcGVuUmVxdWVzdCgnREVMRVRFJywgdXJsLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBzZW5kUmVxdWVzdChyZXEsIG51bGwsIG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAvLyBBIDIwNCByZXNwb25zZSBpbmRpY2F0ZXMgYSBzdWNjZXNzZnVsbCByZXF1ZXN0XG4gICAgICAgIGlmIChyZXMuZ2V0U3RhdHVzKCkgPT09IDIwNCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBfZXJyb3IuZGVmYXVsdCgndHVzOiB1bmV4cGVjdGVkIHJlc3BvbnNlIHdoaWxlIHRlcm1pbmF0aW5nIHVwbG9hZCcsIG51bGwsIHJlcSwgcmVzKTtcbiAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoIShlcnIgaW5zdGFuY2VvZiBfZXJyb3IuZGVmYXVsdCkpIHtcbiAgICAgICAgICBlcnIgPSBuZXcgX2Vycm9yLmRlZmF1bHQoJ3R1czogZmFpbGVkIHRvIHRlcm1pbmF0ZSB1cGxvYWQnLCBlcnIsIHJlcSwgbnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNob3VsZFJldHJ5KGVyciwgMCwgb3B0aW9ucykpIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0gLy8gSW5zdGVhZCBvZiBrZWVwaW5nIHRyYWNrIG9mIHRoZSByZXRyeSBhdHRlbXB0cywgd2UgcmVtb3ZlIHRoZSBmaXJzdCBlbGVtZW50IGZyb20gdGhlIGRlbGF5c1xuICAgICAgICAvLyBhcnJheS4gSWYgdGhlIGFycmF5IGlzIGVtcHR5LCBhbGwgcmV0cnkgYXR0ZW1wdHMgYXJlIHVzZWQgdXAgYW5kIHdlIHdpbGwgYnViYmxlIHVwIHRoZSBlcnJvci5cbiAgICAgICAgLy8gV2UgcmVjdXJzaXZlbHkgY2FsbCB0aGUgdGVybWluYXRlIGZ1bmN0aW9uIHdpbGwgcmVtb3ZpbmcgZWxlbWVudHMgZnJvbSB0aGUgcmV0cnlEZWxheXMgYXJyYXkuXG5cblxuICAgICAgICB2YXIgZGVsYXkgPSBvcHRpb25zLnJldHJ5RGVsYXlzWzBdO1xuICAgICAgICB2YXIgcmVtYWluaW5nRGVsYXlzID0gb3B0aW9ucy5yZXRyeURlbGF5cy5zbGljZSgxKTtcblxuICAgICAgICB2YXIgbmV3T3B0aW9ucyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgcmV0cnlEZWxheXM6IHJlbWFpbmluZ0RlbGF5c1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBCYXNlVXBsb2FkLnRlcm1pbmF0ZSh1cmwsIG5ld09wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCYXNlVXBsb2FkO1xufSgpO1xuXG5mdW5jdGlvbiBlbmNvZGVNZXRhZGF0YShtZXRhZGF0YSkge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMobWV0YWRhdGEpLm1hcChmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICB2YXIgX3JlZjQgPSBfc2xpY2VkVG9BcnJheShfcmVmMywgMiksXG4gICAgICAgIGtleSA9IF9yZWY0WzBdLFxuICAgICAgICB2YWx1ZSA9IF9yZWY0WzFdO1xuXG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KGtleSwgXCIgXCIpLmNvbmNhdChfanNCYXNlLkJhc2U2NC5lbmNvZGUoU3RyaW5nKHZhbHVlKSkpO1xuICB9KS5qb2luKCcsJyk7XG59XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgZ2l2ZW4gc3RhdHVzIGlzIGluIHRoZSByYW5nZSBvZiB0aGUgZXhwZWN0ZWQgY2F0ZWdvcnkuXG4gKiBGb3IgZXhhbXBsZSwgb25seSBhIHN0YXR1cyBiZXR3ZWVuIDIwMCBhbmQgMjk5IHdpbGwgc2F0aXNmeSB0aGUgY2F0ZWdvcnkgMjAwLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gaW5TdGF0dXNDYXRlZ29yeShzdGF0dXMsIGNhdGVnb3J5KSB7XG4gIHJldHVybiBzdGF0dXMgPj0gY2F0ZWdvcnkgJiYgc3RhdHVzIDwgY2F0ZWdvcnkgKyAxMDA7XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBIVFRQIHJlcXVlc3Qgd2l0aCB0aGUgc3BlY2lmaWVkIG1ldGhvZCBhbmQgVVJMLlxuICogVGhlIG5lY2Vzc2FyeSBoZWFkZXJzIHRoYXQgYXJlIGluY2x1ZGVkIGluIGV2ZXJ5IHJlcXVlc3RcbiAqIHdpbGwgYmUgYWRkZWQsIGluY2x1ZGluZyB0aGUgcmVxdWVzdCBJRC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIG9wZW5SZXF1ZXN0KG1ldGhvZCwgdXJsLCBvcHRpb25zKSB7XG4gIHZhciByZXEgPSBvcHRpb25zLmh0dHBTdGFjay5jcmVhdGVSZXF1ZXN0KG1ldGhvZCwgdXJsKTtcbiAgcmVxLnNldEhlYWRlcignVHVzLVJlc3VtYWJsZScsICcxLjAuMCcpO1xuICB2YXIgaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyB8fCB7fTtcbiAgT2JqZWN0LmVudHJpZXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjUpIHtcbiAgICB2YXIgX3JlZjYgPSBfc2xpY2VkVG9BcnJheShfcmVmNSwgMiksXG4gICAgICAgIG5hbWUgPSBfcmVmNlswXSxcbiAgICAgICAgdmFsdWUgPSBfcmVmNlsxXTtcblxuICAgIHJlcS5zZXRIZWFkZXIobmFtZSwgdmFsdWUpO1xuICB9KTtcblxuICBpZiAob3B0aW9ucy5hZGRSZXF1ZXN0SWQpIHtcbiAgICB2YXIgcmVxdWVzdElkID0gKDAsIF91dWlkLmRlZmF1bHQpKCk7XG4gICAgcmVxLnNldEhlYWRlcignWC1SZXF1ZXN0LUlEJywgcmVxdWVzdElkKTtcbiAgfVxuXG4gIHJldHVybiByZXE7XG59XG4vKipcbiAqIFNlbmQgYSByZXF1ZXN0IHdpdGggdGhlIHByb3ZpZGVkIGJvZHkgd2hpbGUgaW52b2tpbmcgdGhlIG9uQmVmb3JlUmVxdWVzdFxuICogYW5kIG9uQWZ0ZXJSZXNwb25zZSBjYWxsYmFja3MuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBzZW5kUmVxdWVzdChyZXEsIGJvZHksIG9wdGlvbnMpIHtcbiAgdmFyIG9uQmVmb3JlUmVxdWVzdFByb21pc2UgPSB0eXBlb2Ygb3B0aW9ucy5vbkJlZm9yZVJlcXVlc3QgPT09ICdmdW5jdGlvbicgPyBQcm9taXNlLnJlc29sdmUob3B0aW9ucy5vbkJlZm9yZVJlcXVlc3QocmVxKSkgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgcmV0dXJuIG9uQmVmb3JlUmVxdWVzdFByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJlcS5zZW5kKGJvZHkpLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgdmFyIG9uQWZ0ZXJSZXNwb25zZVByb21pc2UgPSB0eXBlb2Ygb3B0aW9ucy5vbkFmdGVyUmVzcG9uc2UgPT09ICdmdW5jdGlvbicgPyBQcm9taXNlLnJlc29sdmUob3B0aW9ucy5vbkFmdGVyUmVzcG9uc2UocmVxLCByZXMpKSA6IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgcmV0dXJuIG9uQWZ0ZXJSZXNwb25zZVByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBicm93c2VyIHJ1bm5pbmcgdGhpcyBjb2RlIGhhcyBpbnRlcm5ldCBhY2Nlc3MuXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYWx3YXlzIHJldHVybiB0cnVlIGluIHRoZSBub2RlLmpzIGVudmlyb25tZW50XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBpc09ubGluZSgpIHtcbiAgdmFyIG9ubGluZSA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICduYXZpZ2F0b3InIGluIHdpbmRvdyAmJiB3aW5kb3cubmF2aWdhdG9yLm9uTGluZSA9PT0gZmFsc2UpIHtcbiAgICBvbmxpbmUgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBvbmxpbmU7XG59XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCBpdCBpcyBvayB0byByZXRyeSBhIHJlcXVlc3QuXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgdGhlIGVycm9yIHJldHVybmVkIGZyb20gdGhlIGxhc3QgcmVxdWVzdFxuICogQHBhcmFtIHtudW1iZXJ9IHJldHJ5QXR0ZW1wdCB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZSByZXF1ZXN0IGhhcyBhbHJlYWR5IGJlZW4gcmV0cmllZFxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgdHVzIFVwbG9hZCBvcHRpb25zXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBzaG91bGRSZXRyeShlcnIsIHJldHJ5QXR0ZW1wdCwgb3B0aW9ucykge1xuICAvLyBXZSBvbmx5IGF0dGVtcHQgYSByZXRyeSBpZlxuICAvLyAtIHJldHJ5RGVsYXlzIG9wdGlvbiBpcyBzZXRcbiAgLy8gLSB3ZSBkaWRuJ3QgZXhjZWVkIHRoZSBtYXhpdW0gbnVtYmVyIG9mIHJldHJpZXMsIHlldCwgYW5kXG4gIC8vIC0gdGhpcyBlcnJvciB3YXMgY2F1c2VkIGJ5IGEgcmVxdWVzdCBvciBpdCdzIHJlc3BvbnNlIGFuZFxuICAvLyAtIHRoZSBlcnJvciBpcyBzZXJ2ZXIgZXJyb3IgKGkuZS4gbm90IGEgc3RhdHVzIDR4eCBleGNlcHQgYSA0MDkgb3IgNDIzKSBvclxuICAvLyBhIG9uU2hvdWxkUmV0cnkgaXMgc3BlY2lmaWVkIGFuZCByZXR1cm5zIHRydWVcbiAgLy8gLSB0aGUgYnJvd3NlciBkb2VzIG5vdCBpbmRpY2F0ZSB0aGF0IHdlIGFyZSBvZmZsaW5lXG4gIGlmIChvcHRpb25zLnJldHJ5RGVsYXlzID09IG51bGwgfHwgcmV0cnlBdHRlbXB0ID49IG9wdGlvbnMucmV0cnlEZWxheXMubGVuZ3RoIHx8IGVyci5vcmlnaW5hbFJlcXVlc3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm9uU2hvdWxkUmV0cnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5vblNob3VsZFJldHJ5KGVyciwgcmV0cnlBdHRlbXB0LCBvcHRpb25zKTtcbiAgfVxuXG4gIHZhciBzdGF0dXMgPSBlcnIub3JpZ2luYWxSZXNwb25zZSA/IGVyci5vcmlnaW5hbFJlc3BvbnNlLmdldFN0YXR1cygpIDogMDtcbiAgcmV0dXJuICghaW5TdGF0dXNDYXRlZ29yeShzdGF0dXMsIDQwMCkgfHwgc3RhdHVzID09PSA0MDkgfHwgc3RhdHVzID09PSA0MjMpICYmIGlzT25saW5lKCk7XG59XG4vKipcbiAqIFJlc29sdmUgYSByZWxhdGl2ZSBsaW5rIGdpdmVuIHRoZSBvcmlnaW4gYXMgc291cmNlLiBGb3IgZXhhbXBsZSxcbiAqIGlmIGEgSFRUUCByZXF1ZXN0IHRvIGh0dHA6Ly9leGFtcGxlLmNvbS9maWxlcy8gcmV0dXJucyBhIExvY2F0aW9uXG4gKiBoZWFkZXIgd2l0aCB0aGUgdmFsdWUgL3VwbG9hZC9hYmMsIHRoZSByZXNvbHZlZCBVUkwgd2lsbCBiZTpcbiAqIGh0dHA6Ly9leGFtcGxlLmNvbS91cGxvYWQvYWJjXG4gKi9cblxuXG5mdW5jdGlvbiByZXNvbHZlVXJsKG9yaWdpbiwgbGluaykge1xuICByZXR1cm4gbmV3IF91cmxQYXJzZS5kZWZhdWx0KGxpbmssIG9yaWdpbikudG9TdHJpbmcoKTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBzdGFydCBhbmQgZW5kIHBvc2l0aW9ucyBmb3IgdGhlIHBhcnRzIGlmIGFuIHVwbG9hZFxuICogaXMgc3BsaXQgaW50byBtdWx0aXBsZSBwYXJhbGxlbCByZXF1ZXN0cy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdG90YWxTaXplIFRoZSBieXRlIHNpemUgb2YgdGhlIHVwbG9hZCwgd2hpY2ggd2lsbCBiZSBzcGxpdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXJ0Q291bnQgVGhlIG51bWJlciBpbiBob3cgbWFueSBwYXJ0cyB0aGUgdXBsb2FkIHdpbGwgYmUgc3BsaXQuXG4gKiBAcmV0dXJuIHtvYmplY3RbXX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gc3BsaXRTaXplSW50b1BhcnRzKHRvdGFsU2l6ZSwgcGFydENvdW50KSB7XG4gIHZhciBwYXJ0U2l6ZSA9IE1hdGguZmxvb3IodG90YWxTaXplIC8gcGFydENvdW50KTtcbiAgdmFyIHBhcnRzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0Q291bnQ7IGkrKykge1xuICAgIHBhcnRzLnB1c2goe1xuICAgICAgc3RhcnQ6IHBhcnRTaXplICogaSxcbiAgICAgIGVuZDogcGFydFNpemUgKiAoaSArIDEpXG4gICAgfSk7XG4gIH1cblxuICBwYXJ0c1twYXJ0Q291bnQgLSAxXS5lbmQgPSB0b3RhbFNpemU7XG4gIHJldHVybiBwYXJ0cztcbn1cbi8qKlxuICogQnVpbGQgdGhlIGNodW5rIHN0YWdnZXJzLlxuICpcbiAqIE5PVEU6IFRoZSBjb2RlIHRoYXQgYnVpbGRzIHBhcnRzIG11c3QgYmUga2VwdCBpbiBzeW5jIHdpdGhcbiAqIGBzcGxpdFNpemVJbnRvQ2h1bmtBbGlnbmVkUGFydHNgIGluIHNreW5ldC1qcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGJ1aWxkQ2h1bmtTdGFnZ2Vycyh0b3RhbFNpemUsIHBhcnRDb3VudCwgY2h1bmtTaXplKSB7XG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgYSBuZXcgY2h1bmsgaW4gcGFydHNDaHVua3MgYXQgdGhlIGdpdmVuIHBhcnQuXG4gIGZ1bmN0aW9uIG5ld0NodW5rKHBhcnRzQ2h1bmtzLCBwYXJ0SW5kZXgpIHtcbiAgICB2YXIgY2h1bmtzRm9yUGFydCA9IHBhcnRzQ2h1bmtzW3BhcnRJbmRleF07XG4gICAgdmFyIGNodW5rUmVzb2x2ZTtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBjaHVua1Jlc29sdmUgPSByZXNvbHZlO1xuICAgIH0pO1xuICAgIHZhciBjaHVuayA9IHtcbiAgICAgIHByb21pc2U6IHByb21pc2UsXG4gICAgICByZXNvbHZlOiBjaHVua1Jlc29sdmUsXG4gICAgICByZXNvbHZlZDogZmFsc2UsXG4gICAgICBuZXh0Q2h1bmtTdGFnZ2VyOiBudWxsLFxuICAgICAgbmV4dENodW5rSW5QYXJ0OiBudWxsLFxuICAgICAgaW5kZXhJblBhcnQ6IGNodW5rc0ZvclBhcnQubGVuZ3RoXG4gICAgfTsgLy8gUHJldmlvdXMgY2h1bmsgaW4gcGFydCBzaG91bGQgcG9pbnQgdG8gdGhpcyBjaHVuay5cblxuICAgIGlmIChjaHVua3NGb3JQYXJ0Lmxlbmd0aCA+IDApIHtcbiAgICAgIGNodW5rc0ZvclBhcnRbY2h1bmtzRm9yUGFydC5sZW5ndGggLSAxXS5uZXh0Q2h1bmtJblBhcnQgPSBjaHVuaztcbiAgICB9IC8vIFB1c2ggY2h1bmsgdG8gcGFydC5cblxuXG4gICAgY2h1bmtzRm9yUGFydC5wdXNoKGNodW5rKTtcbiAgfSAvLyBWYWxpZGF0aW9uLlxuXG5cbiAgaWYgKHBhcnRDb3VudCA8IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBvcHRpb24gJ3BhcnRDb3VudCcgdG8gYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEsIHdhcyB0eXBlICdudW1iZXInLCB2YWx1ZSAnXCIuY29uY2F0KHBhcnRDb3VudCwgXCInXCIpKTtcbiAgfVxuXG4gIGlmIChjaHVua1NpemUgPCAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgb3B0aW9uICdjaHVua1NpemUnIHRvIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxLCB3YXMgdHlwZSAnbnVtYmVyJywgdmFsdWUgJ1wiLmNvbmNhdChjaHVua1NpemUsIFwiJ1wiKSk7XG4gIH0gLy8gTk9URTogVW5leHBlY3RlZCBjb2RlIGZsb3cuIGB1cGxvYWRMYXJnZUZpbGVSZXF1ZXN0YCBpbiBza3luZXQtanMgc2hvdWxkXG4gIC8vIG5vdCBlbmFibGUgcGFyYWxsZWwgdXBsb2FkcyBmb3IgdGhpcyBjYXNlLlxuXG5cbiAgaWYgKHRvdGFsU2l6ZSA8PSBjaHVua1NpemUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBwYXJhbWV0ZXIgJ3RvdGFsU2l6ZScgdG8gYmUgZ3JlYXRlciB0aGFuIHRoZSBzaXplIG9mIGEgY2h1bmsgKCdcIi5jb25jYXQoY2h1bmtTaXplLCBcIicpLCB3YXMgdHlwZSAnbnVtYmVyJywgdmFsdWUgJ1wiKS5jb25jYXQodG90YWxTaXplLCBcIidcIikpO1xuICB9IC8vIFRoZSBsaXN0cyBvZiBjaHVua3MgZm9yIGVhY2ggcGFydC4gSW5pdGlhbGl6ZSBhbGwgdG8gZW1wdHkgYXJyYXlzLlxuXG5cbiAgdmFyIHBhcnRzQ2h1bmtzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0Q291bnQ7IGkrKykge1xuICAgIHBhcnRzQ2h1bmtzLnB1c2goW10pO1xuICB9IC8vIEFzc2lnbiBjaHVua3MgdG8gcGFydHMgaW4gb3JkZXIsIGxvb3BpbmcgYmFjayB0byB0aGUgYmVnaW5uaW5nIGlmIHdlIGdldCB0b1xuICAvLyB0aGUgZW5kIG9mIHRoZSBwYXJ0cyBhcnJheS5cblxuXG4gIHZhciBudW1GdWxsQ2h1bmtzID0gTWF0aC5mbG9vcih0b3RhbFNpemUgLyBjaHVua1NpemUpO1xuXG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG51bUZ1bGxDaHVua3M7IF9pMisrKSB7XG4gICAgbmV3Q2h1bmsocGFydHNDaHVua3MsIF9pMiAlIHBhcnRDb3VudCk7XG4gIH0gLy8gV2hldGhlciB0aGVyZSBpcyBhbnkgbGVmdG92ZXIgdGhhdCBoYXMgdG8gZ28gaW4gdGhlIGxhc3QgcGFydC5cblxuXG4gIHZhciBoYXNMZWZ0b3ZlciA9IHRvdGFsU2l6ZSAlIGNodW5rU2l6ZSA+IDA7IC8vIElmIHRoZXJlIGlzIG5vbi1jaHVuay1hbGlnbmVkIGxlZnRvdmVyLCBhZGQgYSBjaHVuayBmb3IgaXQuXG5cbiAgaWYgKGhhc0xlZnRvdmVyKSB7XG4gICAgLy8gQXNzaWduIHRoZSBsZWZ0b3ZlciB0byB0aGUgcGFydCBhZnRlciB0aGUgbGFzdCBwYXJ0IHRoYXQgd2FzIHZpc2l0ZWQsIG9yXG4gICAgLy8gdGhlIGxhc3QgcGFydCBpbiB0aGUgYXJyYXkgaWYgYWxsIHBhcnRzIHdlcmUgdXNlZC5cbiAgICAvL1xuICAgIC8vIE5PVEU6IFdlIGRvbid0IG5lZWQgdG8gd29ycnkgYWJvdXQgZW1wdHkgcGFydHMsIHR1cyBpZ25vcmVzIHRob3NlLlxuICAgIHZhciBsYXN0SW5kZXggPSBNYXRoLm1pbihudW1GdWxsQ2h1bmtzLCBwYXJ0Q291bnQgLSAxKTtcbiAgICBuZXdDaHVuayhwYXJ0c0NodW5rcywgbGFzdEluZGV4KTtcbiAgfSAvLyBOb3cgYXNzaWduIHRoZSBzdGFnZ2VyIG9yZGVyLiBXZSBzdGFydCBhdCB0aGUgcGFydCB3aXRoIHRoZSBtb3N0IGNodW5rcywgc29cbiAgLy8gd2UgZG9uJ3QgZW5kIHVwIHdpdGggYW55IGZpbmFsIHBhdXNlcy5cbiAgLy9cbiAgLy8gTk9URTogVGhlIGZpcnN0IGxvbmdlc3QgcGFydCBpcyBlaXRoZXIgdGhlIGZpcnN0IHBhcnQgb3IgdGhlIGxhc3QuIFRoZSBsYXR0ZXJcbiAgLy8gY2FuIGhhcHBlbi4gd2hlbiBhbGwgcGFydHMgaGF2ZSBvbmUgY2h1bmsgYW5kIHRoZSBsYXN0IHBhcnQgZ2V0cyB0aGUgZXh0cmFcbiAgLy8gbGVmdG92ZXIuIFdlIGV4cGxpY2l0bHkgY2hlY2sgYWxsIHBhcnRzIGp1c3QgdG8gYmUgZGVmZW5zaXZlL2Z1dHVyZXByb29mXG4gIC8vIGFnYWluc3Qgb3VyIGFzc3VtcHRpb25zLlxuXG5cbiAgdmFyIGxvbmdlc3RQYXJ0SW5kZXggPSAwO1xuICB2YXIgbG9uZ2VzdFBhcnRMZW5ndGggPSBwYXJ0c0NodW5rc1swXS5sZW5ndGg7XG5cbiAgZm9yICh2YXIgX2kzID0gMTsgX2kzIDwgcGFydHNDaHVua3MubGVuZ3RoOyBfaTMrKykge1xuICAgIGlmIChwYXJ0c0NodW5rc1tfaTNdLmxlbmd0aCA+IGxvbmdlc3RQYXJ0TGVuZ3RoKSB7XG4gICAgICBsb25nZXN0UGFydEluZGV4ID0gX2kzO1xuICAgICAgbG9uZ2VzdFBhcnRMZW5ndGggPSBwYXJ0c0NodW5rc1tfaTNdLmxlbmd0aDtcbiAgICB9XG4gIH0gLy8gR2V0IHRoZSBjaHVuayBhdCB3aGljaCB0byBzdGFydCB1cGxvYWRpbmcuXG5cblxuICB2YXIgZmlyc3RDaHVuayA9IHBhcnRzQ2h1bmtzW2xvbmdlc3RQYXJ0SW5kZXhdWzBdOyAvLyBCdWlsZCB0aGUgc3RhZ2dlciBzZXF1ZW5jZS5cblxuICB2YXIgbGFzdENodW5rID0gbnVsbDsgLy8gTG9vcCBvdmVyIHRoZSBjaHVuayBpbmRpY2VzIGZvciB0aGUgbG9uZ2VzdCBwYXJ0LlxuXG4gIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IGxvbmdlc3RQYXJ0TGVuZ3RoOyBfaTQrKykge1xuICAgIC8vIExvb3Agb3ZlciB0aGUgcGFydHMsIHN0YXJ0aW5nIGZyb20gdGhlIGxvbmdlc3QuIFRoaXMga2VlcHMgYSBzdGFnZ2VyXG4gICAgLy8gYmV0d2VlbiBjaHVua3MgYW5kIHByZXZlbnRzIHBhdXNlcy4gV2Ugcm9sbCBvdmVyIHRvIHRoZSBmaXJzdCBwYXJ0XG4gICAgLy8gaWYgd2UgbmVlZCB0by5cbiAgICBmb3IgKHZhciBqID0gbG9uZ2VzdFBhcnRJbmRleDsgaiA8IGxvbmdlc3RQYXJ0SW5kZXggKyBwYXJ0Q291bnQ7IGorKykge1xuICAgICAgLy8gUm9sbCBvdmVyIHRvIHRoZSBmaXJzdCBwYXJ0IGlmIHdlIG5lZWQgdG8gd2l0aCB0aGUgbW9kdWxvLlxuICAgICAgdmFyIGluZGV4ID0gaiAlIHBhcnRDb3VudDtcblxuICAgICAgaWYgKHBhcnRzQ2h1bmtzW2luZGV4XS5sZW5ndGggPiBfaTQpIHtcbiAgICAgICAgdmFyIGNodW5rID0gcGFydHNDaHVua3NbaW5kZXhdW19pNF07IC8vIExhc3QgY2h1bmsgaW4gc3RhZ2dlciBvcmRlciBzaG91bGQgcG9pbnQgdG8gdGhpcyBvbmUuXG5cbiAgICAgICAgaWYgKGxhc3RDaHVuayAhPT0gbnVsbCkge1xuICAgICAgICAgIGxhc3RDaHVuay5uZXh0Q2h1bmtTdGFnZ2VyID0gY2h1bms7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0Q2h1bmsgPSBjaHVuaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gW3BhcnRzQ2h1bmtzLCBmaXJzdENodW5rXTtcbn1cblxuQmFzZVVwbG9hZC5kZWZhdWx0T3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xudmFyIF9kZWZhdWx0ID0gQmFzZVVwbG9hZDtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdXVpZDtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIFVVSUQgdjQgYmFzZWQgb24gcmFuZG9tIG51bWJlcnMuIFdlIGludGVudGlvYW5sbHkgdXNlIHRoZSBsZXNzXG4gKiBzZWN1cmUgTWF0aC5yYW5kb20gZnVuY3Rpb24gaGVyZSBzaW5jZSB0aGUgbW9yZSBzZWN1cmUgY3J5cHRvLmdldFJhbmRvbU51bWJlcnNcbiAqIGlzIG5vdCBhdmFpbGFibGUgb24gYWxsIHBsYXRmb3Jtcy5cbiAqIFRoaXMgaXMgbm90IGEgcHJvYmxlbSBmb3IgdXMgc2luY2Ugd2UgdXNlIHRoZSBVVUlEIG9ubHkgZm9yIGdlbmVyYXRpbmcgYVxuICogcmVxdWVzdCBJRCwgc28gd2UgY2FuIGNvcnJlbGF0ZSBzZXJ2ZXIgbG9ncyB0byBjbGllbnQgZXJyb3JzLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdGFrZW4gZnJvbSBmb2xsb3dpbmcgc2l0ZTpcbiAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwNTAzNC9jcmVhdGUtZ3VpZC11dWlkLWluLWphdmFzY3JpcHRcbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBnZW5lcmF0ZSBVVUlEXG4gKi9cbmZ1bmN0aW9uIHV1aWQoKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cbiAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24gKGMpIHtcbiAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDA7XG4gICAgdmFyIHYgPSBjID09PSAneCcgPyByIDogciAmIDB4MyB8IDB4ODtcbiAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gIH0pO1xufSIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvYXhpb3MnKTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBzZXR0bGUgPSByZXF1aXJlKCcuLy4uL2NvcmUvc2V0dGxlJyk7XG52YXIgY29va2llcyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9jb29raWVzJyk7XG52YXIgYnVpbGRVUkwgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvYnVpbGRVUkwnKTtcbnZhciBidWlsZEZ1bGxQYXRoID0gcmVxdWlyZSgnLi4vY29yZS9idWlsZEZ1bGxQYXRoJyk7XG52YXIgcGFyc2VIZWFkZXJzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL3BhcnNlSGVhZGVycycpO1xudmFyIGlzVVJMU2FtZU9yaWdpbiA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9pc1VSTFNhbWVPcmlnaW4nKTtcbnZhciB0cmFuc2l0aW9uYWxEZWZhdWx0cyA9IHJlcXVpcmUoJy4uL2RlZmF1bHRzL3RyYW5zaXRpb25hbCcpO1xudmFyIEF4aW9zRXJyb3IgPSByZXF1aXJlKCcuLi9jb3JlL0F4aW9zRXJyb3InKTtcbnZhciBDYW5jZWxlZEVycm9yID0gcmVxdWlyZSgnLi4vY2FuY2VsL0NhbmNlbGVkRXJyb3InKTtcbnZhciBwYXJzZVByb3RvY29sID0gcmVxdWlyZSgnLi4vaGVscGVycy9wYXJzZVByb3RvY29sJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24geGhyQWRhcHRlcihjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIGRpc3BhdGNoWGhyUmVxdWVzdChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVxdWVzdERhdGEgPSBjb25maWcuZGF0YTtcbiAgICB2YXIgcmVxdWVzdEhlYWRlcnMgPSBjb25maWcuaGVhZGVycztcbiAgICB2YXIgcmVzcG9uc2VUeXBlID0gY29uZmlnLnJlc3BvbnNlVHlwZTtcbiAgICB2YXIgb25DYW5jZWxlZDtcbiAgICBmdW5jdGlvbiBkb25lKCkge1xuICAgICAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgICAgICBjb25maWcuY2FuY2VsVG9rZW4udW5zdWJzY3JpYmUob25DYW5jZWxlZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb25maWcuc2lnbmFsKSB7XG4gICAgICAgIGNvbmZpZy5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBvbkNhbmNlbGVkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShyZXF1ZXN0RGF0YSkgJiYgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSkge1xuICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXTsgLy8gTGV0IHRoZSBicm93c2VyIHNldCBpdFxuICAgIH1cblxuICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAvLyBIVFRQIGJhc2ljIGF1dGhlbnRpY2F0aW9uXG4gICAgaWYgKGNvbmZpZy5hdXRoKSB7XG4gICAgICB2YXIgdXNlcm5hbWUgPSBjb25maWcuYXV0aC51c2VybmFtZSB8fCAnJztcbiAgICAgIHZhciBwYXNzd29yZCA9IGNvbmZpZy5hdXRoLnBhc3N3b3JkID8gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGNvbmZpZy5hdXRoLnBhc3N3b3JkKSkgOiAnJztcbiAgICAgIHJlcXVlc3RIZWFkZXJzLkF1dGhvcml6YXRpb24gPSAnQmFzaWMgJyArIGJ0b2EodXNlcm5hbWUgKyAnOicgKyBwYXNzd29yZCk7XG4gICAgfVxuXG4gICAgdmFyIGZ1bGxQYXRoID0gYnVpbGRGdWxsUGF0aChjb25maWcuYmFzZVVSTCwgY29uZmlnLnVybCk7XG5cbiAgICByZXF1ZXN0Lm9wZW4oY29uZmlnLm1ldGhvZC50b1VwcGVyQ2FzZSgpLCBidWlsZFVSTChmdWxsUGF0aCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpLCB0cnVlKTtcblxuICAgIC8vIFNldCB0aGUgcmVxdWVzdCB0aW1lb3V0IGluIE1TXG4gICAgcmVxdWVzdC50aW1lb3V0ID0gY29uZmlnLnRpbWVvdXQ7XG5cbiAgICBmdW5jdGlvbiBvbmxvYWRlbmQoKSB7XG4gICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gUHJlcGFyZSB0aGUgcmVzcG9uc2VcbiAgICAgIHZhciByZXNwb25zZUhlYWRlcnMgPSAnZ2V0QWxsUmVzcG9uc2VIZWFkZXJzJyBpbiByZXF1ZXN0ID8gcGFyc2VIZWFkZXJzKHJlcXVlc3QuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpIDogbnVsbDtcbiAgICAgIHZhciByZXNwb25zZURhdGEgPSAhcmVzcG9uc2VUeXBlIHx8IHJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnIHx8ICByZXNwb25zZVR5cGUgPT09ICdqc29uJyA/XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUZXh0IDogcmVxdWVzdC5yZXNwb25zZTtcbiAgICAgIHZhciByZXNwb25zZSA9IHtcbiAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxuICAgICAgICBzdGF0dXM6IHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXF1ZXN0LnN0YXR1c1RleHQsXG4gICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3RcbiAgICAgIH07XG5cbiAgICAgIHNldHRsZShmdW5jdGlvbiBfcmVzb2x2ZSh2YWx1ZSkge1xuICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSwgZnVuY3Rpb24gX3JlamVjdChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0sIHJlc3BvbnNlKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCdvbmxvYWRlbmQnIGluIHJlcXVlc3QpIHtcbiAgICAgIC8vIFVzZSBvbmxvYWRlbmQgaWYgYXZhaWxhYmxlXG4gICAgICByZXF1ZXN0Lm9ubG9hZGVuZCA9IG9ubG9hZGVuZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTGlzdGVuIGZvciByZWFkeSBzdGF0ZSB0byBlbXVsYXRlIG9ubG9hZGVuZFxuICAgICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVMb2FkKCkge1xuICAgICAgICBpZiAoIXJlcXVlc3QgfHwgcmVxdWVzdC5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIHJlcXVlc3QgZXJyb3JlZCBvdXQgYW5kIHdlIGRpZG4ndCBnZXQgYSByZXNwb25zZSwgdGhpcyB3aWxsIGJlXG4gICAgICAgIC8vIGhhbmRsZWQgYnkgb25lcnJvciBpbnN0ZWFkXG4gICAgICAgIC8vIFdpdGggb25lIGV4Y2VwdGlvbjogcmVxdWVzdCB0aGF0IHVzaW5nIGZpbGU6IHByb3RvY29sLCBtb3N0IGJyb3dzZXJzXG4gICAgICAgIC8vIHdpbGwgcmV0dXJuIHN0YXR1cyBhcyAwIGV2ZW4gdGhvdWdoIGl0J3MgYSBzdWNjZXNzZnVsIHJlcXVlc3RcbiAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAwICYmICEocmVxdWVzdC5yZXNwb25zZVVSTCAmJiByZXF1ZXN0LnJlc3BvbnNlVVJMLmluZGV4T2YoJ2ZpbGU6JykgPT09IDApKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlYWR5c3RhdGUgaGFuZGxlciBpcyBjYWxsaW5nIGJlZm9yZSBvbmVycm9yIG9yIG9udGltZW91dCBoYW5kbGVycyxcbiAgICAgICAgLy8gc28gd2Ugc2hvdWxkIGNhbGwgb25sb2FkZW5kIG9uIHRoZSBuZXh0ICd0aWNrJ1xuICAgICAgICBzZXRUaW1lb3V0KG9ubG9hZGVuZCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBicm93c2VyIHJlcXVlc3QgY2FuY2VsbGF0aW9uIChhcyBvcHBvc2VkIHRvIGEgbWFudWFsIGNhbmNlbGxhdGlvbilcbiAgICByZXF1ZXN0Lm9uYWJvcnQgPSBmdW5jdGlvbiBoYW5kbGVBYm9ydCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlamVjdChuZXcgQXhpb3NFcnJvcignUmVxdWVzdCBhYm9ydGVkJywgQXhpb3NFcnJvci5FQ09OTkFCT1JURUQsIGNvbmZpZywgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIGxvdyBsZXZlbCBuZXR3b3JrIGVycm9yc1xuICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIGhhbmRsZUVycm9yKCkge1xuICAgICAgLy8gUmVhbCBlcnJvcnMgYXJlIGhpZGRlbiBmcm9tIHVzIGJ5IHRoZSBicm93c2VyXG4gICAgICAvLyBvbmVycm9yIHNob3VsZCBvbmx5IGZpcmUgaWYgaXQncyBhIG5ldHdvcmsgZXJyb3JcbiAgICAgIHJlamVjdChuZXcgQXhpb3NFcnJvcignTmV0d29yayBFcnJvcicsIEF4aW9zRXJyb3IuRVJSX05FVFdPUkssIGNvbmZpZywgcmVxdWVzdCwgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIHRpbWVvdXRcbiAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7XG4gICAgICB2YXIgdGltZW91dEVycm9yTWVzc2FnZSA9IGNvbmZpZy50aW1lb3V0ID8gJ3RpbWVvdXQgb2YgJyArIGNvbmZpZy50aW1lb3V0ICsgJ21zIGV4Y2VlZGVkJyA6ICd0aW1lb3V0IGV4Y2VlZGVkJztcbiAgICAgIHZhciB0cmFuc2l0aW9uYWwgPSBjb25maWcudHJhbnNpdGlvbmFsIHx8IHRyYW5zaXRpb25hbERlZmF1bHRzO1xuICAgICAgaWYgKGNvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIHRpbWVvdXRFcnJvck1lc3NhZ2UgPSBjb25maWcudGltZW91dEVycm9yTWVzc2FnZTtcbiAgICAgIH1cbiAgICAgIHJlamVjdChuZXcgQXhpb3NFcnJvcihcbiAgICAgICAgdGltZW91dEVycm9yTWVzc2FnZSxcbiAgICAgICAgdHJhbnNpdGlvbmFsLmNsYXJpZnlUaW1lb3V0RXJyb3IgPyBBeGlvc0Vycm9yLkVUSU1FRE9VVCA6IEF4aW9zRXJyb3IuRUNPTk5BQk9SVEVELFxuICAgICAgICBjb25maWcsXG4gICAgICAgIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgIC8vIFRoaXMgaXMgb25seSBkb25lIGlmIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50LlxuICAgIC8vIFNwZWNpZmljYWxseSBub3QgaWYgd2UncmUgaW4gYSB3ZWIgd29ya2VyLCBvciByZWFjdC1uYXRpdmUuXG4gICAgaWYgKHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkpIHtcbiAgICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgICAgdmFyIHhzcmZWYWx1ZSA9IChjb25maWcud2l0aENyZWRlbnRpYWxzIHx8IGlzVVJMU2FtZU9yaWdpbihmdWxsUGF0aCkpICYmIGNvbmZpZy54c3JmQ29va2llTmFtZSA/XG4gICAgICAgIGNvb2tpZXMucmVhZChjb25maWcueHNyZkNvb2tpZU5hbWUpIDpcbiAgICAgICAgdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoeHNyZlZhbHVlKSB7XG4gICAgICAgIHJlcXVlc3RIZWFkZXJzW2NvbmZpZy54c3JmSGVhZGVyTmFtZV0gPSB4c3JmVmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIGhlYWRlcnMgdG8gdGhlIHJlcXVlc3RcbiAgICBpZiAoJ3NldFJlcXVlc3RIZWFkZXInIGluIHJlcXVlc3QpIHtcbiAgICAgIHV0aWxzLmZvckVhY2gocmVxdWVzdEhlYWRlcnMsIGZ1bmN0aW9uIHNldFJlcXVlc3RIZWFkZXIodmFsLCBrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0RGF0YSA9PT0gJ3VuZGVmaW5lZCcgJiYga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdjb250ZW50LXR5cGUnKSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIENvbnRlbnQtVHlwZSBpZiBkYXRhIGlzIHVuZGVmaW5lZFxuICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0SGVhZGVyc1trZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSBhZGQgaGVhZGVyIHRvIHRoZSByZXF1ZXN0XG4gICAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHdpdGhDcmVkZW50aWFscyB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnLndpdGhDcmVkZW50aWFscykpIHtcbiAgICAgIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gISFjb25maWcud2l0aENyZWRlbnRpYWxzO1xuICAgIH1cblxuICAgIC8vIEFkZCByZXNwb25zZVR5cGUgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAocmVzcG9uc2VUeXBlICYmIHJlc3BvbnNlVHlwZSAhPT0gJ2pzb24nKSB7XG4gICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IGNvbmZpZy5yZXNwb25zZVR5cGU7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHByb2dyZXNzIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2YgY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIC8vIE5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCB1cGxvYWQgZXZlbnRzXG4gICAgaWYgKHR5cGVvZiBjb25maWcub25VcGxvYWRQcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJyAmJiByZXF1ZXN0LnVwbG9hZCkge1xuICAgICAgcmVxdWVzdC51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBjb25maWcub25VcGxvYWRQcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbiB8fCBjb25maWcuc2lnbmFsKSB7XG4gICAgICAvLyBIYW5kbGUgY2FuY2VsbGF0aW9uXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgICAgb25DYW5jZWxlZCA9IGZ1bmN0aW9uKGNhbmNlbCkge1xuICAgICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVqZWN0KCFjYW5jZWwgfHwgKGNhbmNlbCAmJiBjYW5jZWwudHlwZSkgPyBuZXcgQ2FuY2VsZWRFcnJvcigpIDogY2FuY2VsKTtcbiAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIGNvbmZpZy5jYW5jZWxUb2tlbiAmJiBjb25maWcuY2FuY2VsVG9rZW4uc3Vic2NyaWJlKG9uQ2FuY2VsZWQpO1xuICAgICAgaWYgKGNvbmZpZy5zaWduYWwpIHtcbiAgICAgICAgY29uZmlnLnNpZ25hbC5hYm9ydGVkID8gb25DYW5jZWxlZCgpIDogY29uZmlnLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uQ2FuY2VsZWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcmVxdWVzdERhdGEpIHtcbiAgICAgIHJlcXVlc3REYXRhID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG9jb2wgPSBwYXJzZVByb3RvY29sKGZ1bGxQYXRoKTtcblxuICAgIGlmIChwcm90b2NvbCAmJiBbICdodHRwJywgJ2h0dHBzJywgJ2ZpbGUnIF0uaW5kZXhPZihwcm90b2NvbCkgPT09IC0xKSB7XG4gICAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoJ1Vuc3VwcG9ydGVkIHByb3RvY29sICcgKyBwcm90b2NvbCArICc6JywgQXhpb3NFcnJvci5FUlJfQkFEX1JFUVVFU1QsIGNvbmZpZykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuXG4gICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgIHJlcXVlc3Quc2VuZChyZXF1ZXN0RGF0YSk7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xudmFyIEF4aW9zID0gcmVxdWlyZSgnLi9jb3JlL0F4aW9zJyk7XG52YXIgbWVyZ2VDb25maWcgPSByZXF1aXJlKCcuL2NvcmUvbWVyZ2VDb25maWcnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vZGVmYXVsdHMnKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdENvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICogQHJldHVybiB7QXhpb3N9IEEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRDb25maWcpIHtcbiAgdmFyIGNvbnRleHQgPSBuZXcgQXhpb3MoZGVmYXVsdENvbmZpZyk7XG4gIHZhciBpbnN0YW5jZSA9IGJpbmQoQXhpb3MucHJvdG90eXBlLnJlcXVlc3QsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgYXhpb3MucHJvdG90eXBlIHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgQXhpb3MucHJvdG90eXBlLCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGNvbnRleHQgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBjb250ZXh0KTtcblxuICAvLyBGYWN0b3J5IGZvciBjcmVhdGluZyBuZXcgaW5zdGFuY2VzXG4gIGluc3RhbmNlLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpbnN0YW5jZUNvbmZpZykge1xuICAgIHJldHVybiBjcmVhdGVJbnN0YW5jZShtZXJnZUNvbmZpZyhkZWZhdWx0Q29uZmlnLCBpbnN0YW5jZUNvbmZpZykpO1xuICB9O1xuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLy8gQ3JlYXRlIHRoZSBkZWZhdWx0IGluc3RhbmNlIHRvIGJlIGV4cG9ydGVkXG52YXIgYXhpb3MgPSBjcmVhdGVJbnN0YW5jZShkZWZhdWx0cyk7XG5cbi8vIEV4cG9zZSBBeGlvcyBjbGFzcyB0byBhbGxvdyBjbGFzcyBpbmhlcml0YW5jZVxuYXhpb3MuQXhpb3MgPSBBeGlvcztcblxuLy8gRXhwb3NlIENhbmNlbCAmIENhbmNlbFRva2VuXG5heGlvcy5DYW5jZWxlZEVycm9yID0gcmVxdWlyZSgnLi9jYW5jZWwvQ2FuY2VsZWRFcnJvcicpO1xuYXhpb3MuQ2FuY2VsVG9rZW4gPSByZXF1aXJlKCcuL2NhbmNlbC9DYW5jZWxUb2tlbicpO1xuYXhpb3MuaXNDYW5jZWwgPSByZXF1aXJlKCcuL2NhbmNlbC9pc0NhbmNlbCcpO1xuYXhpb3MuVkVSU0lPTiA9IHJlcXVpcmUoJy4vZW52L2RhdGEnKS52ZXJzaW9uO1xuYXhpb3MudG9Gb3JtRGF0YSA9IHJlcXVpcmUoJy4vaGVscGVycy90b0Zvcm1EYXRhJyk7XG5cbi8vIEV4cG9zZSBBeGlvc0Vycm9yIGNsYXNzXG5heGlvcy5BeGlvc0Vycm9yID0gcmVxdWlyZSgnLi4vbGliL2NvcmUvQXhpb3NFcnJvcicpO1xuXG4vLyBhbGlhcyBmb3IgQ2FuY2VsZWRFcnJvciBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuYXhpb3MuQ2FuY2VsID0gYXhpb3MuQ2FuY2VsZWRFcnJvcjtcblxuLy8gRXhwb3NlIGFsbC9zcHJlYWRcbmF4aW9zLmFsbCA9IGZ1bmN0aW9uIGFsbChwcm9taXNlcykge1xuICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xufTtcbmF4aW9zLnNwcmVhZCA9IHJlcXVpcmUoJy4vaGVscGVycy9zcHJlYWQnKTtcblxuLy8gRXhwb3NlIGlzQXhpb3NFcnJvclxuYXhpb3MuaXNBeGlvc0Vycm9yID0gcmVxdWlyZSgnLi9oZWxwZXJzL2lzQXhpb3NFcnJvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGF4aW9zO1xuXG4vLyBBbGxvdyB1c2Ugb2YgZGVmYXVsdCBpbXBvcnQgc3ludGF4IGluIFR5cGVTY3JpcHRcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBheGlvcztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENhbmNlbGVkRXJyb3IgPSByZXF1aXJlKCcuL0NhbmNlbGVkRXJyb3InKTtcblxuLyoqXG4gKiBBIGBDYW5jZWxUb2tlbmAgaXMgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVxdWVzdCBjYW5jZWxsYXRpb24gb2YgYW4gb3BlcmF0aW9uLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZXhlY3V0b3IgVGhlIGV4ZWN1dG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBDYW5jZWxUb2tlbihleGVjdXRvcikge1xuICBpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhlY3V0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgdmFyIHJlc29sdmVQcm9taXNlO1xuXG4gIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIHByb21pc2VFeGVjdXRvcihyZXNvbHZlKSB7XG4gICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICB9KTtcblxuICB2YXIgdG9rZW4gPSB0aGlzO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gIHRoaXMucHJvbWlzZS50aGVuKGZ1bmN0aW9uKGNhbmNlbCkge1xuICAgIGlmICghdG9rZW4uX2xpc3RlbmVycykgcmV0dXJuO1xuXG4gICAgdmFyIGk7XG4gICAgdmFyIGwgPSB0b2tlbi5fbGlzdGVuZXJzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRva2VuLl9saXN0ZW5lcnNbaV0oY2FuY2VsKTtcbiAgICB9XG4gICAgdG9rZW4uX2xpc3RlbmVycyA9IG51bGw7XG4gIH0pO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gIHRoaXMucHJvbWlzZS50aGVuID0gZnVuY3Rpb24ob25mdWxmaWxsZWQpIHtcbiAgICB2YXIgX3Jlc29sdmU7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgIHRva2VuLnN1YnNjcmliZShyZXNvbHZlKTtcbiAgICAgIF9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB9KS50aGVuKG9uZnVsZmlsbGVkKTtcblxuICAgIHByb21pc2UuY2FuY2VsID0gZnVuY3Rpb24gcmVqZWN0KCkge1xuICAgICAgdG9rZW4udW5zdWJzY3JpYmUoX3Jlc29sdmUpO1xuICAgIH07XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcblxuICBleGVjdXRvcihmdW5jdGlvbiBjYW5jZWwobWVzc2FnZSkge1xuICAgIGlmICh0b2tlbi5yZWFzb24pIHtcbiAgICAgIC8vIENhbmNlbGxhdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRva2VuLnJlYXNvbiA9IG5ldyBDYW5jZWxlZEVycm9yKG1lc3NhZ2UpO1xuICAgIHJlc29sdmVQcm9taXNlKHRva2VuLnJlYXNvbik7XG4gIH0pO1xufVxuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxlZEVycm9yYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5DYW5jZWxUb2tlbi5wcm90b3R5cGUudGhyb3dJZlJlcXVlc3RlZCA9IGZ1bmN0aW9uIHRocm93SWZSZXF1ZXN0ZWQoKSB7XG4gIGlmICh0aGlzLnJlYXNvbikge1xuICAgIHRocm93IHRoaXMucmVhc29uO1xuICB9XG59O1xuXG4vKipcbiAqIFN1YnNjcmliZSB0byB0aGUgY2FuY2VsIHNpZ25hbFxuICovXG5cbkNhbmNlbFRva2VuLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiBzdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgbGlzdGVuZXIodGhpcy5yZWFzb24pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICB0aGlzLl9saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0gW2xpc3RlbmVyXTtcbiAgfVxufTtcblxuLyoqXG4gKiBVbnN1YnNjcmliZSBmcm9tIHRoZSBjYW5jZWwgc2lnbmFsXG4gKi9cblxuQ2FuY2VsVG9rZW4ucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gdW5zdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgaWYgKCF0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGluZGV4ID0gdGhpcy5fbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgdGhpcy5fbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBjb250YWlucyBhIG5ldyBgQ2FuY2VsVG9rZW5gIGFuZCBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLFxuICogY2FuY2VscyB0aGUgYENhbmNlbFRva2VuYC5cbiAqL1xuQ2FuY2VsVG9rZW4uc291cmNlID0gZnVuY3Rpb24gc291cmNlKCkge1xuICB2YXIgY2FuY2VsO1xuICB2YXIgdG9rZW4gPSBuZXcgQ2FuY2VsVG9rZW4oZnVuY3Rpb24gZXhlY3V0b3IoYykge1xuICAgIGNhbmNlbCA9IGM7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHRva2VuOiB0b2tlbixcbiAgICBjYW5jZWw6IGNhbmNlbFxuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW5jZWxUb2tlbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEF4aW9zRXJyb3IgPSByZXF1aXJlKCcuLi9jb3JlL0F4aW9zRXJyb3InKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbi8qKlxuICogQSBgQ2FuY2VsZWRFcnJvcmAgaXMgYW4gb2JqZWN0IHRoYXQgaXMgdGhyb3duIHdoZW4gYW4gb3BlcmF0aW9uIGlzIGNhbmNlbGVkLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtzdHJpbmc9fSBtZXNzYWdlIFRoZSBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiBDYW5jZWxlZEVycm9yKG1lc3NhZ2UpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsZXFlcWVxXG4gIEF4aW9zRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlID09IG51bGwgPyAnY2FuY2VsZWQnIDogbWVzc2FnZSwgQXhpb3NFcnJvci5FUlJfQ0FOQ0VMRUQpO1xuICB0aGlzLm5hbWUgPSAnQ2FuY2VsZWRFcnJvcic7XG59XG5cbnV0aWxzLmluaGVyaXRzKENhbmNlbGVkRXJyb3IsIEF4aW9zRXJyb3IsIHtcbiAgX19DQU5DRUxfXzogdHJ1ZVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FuY2VsZWRFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0NhbmNlbCh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX19DQU5DRUxfXyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgYnVpbGRVUkwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2J1aWxkVVJMJyk7XG52YXIgSW50ZXJjZXB0b3JNYW5hZ2VyID0gcmVxdWlyZSgnLi9JbnRlcmNlcHRvck1hbmFnZXInKTtcbnZhciBkaXNwYXRjaFJlcXVlc3QgPSByZXF1aXJlKCcuL2Rpc3BhdGNoUmVxdWVzdCcpO1xudmFyIG1lcmdlQ29uZmlnID0gcmVxdWlyZSgnLi9tZXJnZUNvbmZpZycpO1xudmFyIGJ1aWxkRnVsbFBhdGggPSByZXF1aXJlKCcuL2J1aWxkRnVsbFBhdGgnKTtcbnZhciB2YWxpZGF0b3IgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3ZhbGlkYXRvcicpO1xuXG52YXIgdmFsaWRhdG9ycyA9IHZhbGlkYXRvci52YWxpZGF0b3JzO1xuLyoqXG4gKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaW5zdGFuY2VDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gQXhpb3MoaW5zdGFuY2VDb25maWcpIHtcbiAgdGhpcy5kZWZhdWx0cyA9IGluc3RhbmNlQ29uZmlnO1xuICB0aGlzLmludGVyY2VwdG9ycyA9IHtcbiAgICByZXF1ZXN0OiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKCksXG4gICAgcmVzcG9uc2U6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKVxuICB9O1xufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyBzcGVjaWZpYyBmb3IgdGhpcyByZXF1ZXN0IChtZXJnZWQgd2l0aCB0aGlzLmRlZmF1bHRzKVxuICovXG5BeGlvcy5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIHJlcXVlc3QoY29uZmlnT3JVcmwsIGNvbmZpZykge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgLy8gQWxsb3cgZm9yIGF4aW9zKCdleGFtcGxlL3VybCdbLCBjb25maWddKSBhIGxhIGZldGNoIEFQSVxuICBpZiAodHlwZW9mIGNvbmZpZ09yVXJsID09PSAnc3RyaW5nJykge1xuICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICBjb25maWcudXJsID0gY29uZmlnT3JVcmw7XG4gIH0gZWxzZSB7XG4gICAgY29uZmlnID0gY29uZmlnT3JVcmwgfHwge307XG4gIH1cblxuICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuXG4gIC8vIFNldCBjb25maWcubWV0aG9kXG4gIGlmIChjb25maWcubWV0aG9kKSB7XG4gICAgY29uZmlnLm1ldGhvZCA9IGNvbmZpZy5tZXRob2QudG9Mb3dlckNhc2UoKTtcbiAgfSBlbHNlIGlmICh0aGlzLmRlZmF1bHRzLm1ldGhvZCkge1xuICAgIGNvbmZpZy5tZXRob2QgPSB0aGlzLmRlZmF1bHRzLm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2Uge1xuICAgIGNvbmZpZy5tZXRob2QgPSAnZ2V0JztcbiAgfVxuXG4gIHZhciB0cmFuc2l0aW9uYWwgPSBjb25maWcudHJhbnNpdGlvbmFsO1xuXG4gIGlmICh0cmFuc2l0aW9uYWwgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhbGlkYXRvci5hc3NlcnRPcHRpb25zKHRyYW5zaXRpb25hbCwge1xuICAgICAgc2lsZW50SlNPTlBhcnNpbmc6IHZhbGlkYXRvcnMudHJhbnNpdGlvbmFsKHZhbGlkYXRvcnMuYm9vbGVhbiksXG4gICAgICBmb3JjZWRKU09OUGFyc2luZzogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuKSxcbiAgICAgIGNsYXJpZnlUaW1lb3V0RXJyb3I6IHZhbGlkYXRvcnMudHJhbnNpdGlvbmFsKHZhbGlkYXRvcnMuYm9vbGVhbilcbiAgICB9LCBmYWxzZSk7XG4gIH1cblxuICAvLyBmaWx0ZXIgb3V0IHNraXBwZWQgaW50ZXJjZXB0b3JzXG4gIHZhciByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbiA9IFtdO1xuICB2YXIgc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzID0gdHJ1ZTtcbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVxdWVzdC5mb3JFYWNoKGZ1bmN0aW9uIHVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgaWYgKHR5cGVvZiBpbnRlcmNlcHRvci5ydW5XaGVuID09PSAnZnVuY3Rpb24nICYmIGludGVyY2VwdG9yLnJ1bldoZW4oY29uZmlnKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgPSBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgJiYgaW50ZXJjZXB0b3Iuc3luY2hyb25vdXM7XG5cbiAgICByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi51bnNoaWZ0KGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB2YXIgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluID0gW107XG4gIHRoaXMuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLmZvckVhY2goZnVuY3Rpb24gcHVzaFJlc3BvbnNlSW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluLnB1c2goaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gIH0pO1xuXG4gIHZhciBwcm9taXNlO1xuXG4gIGlmICghc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzKSB7XG4gICAgdmFyIGNoYWluID0gW2Rpc3BhdGNoUmVxdWVzdCwgdW5kZWZpbmVkXTtcblxuICAgIEFycmF5LnByb3RvdHlwZS51bnNoaWZ0LmFwcGx5KGNoYWluLCByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbik7XG4gICAgY2hhaW4gPSBjaGFpbi5jb25jYXQocmVzcG9uc2VJbnRlcmNlcHRvckNoYWluKTtcblxuICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoY29uZmlnKTtcbiAgICB3aGlsZSAoY2hhaW4ubGVuZ3RoKSB7XG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGNoYWluLnNoaWZ0KCksIGNoYWluLnNoaWZ0KCkpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cblxuICB2YXIgbmV3Q29uZmlnID0gY29uZmlnO1xuICB3aGlsZSAocmVxdWVzdEludGVyY2VwdG9yQ2hhaW4ubGVuZ3RoKSB7XG4gICAgdmFyIG9uRnVsZmlsbGVkID0gcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4uc2hpZnQoKTtcbiAgICB2YXIgb25SZWplY3RlZCA9IHJlcXVlc3RJbnRlcmNlcHRvckNoYWluLnNoaWZ0KCk7XG4gICAgdHJ5IHtcbiAgICAgIG5ld0NvbmZpZyA9IG9uRnVsZmlsbGVkKG5ld0NvbmZpZyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIG9uUmVqZWN0ZWQoZXJyb3IpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdHJ5IHtcbiAgICBwcm9taXNlID0gZGlzcGF0Y2hSZXF1ZXN0KG5ld0NvbmZpZyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgfVxuXG4gIHdoaWxlIChyZXNwb25zZUludGVyY2VwdG9yQ2hhaW4ubGVuZ3RoKSB7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihyZXNwb25zZUludGVyY2VwdG9yQ2hhaW4uc2hpZnQoKSwgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluLnNoaWZ0KCkpO1xuICB9XG5cbiAgcmV0dXJuIHByb21pc2U7XG59O1xuXG5BeGlvcy5wcm90b3R5cGUuZ2V0VXJpID0gZnVuY3Rpb24gZ2V0VXJpKGNvbmZpZykge1xuICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuICB2YXIgZnVsbFBhdGggPSBidWlsZEZ1bGxQYXRoKGNvbmZpZy5iYXNlVVJMLCBjb25maWcudXJsKTtcbiAgcmV0dXJuIGJ1aWxkVVJMKGZ1bGxQYXRoLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplcik7XG59O1xuXG4vLyBQcm92aWRlIGFsaWFzZXMgZm9yIHN1cHBvcnRlZCByZXF1ZXN0IG1ldGhvZHNcbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAnb3B0aW9ucyddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChtZXJnZUNvbmZpZyhjb25maWcgfHwge30sIHtcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgdXJsOiB1cmwsXG4gICAgICBkYXRhOiAoY29uZmlnIHx8IHt9KS5kYXRhXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVIVFRQTWV0aG9kKGlzRm9ybSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBodHRwTWV0aG9kKHVybCwgZGF0YSwgY29uZmlnKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1lcmdlQ29uZmlnKGNvbmZpZyB8fCB7fSwge1xuICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgaGVhZGVyczogaXNGb3JtID8ge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnbXVsdGlwYXJ0L2Zvcm0tZGF0YSdcbiAgICAgICAgfSA6IHt9LFxuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgZGF0YTogZGF0YVxuICAgICAgfSkpO1xuICAgIH07XG4gIH1cblxuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGdlbmVyYXRlSFRUUE1ldGhvZCgpO1xuXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2QgKyAnRm9ybSddID0gZ2VuZXJhdGVIVFRQTWV0aG9kKHRydWUpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQXhpb3M7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbi8qKlxuICogQ3JlYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBtZXNzYWdlLCBjb25maWcsIGVycm9yIGNvZGUsIHJlcXVlc3QgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGNyZWF0ZWQgZXJyb3IuXG4gKi9cbmZ1bmN0aW9uIEF4aW9zRXJyb3IobWVzc2FnZSwgY29kZSwgY29uZmlnLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICBFcnJvci5jYWxsKHRoaXMpO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB0aGlzLm5hbWUgPSAnQXhpb3NFcnJvcic7XG4gIGNvZGUgJiYgKHRoaXMuY29kZSA9IGNvZGUpO1xuICBjb25maWcgJiYgKHRoaXMuY29uZmlnID0gY29uZmlnKTtcbiAgcmVxdWVzdCAmJiAodGhpcy5yZXF1ZXN0ID0gcmVxdWVzdCk7XG4gIHJlc3BvbnNlICYmICh0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2UpO1xufVxuXG51dGlscy5pbmhlcml0cyhBeGlvc0Vycm9yLCBFcnJvciwge1xuICB0b0pTT046IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gU3RhbmRhcmRcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIC8vIE1pY3Jvc29mdFxuICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXG4gICAgICBudW1iZXI6IHRoaXMubnVtYmVyLFxuICAgICAgLy8gTW96aWxsYVxuICAgICAgZmlsZU5hbWU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXG4gICAgICBjb2x1bW5OdW1iZXI6IHRoaXMuY29sdW1uTnVtYmVyLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICAvLyBBeGlvc1xuICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgIGNvZGU6IHRoaXMuY29kZSxcbiAgICAgIHN0YXR1czogdGhpcy5yZXNwb25zZSAmJiB0aGlzLnJlc3BvbnNlLnN0YXR1cyA/IHRoaXMucmVzcG9uc2Uuc3RhdHVzIDogbnVsbFxuICAgIH07XG4gIH1cbn0pO1xuXG52YXIgcHJvdG90eXBlID0gQXhpb3NFcnJvci5wcm90b3R5cGU7XG52YXIgZGVzY3JpcHRvcnMgPSB7fTtcblxuW1xuICAnRVJSX0JBRF9PUFRJT05fVkFMVUUnLFxuICAnRVJSX0JBRF9PUFRJT04nLFxuICAnRUNPTk5BQk9SVEVEJyxcbiAgJ0VUSU1FRE9VVCcsXG4gICdFUlJfTkVUV09SSycsXG4gICdFUlJfRlJfVE9PX01BTllfUkVESVJFQ1RTJyxcbiAgJ0VSUl9ERVBSRUNBVEVEJyxcbiAgJ0VSUl9CQURfUkVTUE9OU0UnLFxuICAnRVJSX0JBRF9SRVFVRVNUJyxcbiAgJ0VSUl9DQU5DRUxFRCdcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5dLmZvckVhY2goZnVuY3Rpb24oY29kZSkge1xuICBkZXNjcmlwdG9yc1tjb2RlXSA9IHt2YWx1ZTogY29kZX07XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQXhpb3NFcnJvciwgZGVzY3JpcHRvcnMpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgJ2lzQXhpb3NFcnJvcicsIHt2YWx1ZTogdHJ1ZX0pO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuQXhpb3NFcnJvci5mcm9tID0gZnVuY3Rpb24oZXJyb3IsIGNvZGUsIGNvbmZpZywgcmVxdWVzdCwgcmVzcG9uc2UsIGN1c3RvbVByb3BzKSB7XG4gIHZhciBheGlvc0Vycm9yID0gT2JqZWN0LmNyZWF0ZShwcm90b3R5cGUpO1xuXG4gIHV0aWxzLnRvRmxhdE9iamVjdChlcnJvciwgYXhpb3NFcnJvciwgZnVuY3Rpb24gZmlsdGVyKG9iaikge1xuICAgIHJldHVybiBvYmogIT09IEVycm9yLnByb3RvdHlwZTtcbiAgfSk7XG5cbiAgQXhpb3NFcnJvci5jYWxsKGF4aW9zRXJyb3IsIGVycm9yLm1lc3NhZ2UsIGNvZGUsIGNvbmZpZywgcmVxdWVzdCwgcmVzcG9uc2UpO1xuXG4gIGF4aW9zRXJyb3IubmFtZSA9IGVycm9yLm5hbWU7XG5cbiAgY3VzdG9tUHJvcHMgJiYgT2JqZWN0LmFzc2lnbihheGlvc0Vycm9yLCBjdXN0b21Qcm9wcyk7XG5cbiAgcmV0dXJuIGF4aW9zRXJyb3I7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF4aW9zRXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gSW50ZXJjZXB0b3JNYW5hZ2VyKCkge1xuICB0aGlzLmhhbmRsZXJzID0gW107XG59XG5cbi8qKlxuICogQWRkIGEgbmV3IGludGVyY2VwdG9yIHRvIHRoZSBzdGFja1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bGZpbGxlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGB0aGVuYCBmb3IgYSBgUHJvbWlzZWBcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHJlamVjdGAgZm9yIGEgYFByb21pc2VgXG4gKlxuICogQHJldHVybiB7TnVtYmVyfSBBbiBJRCB1c2VkIHRvIHJlbW92ZSBpbnRlcmNlcHRvciBsYXRlclxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIHVzZShmdWxmaWxsZWQsIHJlamVjdGVkLCBvcHRpb25zKSB7XG4gIHRoaXMuaGFuZGxlcnMucHVzaCh7XG4gICAgZnVsZmlsbGVkOiBmdWxmaWxsZWQsXG4gICAgcmVqZWN0ZWQ6IHJlamVjdGVkLFxuICAgIHN5bmNocm9ub3VzOiBvcHRpb25zID8gb3B0aW9ucy5zeW5jaHJvbm91cyA6IGZhbHNlLFxuICAgIHJ1bldoZW46IG9wdGlvbnMgPyBvcHRpb25zLnJ1bldoZW4gOiBudWxsXG4gIH0pO1xuICByZXR1cm4gdGhpcy5oYW5kbGVycy5sZW5ndGggLSAxO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaW50ZXJjZXB0b3IgZnJvbSB0aGUgc3RhY2tcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gaWQgVGhlIElEIHRoYXQgd2FzIHJldHVybmVkIGJ5IGB1c2VgXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUuZWplY3QgPSBmdW5jdGlvbiBlamVjdChpZCkge1xuICBpZiAodGhpcy5oYW5kbGVyc1tpZF0pIHtcbiAgICB0aGlzLmhhbmRsZXJzW2lkXSA9IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFsbCB0aGUgcmVnaXN0ZXJlZCBpbnRlcmNlcHRvcnNcbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBza2lwcGluZyBvdmVyIGFueVxuICogaW50ZXJjZXB0b3JzIHRoYXQgbWF5IGhhdmUgYmVjb21lIGBudWxsYCBjYWxsaW5nIGBlamVjdGAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggaW50ZXJjZXB0b3JcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaChmbikge1xuICB1dGlscy5mb3JFYWNoKHRoaXMuaGFuZGxlcnMsIGZ1bmN0aW9uIGZvckVhY2hIYW5kbGVyKGgpIHtcbiAgICBpZiAoaCAhPT0gbnVsbCkge1xuICAgICAgZm4oaCk7XG4gICAgfVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW50ZXJjZXB0b3JNYW5hZ2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNBYnNvbHV0ZVVSTCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTCcpO1xudmFyIGNvbWJpbmVVUkxzID0gcmVxdWlyZSgnLi4vaGVscGVycy9jb21iaW5lVVJMcycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgYmFzZVVSTCB3aXRoIHRoZSByZXF1ZXN0ZWRVUkwsXG4gKiBvbmx5IHdoZW4gdGhlIHJlcXVlc3RlZFVSTCBpcyBub3QgYWxyZWFkeSBhbiBhYnNvbHV0ZSBVUkwuXG4gKiBJZiB0aGUgcmVxdWVzdFVSTCBpcyBhYnNvbHV0ZSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSByZXF1ZXN0ZWRVUkwgdW50b3VjaGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlcXVlc3RlZFVSTCBBYnNvbHV0ZSBvciByZWxhdGl2ZSBVUkwgdG8gY29tYmluZVxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIGZ1bGwgcGF0aFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJ1aWxkRnVsbFBhdGgoYmFzZVVSTCwgcmVxdWVzdGVkVVJMKSB7XG4gIGlmIChiYXNlVVJMICYmICFpc0Fic29sdXRlVVJMKHJlcXVlc3RlZFVSTCkpIHtcbiAgICByZXR1cm4gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVxdWVzdGVkVVJMKTtcbiAgfVxuICByZXR1cm4gcmVxdWVzdGVkVVJMO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHRyYW5zZm9ybURhdGEgPSByZXF1aXJlKCcuL3RyYW5zZm9ybURhdGEnKTtcbnZhciBpc0NhbmNlbCA9IHJlcXVpcmUoJy4uL2NhbmNlbC9pc0NhbmNlbCcpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi4vZGVmYXVsdHMnKTtcbnZhciBDYW5jZWxlZEVycm9yID0gcmVxdWlyZSgnLi4vY2FuY2VsL0NhbmNlbGVkRXJyb3InKTtcblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsZWRFcnJvcmAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqL1xuZnVuY3Rpb24gdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpIHtcbiAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgIGNvbmZpZy5jYW5jZWxUb2tlbi50aHJvd0lmUmVxdWVzdGVkKCk7XG4gIH1cblxuICBpZiAoY29uZmlnLnNpZ25hbCAmJiBjb25maWcuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICB0aHJvdyBuZXcgQ2FuY2VsZWRFcnJvcigpO1xuICB9XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgdXNpbmcgdGhlIGNvbmZpZ3VyZWQgYWRhcHRlci5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIFRoZSBjb25maWcgdGhhdCBpcyB0byBiZSB1c2VkIGZvciB0aGUgcmVxdWVzdFxuICogQHJldHVybnMge1Byb21pc2V9IFRoZSBQcm9taXNlIHRvIGJlIGZ1bGZpbGxlZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRpc3BhdGNoUmVxdWVzdChjb25maWcpIHtcbiAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gIC8vIEVuc3VyZSBoZWFkZXJzIGV4aXN0XG4gIGNvbmZpZy5oZWFkZXJzID0gY29uZmlnLmhlYWRlcnMgfHwge307XG5cbiAgLy8gVHJhbnNmb3JtIHJlcXVlc3QgZGF0YVxuICBjb25maWcuZGF0YSA9IHRyYW5zZm9ybURhdGEuY2FsbChcbiAgICBjb25maWcsXG4gICAgY29uZmlnLmRhdGEsXG4gICAgY29uZmlnLmhlYWRlcnMsXG4gICAgY29uZmlnLnRyYW5zZm9ybVJlcXVlc3RcbiAgKTtcblxuICAvLyBGbGF0dGVuIGhlYWRlcnNcbiAgY29uZmlnLmhlYWRlcnMgPSB1dGlscy5tZXJnZShcbiAgICBjb25maWcuaGVhZGVycy5jb21tb24gfHwge30sXG4gICAgY29uZmlnLmhlYWRlcnNbY29uZmlnLm1ldGhvZF0gfHwge30sXG4gICAgY29uZmlnLmhlYWRlcnNcbiAgKTtcblxuICB1dGlscy5mb3JFYWNoKFxuICAgIFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJywgJ2NvbW1vbiddLFxuICAgIGZ1bmN0aW9uIGNsZWFuSGVhZGVyQ29uZmlnKG1ldGhvZCkge1xuICAgICAgZGVsZXRlIGNvbmZpZy5oZWFkZXJzW21ldGhvZF07XG4gICAgfVxuICApO1xuXG4gIHZhciBhZGFwdGVyID0gY29uZmlnLmFkYXB0ZXIgfHwgZGVmYXVsdHMuYWRhcHRlcjtcblxuICByZXR1cm4gYWRhcHRlcihjb25maWcpLnRoZW4oZnVuY3Rpb24gb25BZGFwdGVyUmVzb2x1dGlvbihyZXNwb25zZSkge1xuICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgcmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEuY2FsbChcbiAgICAgIGNvbmZpZyxcbiAgICAgIHJlc3BvbnNlLmRhdGEsXG4gICAgICByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgKTtcblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSwgZnVuY3Rpb24gb25BZGFwdGVyUmVqZWN0aW9uKHJlYXNvbikge1xuICAgIGlmICghaXNDYW5jZWwocmVhc29uKSkge1xuICAgICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgICAgaWYgKHJlYXNvbiAmJiByZWFzb24ucmVzcG9uc2UpIHtcbiAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhLmNhbGwoXG4gICAgICAgICAgY29uZmlnLFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhLFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZWFzb24pO1xuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbi8qKlxuICogQ29uZmlnLXNwZWNpZmljIG1lcmdlLWZ1bmN0aW9uIHdoaWNoIGNyZWF0ZXMgYSBuZXcgY29uZmlnLW9iamVjdFxuICogYnkgbWVyZ2luZyB0d28gY29uZmlndXJhdGlvbiBvYmplY3RzIHRvZ2V0aGVyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcxXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnMlxuICogQHJldHVybnMge09iamVjdH0gTmV3IG9iamVjdCByZXN1bHRpbmcgZnJvbSBtZXJnaW5nIGNvbmZpZzIgdG8gY29uZmlnMVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1lcmdlQ29uZmlnKGNvbmZpZzEsIGNvbmZpZzIpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIGNvbmZpZzIgPSBjb25maWcyIHx8IHt9O1xuICB2YXIgY29uZmlnID0ge307XG5cbiAgZnVuY3Rpb24gZ2V0TWVyZ2VkVmFsdWUodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBpZiAodXRpbHMuaXNQbGFpbk9iamVjdCh0YXJnZXQpICYmIHV0aWxzLmlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHV0aWxzLm1lcmdlKHRhcmdldCwgc291cmNlKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHV0aWxzLm1lcmdlKHt9LCBzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gc291cmNlLnNsaWNlKCk7XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgZnVuY3Rpb24gbWVyZ2VEZWVwUHJvcGVydGllcyhwcm9wKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcyW3Byb3BdKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKGNvbmZpZzFbcHJvcF0sIGNvbmZpZzJbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzFbcHJvcF0pKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcxW3Byb3BdKTtcbiAgICB9XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgZnVuY3Rpb24gdmFsdWVGcm9tQ29uZmlnMihwcm9wKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcyW3Byb3BdKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMltwcm9wXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIGZ1bmN0aW9uIGRlZmF1bHRUb0NvbmZpZzIocHJvcCkge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMltwcm9wXSkpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzJbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzFbcHJvcF0pKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcxW3Byb3BdKTtcbiAgICB9XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgZnVuY3Rpb24gbWVyZ2VEaXJlY3RLZXlzKHByb3ApIHtcbiAgICBpZiAocHJvcCBpbiBjb25maWcyKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUoY29uZmlnMVtwcm9wXSwgY29uZmlnMltwcm9wXSk7XG4gICAgfSBlbHNlIGlmIChwcm9wIGluIGNvbmZpZzEpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xuICAgIH1cbiAgfVxuXG4gIHZhciBtZXJnZU1hcCA9IHtcbiAgICAndXJsJzogdmFsdWVGcm9tQ29uZmlnMixcbiAgICAnbWV0aG9kJzogdmFsdWVGcm9tQ29uZmlnMixcbiAgICAnZGF0YSc6IHZhbHVlRnJvbUNvbmZpZzIsXG4gICAgJ2Jhc2VVUkwnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICd0cmFuc2Zvcm1SZXF1ZXN0JzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAndHJhbnNmb3JtUmVzcG9uc2UnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdwYXJhbXNTZXJpYWxpemVyJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAndGltZW91dCc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ3RpbWVvdXRNZXNzYWdlJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAnd2l0aENyZWRlbnRpYWxzJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAnYWRhcHRlcic6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ3Jlc3BvbnNlVHlwZSc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ3hzcmZDb29raWVOYW1lJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAneHNyZkhlYWRlck5hbWUnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdvblVwbG9hZFByb2dyZXNzJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAnb25Eb3dubG9hZFByb2dyZXNzJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAnZGVjb21wcmVzcyc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ21heENvbnRlbnRMZW5ndGgnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdtYXhCb2R5TGVuZ3RoJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAnYmVmb3JlUmVkaXJlY3QnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICd0cmFuc3BvcnQnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdodHRwQWdlbnQnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdodHRwc0FnZW50JzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAnY2FuY2VsVG9rZW4nOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdzb2NrZXRQYXRoJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAncmVzcG9uc2VFbmNvZGluZyc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ3ZhbGlkYXRlU3RhdHVzJzogbWVyZ2VEaXJlY3RLZXlzXG4gIH07XG5cbiAgdXRpbHMuZm9yRWFjaChPYmplY3Qua2V5cyhjb25maWcxKS5jb25jYXQoT2JqZWN0LmtleXMoY29uZmlnMikpLCBmdW5jdGlvbiBjb21wdXRlQ29uZmlnVmFsdWUocHJvcCkge1xuICAgIHZhciBtZXJnZSA9IG1lcmdlTWFwW3Byb3BdIHx8IG1lcmdlRGVlcFByb3BlcnRpZXM7XG4gICAgdmFyIGNvbmZpZ1ZhbHVlID0gbWVyZ2UocHJvcCk7XG4gICAgKHV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZ1ZhbHVlKSAmJiBtZXJnZSAhPT0gbWVyZ2VEaXJlY3RLZXlzKSB8fCAoY29uZmlnW3Byb3BdID0gY29uZmlnVmFsdWUpO1xuICB9KTtcblxuICByZXR1cm4gY29uZmlnO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEF4aW9zRXJyb3IgPSByZXF1aXJlKCcuL0F4aW9zRXJyb3InKTtcblxuLyoqXG4gKiBSZXNvbHZlIG9yIHJlamVjdCBhIFByb21pc2UgYmFzZWQgb24gcmVzcG9uc2Ugc3RhdHVzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmUgQSBmdW5jdGlvbiB0aGF0IHJlc29sdmVzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0IEEgZnVuY3Rpb24gdGhhdCByZWplY3RzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtvYmplY3R9IHJlc3BvbnNlIFRoZSByZXNwb25zZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSkge1xuICB2YXIgdmFsaWRhdGVTdGF0dXMgPSByZXNwb25zZS5jb25maWcudmFsaWRhdGVTdGF0dXM7XG4gIGlmICghcmVzcG9uc2Uuc3RhdHVzIHx8ICF2YWxpZGF0ZVN0YXR1cyB8fCB2YWxpZGF0ZVN0YXR1cyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gIH0gZWxzZSB7XG4gICAgcmVqZWN0KG5ldyBBeGlvc0Vycm9yKFxuICAgICAgJ1JlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJyArIHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIFtBeGlvc0Vycm9yLkVSUl9CQURfUkVRVUVTVCwgQXhpb3NFcnJvci5FUlJfQkFEX1JFU1BPTlNFXVtNYXRoLmZsb29yKHJlc3BvbnNlLnN0YXR1cyAvIDEwMCkgLSA0XSxcbiAgICAgIHJlc3BvbnNlLmNvbmZpZyxcbiAgICAgIHJlc3BvbnNlLnJlcXVlc3QsXG4gICAgICByZXNwb25zZVxuICAgICkpO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLi9kZWZhdWx0cycpO1xuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgZGF0YSBmb3IgYSByZXF1ZXN0IG9yIGEgcmVzcG9uc2VcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gYmUgdHJhbnNmb3JtZWRcbiAqIEBwYXJhbSB7QXJyYXl9IGhlYWRlcnMgVGhlIGhlYWRlcnMgZm9yIHRoZSByZXF1ZXN0IG9yIHJlc3BvbnNlXG4gKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufSBmbnMgQSBzaW5nbGUgZnVuY3Rpb24gb3IgQXJyYXkgb2YgZnVuY3Rpb25zXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHJlc3VsdGluZyB0cmFuc2Zvcm1lZCBkYXRhXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHJhbnNmb3JtRGF0YShkYXRhLCBoZWFkZXJzLCBmbnMpIHtcbiAgdmFyIGNvbnRleHQgPSB0aGlzIHx8IGRlZmF1bHRzO1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgdXRpbHMuZm9yRWFjaChmbnMsIGZ1bmN0aW9uIHRyYW5zZm9ybShmbikge1xuICAgIGRhdGEgPSBmbi5jYWxsKGNvbnRleHQsIGRhdGEsIGhlYWRlcnMpO1xuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgbm9ybWFsaXplSGVhZGVyTmFtZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZScpO1xudmFyIEF4aW9zRXJyb3IgPSByZXF1aXJlKCcuLi9jb3JlL0F4aW9zRXJyb3InKTtcbnZhciB0cmFuc2l0aW9uYWxEZWZhdWx0cyA9IHJlcXVpcmUoJy4vdHJhbnNpdGlvbmFsJyk7XG52YXIgdG9Gb3JtRGF0YSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvdG9Gb3JtRGF0YScpO1xuXG52YXIgREVGQVVMVF9DT05URU5UX1RZUEUgPSB7XG4gICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xufTtcblxuZnVuY3Rpb24gc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsIHZhbHVlKSB7XG4gIGlmICghdXRpbHMuaXNVbmRlZmluZWQoaGVhZGVycykgJiYgdXRpbHMuaXNVbmRlZmluZWQoaGVhZGVyc1snQ29udGVudC1UeXBlJ10pKSB7XG4gICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0QWRhcHRlcigpIHtcbiAgdmFyIGFkYXB0ZXI7XG4gIGlmICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gRm9yIGJyb3dzZXJzIHVzZSBYSFIgYWRhcHRlclxuICAgIGFkYXB0ZXIgPSByZXF1aXJlKCcuLi9hZGFwdGVycy94aHInKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXScpIHtcbiAgICAvLyBGb3Igbm9kZSB1c2UgSFRUUCBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4uL2FkYXB0ZXJzL2h0dHAnKTtcbiAgfVxuICByZXR1cm4gYWRhcHRlcjtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5U2FmZWx5KHJhd1ZhbHVlLCBwYXJzZXIsIGVuY29kZXIpIHtcbiAgaWYgKHV0aWxzLmlzU3RyaW5nKHJhd1ZhbHVlKSkge1xuICAgIHRyeSB7XG4gICAgICAocGFyc2VyIHx8IEpTT04ucGFyc2UpKHJhd1ZhbHVlKTtcbiAgICAgIHJldHVybiB1dGlscy50cmltKHJhd1ZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZS5uYW1lICE9PSAnU3ludGF4RXJyb3InKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIChlbmNvZGVyIHx8IEpTT04uc3RyaW5naWZ5KShyYXdWYWx1ZSk7XG59XG5cbnZhciBkZWZhdWx0cyA9IHtcblxuICB0cmFuc2l0aW9uYWw6IHRyYW5zaXRpb25hbERlZmF1bHRzLFxuXG4gIGFkYXB0ZXI6IGdldERlZmF1bHRBZGFwdGVyKCksXG5cbiAgdHJhbnNmb3JtUmVxdWVzdDogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlcXVlc3QoZGF0YSwgaGVhZGVycykge1xuICAgIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgJ0FjY2VwdCcpO1xuICAgIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgJ0NvbnRlbnQtVHlwZScpO1xuXG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQXJyYXlCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc1N0cmVhbShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNGaWxlKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0Jsb2IoZGF0YSlcbiAgICApIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNBcnJheUJ1ZmZlclZpZXcoZGF0YSkpIHtcbiAgICAgIHJldHVybiBkYXRhLmJ1ZmZlcjtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKGRhdGEpKSB7XG4gICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PXV0Zi04Jyk7XG4gICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuICAgIH1cblxuICAgIHZhciBpc09iamVjdFBheWxvYWQgPSB1dGlscy5pc09iamVjdChkYXRhKTtcbiAgICB2YXIgY29udGVudFR5cGUgPSBoZWFkZXJzICYmIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddO1xuXG4gICAgdmFyIGlzRmlsZUxpc3Q7XG5cbiAgICBpZiAoKGlzRmlsZUxpc3QgPSB1dGlscy5pc0ZpbGVMaXN0KGRhdGEpKSB8fCAoaXNPYmplY3RQYXlsb2FkICYmIGNvbnRlbnRUeXBlID09PSAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScpKSB7XG4gICAgICB2YXIgX0Zvcm1EYXRhID0gdGhpcy5lbnYgJiYgdGhpcy5lbnYuRm9ybURhdGE7XG4gICAgICByZXR1cm4gdG9Gb3JtRGF0YShpc0ZpbGVMaXN0ID8geydmaWxlc1tdJzogZGF0YX0gOiBkYXRhLCBfRm9ybURhdGEgJiYgbmV3IF9Gb3JtRGF0YSgpKTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0UGF5bG9hZCB8fCBjb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL2pzb24nKSB7XG4gICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgIHJldHVybiBzdHJpbmdpZnlTYWZlbHkoZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIHRyYW5zZm9ybVJlc3BvbnNlOiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVzcG9uc2UoZGF0YSkge1xuICAgIHZhciB0cmFuc2l0aW9uYWwgPSB0aGlzLnRyYW5zaXRpb25hbCB8fCBkZWZhdWx0cy50cmFuc2l0aW9uYWw7XG4gICAgdmFyIHNpbGVudEpTT05QYXJzaW5nID0gdHJhbnNpdGlvbmFsICYmIHRyYW5zaXRpb25hbC5zaWxlbnRKU09OUGFyc2luZztcbiAgICB2YXIgZm9yY2VkSlNPTlBhcnNpbmcgPSB0cmFuc2l0aW9uYWwgJiYgdHJhbnNpdGlvbmFsLmZvcmNlZEpTT05QYXJzaW5nO1xuICAgIHZhciBzdHJpY3RKU09OUGFyc2luZyA9ICFzaWxlbnRKU09OUGFyc2luZyAmJiB0aGlzLnJlc3BvbnNlVHlwZSA9PT0gJ2pzb24nO1xuXG4gICAgaWYgKHN0cmljdEpTT05QYXJzaW5nIHx8IChmb3JjZWRKU09OUGFyc2luZyAmJiB1dGlscy5pc1N0cmluZyhkYXRhKSAmJiBkYXRhLmxlbmd0aCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoc3RyaWN0SlNPTlBhcnNpbmcpIHtcbiAgICAgICAgICBpZiAoZS5uYW1lID09PSAnU3ludGF4RXJyb3InKSB7XG4gICAgICAgICAgICB0aHJvdyBBeGlvc0Vycm9yLmZyb20oZSwgQXhpb3NFcnJvci5FUlJfQkFEX1JFU1BPTlNFLCB0aGlzLCBudWxsLCB0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICAvKipcbiAgICogQSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyB0byBhYm9ydCBhIHJlcXVlc3QuIElmIHNldCB0byAwIChkZWZhdWx0KSBhXG4gICAqIHRpbWVvdXQgaXMgbm90IGNyZWF0ZWQuXG4gICAqL1xuICB0aW1lb3V0OiAwLFxuXG4gIHhzcmZDb29raWVOYW1lOiAnWFNSRi1UT0tFTicsXG4gIHhzcmZIZWFkZXJOYW1lOiAnWC1YU1JGLVRPS0VOJyxcblxuICBtYXhDb250ZW50TGVuZ3RoOiAtMSxcbiAgbWF4Qm9keUxlbmd0aDogLTEsXG5cbiAgZW52OiB7XG4gICAgRm9ybURhdGE6IHJlcXVpcmUoJy4vZW52L0Zvcm1EYXRhJylcbiAgfSxcblxuICB2YWxpZGF0ZVN0YXR1czogZnVuY3Rpb24gdmFsaWRhdGVTdGF0dXMoc3RhdHVzKSB7XG4gICAgcmV0dXJuIHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwO1xuICB9LFxuXG4gIGhlYWRlcnM6IHtcbiAgICBjb21tb246IHtcbiAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qJ1xuICAgIH1cbiAgfVxufTtcblxudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB7fTtcbn0pO1xuXG51dGlscy5mb3JFYWNoKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZFdpdGhEYXRhKG1ldGhvZCkge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB1dGlscy5tZXJnZShERUZBVUxUX0NPTlRFTlRfVFlQRSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZhdWx0cztcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNpbGVudEpTT05QYXJzaW5nOiB0cnVlLFxuICBmb3JjZWRKU09OUGFyc2luZzogdHJ1ZSxcbiAgY2xhcmlmeVRpbWVvdXRFcnJvcjogZmFsc2Vcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgXCJ2ZXJzaW9uXCI6IFwiMC4yNy4yXCJcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQoZm4sIHRoaXNBcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIGVuY29kZSh2YWwpIHtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpLlxuICAgIHJlcGxhY2UoLyUzQS9naSwgJzonKS5cbiAgICByZXBsYWNlKC8lMjQvZywgJyQnKS5cbiAgICByZXBsYWNlKC8lMkMvZ2ksICcsJykuXG4gICAgcmVwbGFjZSgvJTIwL2csICcrJykuXG4gICAgcmVwbGFjZSgvJTVCL2dpLCAnWycpLlxuICAgIHJlcGxhY2UoLyU1RC9naSwgJ10nKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIFVSTCBieSBhcHBlbmRpbmcgcGFyYW1zIHRvIHRoZSBlbmRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBiYXNlIG9mIHRoZSB1cmwgKGUuZy4sIGh0dHA6Ly93d3cuZ29vZ2xlLmNvbSlcbiAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zXSBUaGUgcGFyYW1zIHRvIGJlIGFwcGVuZGVkXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIHVybFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJ1aWxkVVJMKHVybCwgcGFyYW1zLCBwYXJhbXNTZXJpYWxpemVyKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICBpZiAoIXBhcmFtcykge1xuICAgIHJldHVybiB1cmw7XG4gIH1cblxuICB2YXIgc2VyaWFsaXplZFBhcmFtcztcbiAgaWYgKHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFyYW1zU2VyaWFsaXplcihwYXJhbXMpO1xuICB9IGVsc2UgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykpIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFyYW1zLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHBhcnRzID0gW107XG5cbiAgICB1dGlscy5mb3JFYWNoKHBhcmFtcywgZnVuY3Rpb24gc2VyaWFsaXplKHZhbCwga2V5KSB7XG4gICAgICBpZiAodmFsID09PSBudWxsIHx8IHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHV0aWxzLmlzQXJyYXkodmFsKSkge1xuICAgICAgICBrZXkgPSBrZXkgKyAnW10nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gW3ZhbF07XG4gICAgICB9XG5cbiAgICAgIHV0aWxzLmZvckVhY2godmFsLCBmdW5jdGlvbiBwYXJzZVZhbHVlKHYpIHtcbiAgICAgICAgaWYgKHV0aWxzLmlzRGF0ZSh2KSkge1xuICAgICAgICAgIHYgPSB2LnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodXRpbHMuaXNPYmplY3QodikpIHtcbiAgICAgICAgICB2ID0gSlNPTi5zdHJpbmdpZnkodik7XG4gICAgICAgIH1cbiAgICAgICAgcGFydHMucHVzaChlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZSh2KSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJ0cy5qb2luKCcmJyk7XG4gIH1cblxuICBpZiAoc2VyaWFsaXplZFBhcmFtcykge1xuICAgIHZhciBoYXNobWFya0luZGV4ID0gdXJsLmluZGV4T2YoJyMnKTtcbiAgICBpZiAoaGFzaG1hcmtJbmRleCAhPT0gLTEpIHtcbiAgICAgIHVybCA9IHVybC5zbGljZSgwLCBoYXNobWFya0luZGV4KTtcbiAgICB9XG5cbiAgICB1cmwgKz0gKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIH1cblxuICByZXR1cm4gdXJsO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIHNwZWNpZmllZCBVUkxzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVsYXRpdmVVUkwgVGhlIHJlbGF0aXZlIFVSTFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIFVSTFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlbGF0aXZlVVJMKSB7XG4gIHJldHVybiByZWxhdGl2ZVVSTFxuICAgID8gYmFzZVVSTC5yZXBsYWNlKC9cXC8rJC8sICcnKSArICcvJyArIHJlbGF0aXZlVVJMLnJlcGxhY2UoL15cXC8rLywgJycpXG4gICAgOiBiYXNlVVJMO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIHN1cHBvcnQgZG9jdW1lbnQuY29va2llXG4gICAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShuYW1lLCB2YWx1ZSwgZXhwaXJlcywgcGF0aCwgZG9tYWluLCBzZWN1cmUpIHtcbiAgICAgICAgICB2YXIgY29va2llID0gW107XG4gICAgICAgICAgY29va2llLnB1c2gobmFtZSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzTnVtYmVyKGV4cGlyZXMpKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgnZXhwaXJlcz0nICsgbmV3IERhdGUoZXhwaXJlcykudG9HTVRTdHJpbmcoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKHBhdGgpKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgncGF0aD0nICsgcGF0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKGRvbWFpbikpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdkb21haW49JyArIGRvbWFpbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlY3VyZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ3NlY3VyZScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGNvb2tpZS5qb2luKCc7ICcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQobmFtZSkge1xuICAgICAgICAgIHZhciBtYXRjaCA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaChuZXcgUmVnRXhwKCcoXnw7XFxcXHMqKSgnICsgbmFtZSArICcpPShbXjtdKiknKSk7XG4gICAgICAgICAgcmV0dXJuIChtYXRjaCA/IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFszXSkgOiBudWxsKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShuYW1lKSB7XG4gICAgICAgICAgdGhpcy53cml0ZShuYW1lLCAnJywgRGF0ZS5ub3coKSAtIDg2NDAwMDAwKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnYgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gICAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSgpIHt9LFxuICAgICAgICByZWFkOiBmdW5jdGlvbiByZWFkKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7fVxuICAgICAgfTtcbiAgICB9KSgpXG4pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBYnNvbHV0ZVVSTCh1cmwpIHtcbiAgLy8gQSBVUkwgaXMgY29uc2lkZXJlZCBhYnNvbHV0ZSBpZiBpdCBiZWdpbnMgd2l0aCBcIjxzY2hlbWU+Oi8vXCIgb3IgXCIvL1wiIChwcm90b2NvbC1yZWxhdGl2ZSBVUkwpLlxuICAvLyBSRkMgMzk4NiBkZWZpbmVzIHNjaGVtZSBuYW1lIGFzIGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyBiZWdpbm5pbmcgd2l0aCBhIGxldHRlciBhbmQgZm9sbG93ZWRcbiAgLy8gYnkgYW55IGNvbWJpbmF0aW9uIG9mIGxldHRlcnMsIGRpZ2l0cywgcGx1cywgcGVyaW9kLCBvciBoeXBoZW4uXG4gIHJldHVybiAvXihbYS16XVthLXpcXGQrXFwtLl0qOik/XFwvXFwvL2kudGVzdCh1cmwpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgcGF5bG9hZCBpcyBhbiBlcnJvciB0aHJvd24gYnkgQXhpb3NcbiAqXG4gKiBAcGFyYW0geyp9IHBheWxvYWQgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBwYXlsb2FkIGlzIGFuIGVycm9yIHRocm93biBieSBBeGlvcywgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBeGlvc0Vycm9yKHBheWxvYWQpIHtcbiAgcmV0dXJuIHV0aWxzLmlzT2JqZWN0KHBheWxvYWQpICYmIChwYXlsb2FkLmlzQXhpb3NFcnJvciA9PT0gdHJ1ZSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKFxuICB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpID9cblxuICAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgaGF2ZSBmdWxsIHN1cHBvcnQgb2YgdGhlIEFQSXMgbmVlZGVkIHRvIHRlc3RcbiAgLy8gd2hldGhlciB0aGUgcmVxdWVzdCBVUkwgaXMgb2YgdGhlIHNhbWUgb3JpZ2luIGFzIGN1cnJlbnQgbG9jYXRpb24uXG4gICAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHZhciBtc2llID0gLyhtc2llfHRyaWRlbnQpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAgIHZhciB1cmxQYXJzaW5nTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgIHZhciBvcmlnaW5VUkw7XG5cbiAgICAgIC8qKlxuICAgICogUGFyc2UgYSBVUkwgdG8gZGlzY292ZXIgaXQncyBjb21wb25lbnRzXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBUaGUgVVJMIHRvIGJlIHBhcnNlZFxuICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAqL1xuICAgICAgZnVuY3Rpb24gcmVzb2x2ZVVSTCh1cmwpIHtcbiAgICAgICAgdmFyIGhyZWYgPSB1cmw7XG5cbiAgICAgICAgaWYgKG1zaWUpIHtcbiAgICAgICAgLy8gSUUgbmVlZHMgYXR0cmlidXRlIHNldCB0d2ljZSB0byBub3JtYWxpemUgcHJvcGVydGllc1xuICAgICAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuICAgICAgICAgIGhyZWYgPSB1cmxQYXJzaW5nTm9kZS5ocmVmO1xuICAgICAgICB9XG5cbiAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG5cbiAgICAgICAgLy8gdXJsUGFyc2luZ05vZGUgcHJvdmlkZXMgdGhlIFVybFV0aWxzIGludGVyZmFjZSAtIGh0dHA6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmx1dGlsc1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGhyZWY6IHVybFBhcnNpbmdOb2RlLmhyZWYsXG4gICAgICAgICAgcHJvdG9jb2w6IHVybFBhcnNpbmdOb2RlLnByb3RvY29sID8gdXJsUGFyc2luZ05vZGUucHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJykgOiAnJyxcbiAgICAgICAgICBob3N0OiB1cmxQYXJzaW5nTm9kZS5ob3N0LFxuICAgICAgICAgIHNlYXJjaDogdXJsUGFyc2luZ05vZGUuc2VhcmNoID8gdXJsUGFyc2luZ05vZGUuc2VhcmNoLnJlcGxhY2UoL15cXD8vLCAnJykgOiAnJyxcbiAgICAgICAgICBoYXNoOiB1cmxQYXJzaW5nTm9kZS5oYXNoID8gdXJsUGFyc2luZ05vZGUuaGFzaC5yZXBsYWNlKC9eIy8sICcnKSA6ICcnLFxuICAgICAgICAgIGhvc3RuYW1lOiB1cmxQYXJzaW5nTm9kZS5ob3N0bmFtZSxcbiAgICAgICAgICBwb3J0OiB1cmxQYXJzaW5nTm9kZS5wb3J0LFxuICAgICAgICAgIHBhdGhuYW1lOiAodXJsUGFyc2luZ05vZGUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpID9cbiAgICAgICAgICAgIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lIDpcbiAgICAgICAgICAgICcvJyArIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG9yaWdpblVSTCA9IHJlc29sdmVVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuXG4gICAgICAvKipcbiAgICAqIERldGVybWluZSBpZiBhIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luIGFzIHRoZSBjdXJyZW50IGxvY2F0aW9uXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RVUkwgVGhlIFVSTCB0byB0ZXN0XG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgKi9cbiAgICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4ocmVxdWVzdFVSTCkge1xuICAgICAgICB2YXIgcGFyc2VkID0gKHV0aWxzLmlzU3RyaW5nKHJlcXVlc3RVUkwpKSA/IHJlc29sdmVVUkwocmVxdWVzdFVSTCkgOiByZXF1ZXN0VVJMO1xuICAgICAgICByZXR1cm4gKHBhcnNlZC5wcm90b2NvbCA9PT0gb3JpZ2luVVJMLnByb3RvY29sICYmXG4gICAgICAgICAgICBwYXJzZWQuaG9zdCA9PT0gb3JpZ2luVVJMLmhvc3QpO1xuICAgICAgfTtcbiAgICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnZzICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAgIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgfSkoKVxuKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsIG5vcm1hbGl6ZWROYW1lKSB7XG4gIHV0aWxzLmZvckVhY2goaGVhZGVycywgZnVuY3Rpb24gcHJvY2Vzc0hlYWRlcih2YWx1ZSwgbmFtZSkge1xuICAgIGlmIChuYW1lICE9PSBub3JtYWxpemVkTmFtZSAmJiBuYW1lLnRvVXBwZXJDYXNlKCkgPT09IG5vcm1hbGl6ZWROYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgIGhlYWRlcnNbbm9ybWFsaXplZE5hbWVdID0gdmFsdWU7XG4gICAgICBkZWxldGUgaGVhZGVyc1tuYW1lXTtcbiAgICB9XG4gIH0pO1xufTtcbiIsIi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBzdHJpY3Rcbm1vZHVsZS5leHBvcnRzID0gbnVsbDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG4vLyBIZWFkZXJzIHdob3NlIGR1cGxpY2F0ZXMgYXJlIGlnbm9yZWQgYnkgbm9kZVxuLy8gYy5mLiBodHRwczovL25vZGVqcy5vcmcvYXBpL2h0dHAuaHRtbCNodHRwX21lc3NhZ2VfaGVhZGVyc1xudmFyIGlnbm9yZUR1cGxpY2F0ZU9mID0gW1xuICAnYWdlJywgJ2F1dGhvcml6YXRpb24nLCAnY29udGVudC1sZW5ndGgnLCAnY29udGVudC10eXBlJywgJ2V0YWcnLFxuICAnZXhwaXJlcycsICdmcm9tJywgJ2hvc3QnLCAnaWYtbW9kaWZpZWQtc2luY2UnLCAnaWYtdW5tb2RpZmllZC1zaW5jZScsXG4gICdsYXN0LW1vZGlmaWVkJywgJ2xvY2F0aW9uJywgJ21heC1mb3J3YXJkcycsICdwcm94eS1hdXRob3JpemF0aW9uJyxcbiAgJ3JlZmVyZXInLCAncmV0cnktYWZ0ZXInLCAndXNlci1hZ2VudCdcbl07XG5cbi8qKlxuICogUGFyc2UgaGVhZGVycyBpbnRvIGFuIG9iamVjdFxuICpcbiAqIGBgYFxuICogRGF0ZTogV2VkLCAyNyBBdWcgMjAxNCAwODo1ODo0OSBHTVRcbiAqIENvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vanNvblxuICogQ29ubmVjdGlvbjoga2VlcC1hbGl2ZVxuICogVHJhbnNmZXItRW5jb2Rpbmc6IGNodW5rZWRcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXJzIEhlYWRlcnMgbmVlZGluZyB0byBiZSBwYXJzZWRcbiAqIEByZXR1cm5zIHtPYmplY3R9IEhlYWRlcnMgcGFyc2VkIGludG8gYW4gb2JqZWN0XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VIZWFkZXJzKGhlYWRlcnMpIHtcbiAgdmFyIHBhcnNlZCA9IHt9O1xuICB2YXIga2V5O1xuICB2YXIgdmFsO1xuICB2YXIgaTtcblxuICBpZiAoIWhlYWRlcnMpIHsgcmV0dXJuIHBhcnNlZDsgfVxuXG4gIHV0aWxzLmZvckVhY2goaGVhZGVycy5zcGxpdCgnXFxuJyksIGZ1bmN0aW9uIHBhcnNlcihsaW5lKSB7XG4gICAgaSA9IGxpbmUuaW5kZXhPZignOicpO1xuICAgIGtleSA9IHV0aWxzLnRyaW0obGluZS5zdWJzdHIoMCwgaSkpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cihpICsgMSkpO1xuXG4gICAgaWYgKGtleSkge1xuICAgICAgaWYgKHBhcnNlZFtrZXldICYmIGlnbm9yZUR1cGxpY2F0ZU9mLmluZGV4T2Yoa2V5KSA+PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChrZXkgPT09ICdzZXQtY29va2llJykge1xuICAgICAgICBwYXJzZWRba2V5XSA9IChwYXJzZWRba2V5XSA/IHBhcnNlZFtrZXldIDogW10pLmNvbmNhdChbdmFsXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZWRba2V5XSA9IHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gKyAnLCAnICsgdmFsIDogdmFsO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHBhcnNlZDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VQcm90b2NvbCh1cmwpIHtcbiAgdmFyIG1hdGNoID0gL14oWy0rXFx3XXsxLDI1fSkoOj9cXC9cXC98OikvLmV4ZWModXJsKTtcbiAgcmV0dXJuIG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTeW50YWN0aWMgc3VnYXIgZm9yIGludm9raW5nIGEgZnVuY3Rpb24gYW5kIGV4cGFuZGluZyBhbiBhcnJheSBmb3IgYXJndW1lbnRzLlxuICpcbiAqIENvbW1vbiB1c2UgY2FzZSB3b3VsZCBiZSB0byB1c2UgYEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseWAuXG4gKlxuICogIGBgYGpzXG4gKiAgZnVuY3Rpb24gZih4LCB5LCB6KSB7fVxuICogIHZhciBhcmdzID0gWzEsIDIsIDNdO1xuICogIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gKiAgYGBgXG4gKlxuICogV2l0aCBgc3ByZWFkYCB0aGlzIGV4YW1wbGUgY2FuIGJlIHJlLXdyaXR0ZW4uXG4gKlxuICogIGBgYGpzXG4gKiAgc3ByZWFkKGZ1bmN0aW9uKHgsIHksIHopIHt9KShbMSwgMiwgM10pO1xuICogIGBgYFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3ByZWFkKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKGFycikge1xuICAgIHJldHVybiBjYWxsYmFjay5hcHBseShudWxsLCBhcnIpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgZGF0YSBvYmplY3QgdG8gRm9ybURhdGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7P09iamVjdH0gW2Zvcm1EYXRhXVxuICogQHJldHVybnMge09iamVjdH1cbiAqKi9cblxuZnVuY3Rpb24gdG9Gb3JtRGF0YShvYmosIGZvcm1EYXRhKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICBmb3JtRGF0YSA9IGZvcm1EYXRhIHx8IG5ldyBGb3JtRGF0YSgpO1xuXG4gIHZhciBzdGFjayA9IFtdO1xuXG4gIGZ1bmN0aW9uIGNvbnZlcnRWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuICcnO1xuXG4gICAgaWYgKHV0aWxzLmlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZS50b0lTT1N0cmluZygpO1xuICAgIH1cblxuICAgIGlmICh1dGlscy5pc0FycmF5QnVmZmVyKHZhbHVlKSB8fCB1dGlscy5pc1R5cGVkQXJyYXkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIEJsb2IgPT09ICdmdW5jdGlvbicgPyBuZXcgQmxvYihbdmFsdWVdKSA6IEJ1ZmZlci5mcm9tKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBidWlsZChkYXRhLCBwYXJlbnRLZXkpIHtcbiAgICBpZiAodXRpbHMuaXNQbGFpbk9iamVjdChkYXRhKSB8fCB1dGlscy5pc0FycmF5KGRhdGEpKSB7XG4gICAgICBpZiAoc3RhY2suaW5kZXhPZihkYXRhKSAhPT0gLTEpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0NpcmN1bGFyIHJlZmVyZW5jZSBkZXRlY3RlZCBpbiAnICsgcGFyZW50S2V5KTtcbiAgICAgIH1cblxuICAgICAgc3RhY2sucHVzaChkYXRhKTtcblxuICAgICAgdXRpbHMuZm9yRWFjaChkYXRhLCBmdW5jdGlvbiBlYWNoKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgaWYgKHV0aWxzLmlzVW5kZWZpbmVkKHZhbHVlKSkgcmV0dXJuO1xuICAgICAgICB2YXIgZnVsbEtleSA9IHBhcmVudEtleSA/IHBhcmVudEtleSArICcuJyArIGtleSA6IGtleTtcbiAgICAgICAgdmFyIGFycjtcblxuICAgICAgICBpZiAodmFsdWUgJiYgIXBhcmVudEtleSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgaWYgKHV0aWxzLmVuZHNXaXRoKGtleSwgJ3t9JykpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgdmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh1dGlscy5lbmRzV2l0aChrZXksICdbXScpICYmIChhcnIgPSB1dGlscy50b0FycmF5KHZhbHVlKSkpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gICAgICAgICAgICBhcnIuZm9yRWFjaChmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgICAhdXRpbHMuaXNVbmRlZmluZWQoZWwpICYmIGZvcm1EYXRhLmFwcGVuZChmdWxsS2V5LCBjb252ZXJ0VmFsdWUoZWwpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJ1aWxkKHZhbHVlLCBmdWxsS2V5KTtcbiAgICAgIH0pO1xuXG4gICAgICBzdGFjay5wb3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9ybURhdGEuYXBwZW5kKHBhcmVudEtleSwgY29udmVydFZhbHVlKGRhdGEpKTtcbiAgICB9XG4gIH1cblxuICBidWlsZChvYmopO1xuXG4gIHJldHVybiBmb3JtRGF0YTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0Zvcm1EYXRhO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVkVSU0lPTiA9IHJlcXVpcmUoJy4uL2Vudi9kYXRhJykudmVyc2lvbjtcbnZhciBBeGlvc0Vycm9yID0gcmVxdWlyZSgnLi4vY29yZS9BeGlvc0Vycm9yJyk7XG5cbnZhciB2YWxpZGF0b3JzID0ge307XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5bJ29iamVjdCcsICdib29sZWFuJywgJ251bWJlcicsICdmdW5jdGlvbicsICdzdHJpbmcnLCAnc3ltYm9sJ10uZm9yRWFjaChmdW5jdGlvbih0eXBlLCBpKSB7XG4gIHZhbGlkYXRvcnNbdHlwZV0gPSBmdW5jdGlvbiB2YWxpZGF0b3IodGhpbmcpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaW5nID09PSB0eXBlIHx8ICdhJyArIChpIDwgMSA/ICduICcgOiAnICcpICsgdHlwZTtcbiAgfTtcbn0pO1xuXG52YXIgZGVwcmVjYXRlZFdhcm5pbmdzID0ge307XG5cbi8qKlxuICogVHJhbnNpdGlvbmFsIG9wdGlvbiB2YWxpZGF0b3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb258Ym9vbGVhbj99IHZhbGlkYXRvciAtIHNldCB0byBmYWxzZSBpZiB0aGUgdHJhbnNpdGlvbmFsIG9wdGlvbiBoYXMgYmVlbiByZW1vdmVkXG4gKiBAcGFyYW0ge3N0cmluZz99IHZlcnNpb24gLSBkZXByZWNhdGVkIHZlcnNpb24gLyByZW1vdmVkIHNpbmNlIHZlcnNpb25cbiAqIEBwYXJhbSB7c3RyaW5nP30gbWVzc2FnZSAtIHNvbWUgbWVzc2FnZSB3aXRoIGFkZGl0aW9uYWwgaW5mb1xuICogQHJldHVybnMge2Z1bmN0aW9ufVxuICovXG52YWxpZGF0b3JzLnRyYW5zaXRpb25hbCA9IGZ1bmN0aW9uIHRyYW5zaXRpb25hbCh2YWxpZGF0b3IsIHZlcnNpb24sIG1lc3NhZ2UpIHtcbiAgZnVuY3Rpb24gZm9ybWF0TWVzc2FnZShvcHQsIGRlc2MpIHtcbiAgICByZXR1cm4gJ1tBeGlvcyB2JyArIFZFUlNJT04gKyAnXSBUcmFuc2l0aW9uYWwgb3B0aW9uIFxcJycgKyBvcHQgKyAnXFwnJyArIGRlc2MgKyAobWVzc2FnZSA/ICcuICcgKyBtZXNzYWdlIDogJycpO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvcHQsIG9wdHMpIHtcbiAgICBpZiAodmFsaWRhdG9yID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoXG4gICAgICAgIGZvcm1hdE1lc3NhZ2Uob3B0LCAnIGhhcyBiZWVuIHJlbW92ZWQnICsgKHZlcnNpb24gPyAnIGluICcgKyB2ZXJzaW9uIDogJycpKSxcbiAgICAgICAgQXhpb3NFcnJvci5FUlJfREVQUkVDQVRFRFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodmVyc2lvbiAmJiAhZGVwcmVjYXRlZFdhcm5pbmdzW29wdF0pIHtcbiAgICAgIGRlcHJlY2F0ZWRXYXJuaW5nc1tvcHRdID0gdHJ1ZTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGZvcm1hdE1lc3NhZ2UoXG4gICAgICAgICAgb3B0LFxuICAgICAgICAgICcgaGFzIGJlZW4gZGVwcmVjYXRlZCBzaW5jZSB2JyArIHZlcnNpb24gKyAnIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5lYXIgZnV0dXJlJ1xuICAgICAgICApXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB2YWxpZGF0b3IgPyB2YWxpZGF0b3IodmFsdWUsIG9wdCwgb3B0cykgOiB0cnVlO1xuICB9O1xufTtcblxuLyoqXG4gKiBBc3NlcnQgb2JqZWN0J3MgcHJvcGVydGllcyB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtvYmplY3R9IHNjaGVtYVxuICogQHBhcmFtIHtib29sZWFuP30gYWxsb3dVbmtub3duXG4gKi9cblxuZnVuY3Rpb24gYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBzY2hlbWEsIGFsbG93VW5rbm93bikge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QnLCBBeGlvc0Vycm9yLkVSUl9CQURfT1BUSU9OX1ZBTFVFKTtcbiAgfVxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tID4gMCkge1xuICAgIHZhciBvcHQgPSBrZXlzW2ldO1xuICAgIHZhciB2YWxpZGF0b3IgPSBzY2hlbWFbb3B0XTtcbiAgICBpZiAodmFsaWRhdG9yKSB7XG4gICAgICB2YXIgdmFsdWUgPSBvcHRpb25zW29wdF07XG4gICAgICB2YXIgcmVzdWx0ID0gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWxpZGF0b3IodmFsdWUsIG9wdCwgb3B0aW9ucyk7XG4gICAgICBpZiAocmVzdWx0ICE9PSB0cnVlKSB7XG4gICAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKCdvcHRpb24gJyArIG9wdCArICcgbXVzdCBiZSAnICsgcmVzdWx0LCBBeGlvc0Vycm9yLkVSUl9CQURfT1BUSU9OX1ZBTFVFKTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoYWxsb3dVbmtub3duICE9PSB0cnVlKSB7XG4gICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcignVW5rbm93biBvcHRpb24gJyArIG9wdCwgQXhpb3NFcnJvci5FUlJfQkFEX09QVElPTik7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhc3NlcnRPcHRpb25zOiBhc3NlcnRPcHRpb25zLFxuICB2YWxpZGF0b3JzOiB2YWxpZGF0b3JzXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJy4vaGVscGVycy9iaW5kJyk7XG5cbi8vIHV0aWxzIGlzIGEgbGlicmFyeSBvZiBnZW5lcmljIGhlbHBlciBmdW5jdGlvbnMgbm9uLXNwZWNpZmljIHRvIGF4aW9zXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG52YXIga2luZE9mID0gKGZ1bmN0aW9uKGNhY2hlKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gIHJldHVybiBmdW5jdGlvbih0aGluZykge1xuICAgIHZhciBzdHIgPSB0b1N0cmluZy5jYWxsKHRoaW5nKTtcbiAgICByZXR1cm4gY2FjaGVbc3RyXSB8fCAoY2FjaGVbc3RyXSA9IHN0ci5zbGljZSg4LCAtMSkudG9Mb3dlckNhc2UoKSk7XG4gIH07XG59KShPYmplY3QuY3JlYXRlKG51bGwpKTtcblxuZnVuY3Rpb24ga2luZE9mVGVzdCh0eXBlKSB7XG4gIHR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBmdW5jdGlvbiBpc0tpbmRPZih0aGluZykge1xuICAgIHJldHVybiBraW5kT2YodGhpbmcpID09PSB0eXBlO1xuICB9O1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXksIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5KHZhbCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIHVuZGVmaW5lZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0J1ZmZlcih2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiAhaXNVbmRlZmluZWQodmFsKSAmJiB2YWwuY29uc3RydWN0b3IgIT09IG51bGwgJiYgIWlzVW5kZWZpbmVkKHZhbC5jb25zdHJ1Y3RvcilcbiAgICAmJiB0eXBlb2YgdmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlcih2YWwpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbnZhciBpc0FycmF5QnVmZmVyID0ga2luZE9mVGVzdCgnQXJyYXlCdWZmZXInKTtcblxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KHZhbCkge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpICYmIChBcnJheUJ1ZmZlci5pc1ZpZXcpKSB7XG4gICAgcmVzdWx0ID0gQXJyYXlCdWZmZXIuaXNWaWV3KHZhbCk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gKHZhbCkgJiYgKHZhbC5idWZmZXIpICYmIChpc0FycmF5QnVmZmVyKHZhbC5idWZmZXIpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJpbmcsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgTnVtYmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBOdW1iZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc051bWJlcih2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgcGxhaW4gT2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHBsYWluIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsKSB7XG4gIGlmIChraW5kT2YodmFsKSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbCk7XG4gIHJldHVybiBwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRGF0ZVxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBEYXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xudmFyIGlzRGF0ZSA9IGtpbmRPZlRlc3QoJ0RhdGUnKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZpbGVcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbnZhciBpc0ZpbGUgPSBraW5kT2ZUZXN0KCdGaWxlJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCbG9iXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJsb2IsIG90aGVyd2lzZSBmYWxzZVxuICovXG52YXIgaXNCbG9iID0ga2luZE9mVGVzdCgnQmxvYicpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZUxpc3RcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbnZhciBpc0ZpbGVMaXN0ID0ga2luZE9mVGVzdCgnRmlsZUxpc3QnKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGdW5jdGlvbiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJlYW1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmVhbSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyZWFtKHZhbCkge1xuICByZXR1cm4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC5waXBlKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZvcm1EYXRhXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRoaW5nIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBGb3JtRGF0YSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRm9ybURhdGEodGhpbmcpIHtcbiAgdmFyIHBhdHRlcm4gPSAnW29iamVjdCBGb3JtRGF0YV0nO1xuICByZXR1cm4gdGhpbmcgJiYgKFxuICAgICh0eXBlb2YgRm9ybURhdGEgPT09ICdmdW5jdGlvbicgJiYgdGhpbmcgaW5zdGFuY2VvZiBGb3JtRGF0YSkgfHxcbiAgICB0b1N0cmluZy5jYWxsKHRoaW5nKSA9PT0gcGF0dGVybiB8fFxuICAgIChpc0Z1bmN0aW9uKHRoaW5nLnRvU3RyaW5nKSAmJiB0aGluZy50b1N0cmluZygpID09PSBwYXR0ZXJuKVxuICApO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdFxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG52YXIgaXNVUkxTZWFyY2hQYXJhbXMgPSBraW5kT2ZUZXN0KCdVUkxTZWFyY2hQYXJhbXMnKTtcblxuLyoqXG4gKiBUcmltIGV4Y2VzcyB3aGl0ZXNwYWNlIG9mZiB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBTdHJpbmcgdG8gdHJpbVxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFN0cmluZyBmcmVlZCBvZiBleGNlc3Mgd2hpdGVzcGFjZVxuICovXG5mdW5jdGlvbiB0cmltKHN0cikge1xuICByZXR1cm4gc3RyLnRyaW0gPyBzdHIudHJpbSgpIDogc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgd2UncmUgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAqXG4gKiBUaGlzIGFsbG93cyBheGlvcyB0byBydW4gaW4gYSB3ZWIgd29ya2VyLCBhbmQgcmVhY3QtbmF0aXZlLlxuICogQm90aCBlbnZpcm9ubWVudHMgc3VwcG9ydCBYTUxIdHRwUmVxdWVzdCwgYnV0IG5vdCBmdWxseSBzdGFuZGFyZCBnbG9iYWxzLlxuICpcbiAqIHdlYiB3b3JrZXJzOlxuICogIHR5cGVvZiB3aW5kb3cgLT4gdW5kZWZpbmVkXG4gKiAgdHlwZW9mIGRvY3VtZW50IC0+IHVuZGVmaW5lZFxuICpcbiAqIHJlYWN0LW5hdGl2ZTpcbiAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnUmVhY3ROYXRpdmUnXG4gKiBuYXRpdmVzY3JpcHRcbiAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnTmF0aXZlU2NyaXB0JyBvciAnTlMnXG4gKi9cbmZ1bmN0aW9uIGlzU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgKG5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdOYXRpdmVTY3JpcHQnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdOUycpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG4gICk7XG59XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFuIEFycmF5IG9yIGFuIE9iamVjdCBpbnZva2luZyBhIGZ1bmN0aW9uIGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgYG9iamAgaXMgYW4gQXJyYXkgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBpbmRleCwgYW5kIGNvbXBsZXRlIGFycmF5IGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgJ29iaicgaXMgYW4gT2JqZWN0IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwga2V5LCBhbmQgY29tcGxldGUgb2JqZWN0IGZvciBlYWNoIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmogVGhlIG9iamVjdCB0byBpdGVyYXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIGZvciBlYWNoIGl0ZW1cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChvYmosIGZuKSB7XG4gIC8vIERvbid0IGJvdGhlciBpZiBubyB2YWx1ZSBwcm92aWRlZFxuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRm9yY2UgYW4gYXJyYXkgaWYgbm90IGFscmVhZHkgc29tZXRoaW5nIGl0ZXJhYmxlXG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIG9iaiA9IFtvYmpdO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBhcnJheSB2YWx1ZXNcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2ldLCBpLCBvYmopO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgb2JqZWN0IGtleXNcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICBmbi5jYWxsKG51bGwsIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjZXB0cyB2YXJhcmdzIGV4cGVjdGluZyBlYWNoIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCwgdGhlblxuICogaW1tdXRhYmx5IG1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiBlYWNoIG9iamVjdCBhbmQgcmV0dXJucyByZXN1bHQuXG4gKlxuICogV2hlbiBtdWx0aXBsZSBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUga2V5IHRoZSBsYXRlciBvYmplY3QgaW5cbiAqIHRoZSBhcmd1bWVudHMgbGlzdCB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcmVzdWx0ID0gbWVyZ2Uoe2ZvbzogMTIzfSwge2ZvbzogNDU2fSk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuZm9vKTsgLy8gb3V0cHV0cyA0NTZcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBtZXJnZVxuICogQHJldHVybnMge09iamVjdH0gUmVzdWx0IG9mIGFsbCBtZXJnZSBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIG1lcmdlKC8qIG9iajEsIG9iajIsIG9iajMsIC4uLiAqLykge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QocmVzdWx0W2tleV0pICYmIGlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZShyZXN1bHRba2V5XSwgdmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZSh7fSwgdmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWwuc2xpY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWw7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZm9yRWFjaChhcmd1bWVudHNbaV0sIGFzc2lnblZhbHVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEV4dGVuZHMgb2JqZWN0IGEgYnkgbXV0YWJseSBhZGRpbmcgdG8gaXQgdGhlIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGEgVGhlIG9iamVjdCB0byBiZSBleHRlbmRlZFxuICogQHBhcmFtIHtPYmplY3R9IGIgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogQHBhcmFtIHtPYmplY3R9IHRoaXNBcmcgVGhlIG9iamVjdCB0byBiaW5kIGZ1bmN0aW9uIHRvXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSByZXN1bHRpbmcgdmFsdWUgb2Ygb2JqZWN0IGFcbiAqL1xuZnVuY3Rpb24gZXh0ZW5kKGEsIGIsIHRoaXNBcmcpIHtcbiAgZm9yRWFjaChiLCBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuICAgIGlmICh0aGlzQXJnICYmIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFba2V5XSA9IGJpbmQodmFsLCB0aGlzQXJnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYVtrZXldID0gdmFsO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBhO1xufVxuXG4vKipcbiAqIFJlbW92ZSBieXRlIG9yZGVyIG1hcmtlci4gVGhpcyBjYXRjaGVzIEVGIEJCIEJGICh0aGUgVVRGLTggQk9NKVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50IHdpdGggQk9NXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGNvbnRlbnQgdmFsdWUgd2l0aG91dCBCT01cbiAqL1xuZnVuY3Rpb24gc3RyaXBCT00oY29udGVudCkge1xuICBpZiAoY29udGVudC5jaGFyQ29kZUF0KDApID09PSAweEZFRkYpIHtcbiAgICBjb250ZW50ID0gY29udGVudC5zbGljZSgxKTtcbiAgfVxuICByZXR1cm4gY29udGVudDtcbn1cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gW3Byb3BzXVxuICogQHBhcmFtIHtvYmplY3R9IFtkZXNjcmlwdG9yc11cbiAqL1xuXG5mdW5jdGlvbiBpbmhlcml0cyhjb25zdHJ1Y3Rvciwgc3VwZXJDb25zdHJ1Y3RvciwgcHJvcHMsIGRlc2NyaXB0b3JzKSB7XG4gIGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIGRlc2NyaXB0b3JzKTtcbiAgY29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY29uc3RydWN0b3I7XG4gIHByb3BzICYmIE9iamVjdC5hc3NpZ24oY29uc3RydWN0b3IucHJvdG90eXBlLCBwcm9wcyk7XG59XG5cbi8qKlxuICogUmVzb2x2ZSBvYmplY3Qgd2l0aCBkZWVwIHByb3RvdHlwZSBjaGFpbiB0byBhIGZsYXQgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlT2JqIHNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZGVzdE9ial1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmaWx0ZXJdXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIHRvRmxhdE9iamVjdChzb3VyY2VPYmosIGRlc3RPYmosIGZpbHRlcikge1xuICB2YXIgcHJvcHM7XG4gIHZhciBpO1xuICB2YXIgcHJvcDtcbiAgdmFyIG1lcmdlZCA9IHt9O1xuXG4gIGRlc3RPYmogPSBkZXN0T2JqIHx8IHt9O1xuXG4gIGRvIHtcbiAgICBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZU9iaik7XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgaWYgKCFtZXJnZWRbcHJvcF0pIHtcbiAgICAgICAgZGVzdE9ialtwcm9wXSA9IHNvdXJjZU9ialtwcm9wXTtcbiAgICAgICAgbWVyZ2VkW3Byb3BdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgc291cmNlT2JqID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHNvdXJjZU9iaik7XG4gIH0gd2hpbGUgKHNvdXJjZU9iaiAmJiAoIWZpbHRlciB8fCBmaWx0ZXIoc291cmNlT2JqLCBkZXN0T2JqKSkgJiYgc291cmNlT2JqICE9PSBPYmplY3QucHJvdG90eXBlKTtcblxuICByZXR1cm4gZGVzdE9iajtcbn1cblxuLypcbiAqIGRldGVybWluZXMgd2hldGhlciBhIHN0cmluZyBlbmRzIHdpdGggdGhlIGNoYXJhY3RlcnMgb2YgYSBzcGVjaWZpZWQgc3RyaW5nXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VhcmNoU3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gW3Bvc2l0aW9uPSAwXVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGVuZHNXaXRoKHN0ciwgc2VhcmNoU3RyaW5nLCBwb3NpdGlvbikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQgfHwgcG9zaXRpb24gPiBzdHIubGVuZ3RoKSB7XG4gICAgcG9zaXRpb24gPSBzdHIubGVuZ3RoO1xuICB9XG4gIHBvc2l0aW9uIC09IHNlYXJjaFN0cmluZy5sZW5ndGg7XG4gIHZhciBsYXN0SW5kZXggPSBzdHIuaW5kZXhPZihzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKTtcbiAgcmV0dXJuIGxhc3RJbmRleCAhPT0gLTEgJiYgbGFzdEluZGV4ID09PSBwb3NpdGlvbjtcbn1cblxuXG4vKipcbiAqIFJldHVybnMgbmV3IGFycmF5IGZyb20gYXJyYXkgbGlrZSBvYmplY3RcbiAqIEBwYXJhbSB7Kn0gW3RoaW5nXVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5mdW5jdGlvbiB0b0FycmF5KHRoaW5nKSB7XG4gIGlmICghdGhpbmcpIHJldHVybiBudWxsO1xuICB2YXIgaSA9IHRoaW5nLmxlbmd0aDtcbiAgaWYgKGlzVW5kZWZpbmVkKGkpKSByZXR1cm4gbnVsbDtcbiAgdmFyIGFyciA9IG5ldyBBcnJheShpKTtcbiAgd2hpbGUgKGktLSA+IDApIHtcbiAgICBhcnJbaV0gPSB0aGluZ1tpXTtcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xudmFyIGlzVHlwZWRBcnJheSA9IChmdW5jdGlvbihUeXBlZEFycmF5KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gIHJldHVybiBmdW5jdGlvbih0aGluZykge1xuICAgIHJldHVybiBUeXBlZEFycmF5ICYmIHRoaW5nIGluc3RhbmNlb2YgVHlwZWRBcnJheTtcbiAgfTtcbn0pKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVWludDhBcnJheSkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNBcnJheTogaXNBcnJheSxcbiAgaXNBcnJheUJ1ZmZlcjogaXNBcnJheUJ1ZmZlcixcbiAgaXNCdWZmZXI6IGlzQnVmZmVyLFxuICBpc0Zvcm1EYXRhOiBpc0Zvcm1EYXRhLFxuICBpc0FycmF5QnVmZmVyVmlldzogaXNBcnJheUJ1ZmZlclZpZXcsXG4gIGlzU3RyaW5nOiBpc1N0cmluZyxcbiAgaXNOdW1iZXI6IGlzTnVtYmVyLFxuICBpc09iamVjdDogaXNPYmplY3QsXG4gIGlzUGxhaW5PYmplY3Q6IGlzUGxhaW5PYmplY3QsXG4gIGlzVW5kZWZpbmVkOiBpc1VuZGVmaW5lZCxcbiAgaXNEYXRlOiBpc0RhdGUsXG4gIGlzRmlsZTogaXNGaWxlLFxuICBpc0Jsb2I6IGlzQmxvYixcbiAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcbiAgaXNTdHJlYW06IGlzU3RyZWFtLFxuICBpc1VSTFNlYXJjaFBhcmFtczogaXNVUkxTZWFyY2hQYXJhbXMsXG4gIGlzU3RhbmRhcmRCcm93c2VyRW52OiBpc1N0YW5kYXJkQnJvd3NlckVudixcbiAgZm9yRWFjaDogZm9yRWFjaCxcbiAgbWVyZ2U6IG1lcmdlLFxuICBleHRlbmQ6IGV4dGVuZCxcbiAgdHJpbTogdHJpbSxcbiAgc3RyaXBCT006IHN0cmlwQk9NLFxuICBpbmhlcml0czogaW5oZXJpdHMsXG4gIHRvRmxhdE9iamVjdDogdG9GbGF0T2JqZWN0LFxuICBraW5kT2Y6IGtpbmRPZixcbiAga2luZE9mVGVzdDoga2luZE9mVGVzdCxcbiAgZW5kc1dpdGg6IGVuZHNXaXRoLFxuICB0b0FycmF5OiB0b0FycmF5LFxuICBpc1R5cGVkQXJyYXk6IGlzVHlwZWRBcnJheSxcbiAgaXNGaWxlTGlzdDogaXNGaWxlTGlzdFxufTtcbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbnZhciBLX01BWF9MRU5HVEggPSAweDdmZmZmZmZmXG5leHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEhcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdFxuICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlXG4gKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXG4gKiAoU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzgpLiBJRSAxMCBsYWNrcyBzdXBwb3J0XG4gKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgY29uc29sZS5lcnJvcihcbiAgICAnVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5ICcgK1xuICAgICdgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LidcbiAgKVxufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0geyBfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH0gfVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5idWZmZXJcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldFxuICB9XG59KVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBsZW5ndGggKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICE9IG51bGwgJiZcbiAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG5mdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHZhbHVlKVxuICB9XG5cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gICAgKVxuICB9XG5cbiAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgIClcbiAgfVxuXG4gIHZhciB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZiAmJiB2YWx1ZS52YWx1ZU9mKClcbiAgaWYgKHZhbHVlT2YgIT0gbnVsbCAmJiB2YWx1ZU9mICE9PSB2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZU9mLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICB2YXIgYiA9IGZyb21PYmplY3QodmFsdWUpXG4gIGlmIChiKSByZXR1cm4gYlxuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9QcmltaXRpdmUgIT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oXG4gICAgICB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCdzdHJpbmcnKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoXG4gICAgKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICApXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbkJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbkJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBzaXplICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgdmFyIGJ1ZlxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgYnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgfVxuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgfVxuXG4gIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiZcbiAgICBiICE9PSBCdWZmZXIucHJvdG90eXBlIC8vIHNvIEJ1ZmZlci5pc0J1ZmZlcihCdWZmZXIucHJvdG90eXBlKSB3aWxsIGJlIGZhbHNlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkgYSA9IEJ1ZmZlci5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpXG4gIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKSBiID0gQnVmZmVyLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aClcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICApXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBidWYgPSBCdWZmZXIuZnJvbShidWYpXG4gICAgfVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc3RyaW5nXG4gICAgKVxuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIG11c3RNYXRjaCA9IChhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWUpXG4gIGlmICghbXVzdE1hdGNoICYmIGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkge1xuICAgICAgICAgIHJldHVybiBtdXN0TWF0Y2ggPyAtMSA6IHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nXG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICckMSAnKS50cmltKClcbiAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoaXNJbnN0YW5jZSh0YXJnZXQsIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGFyZ2V0ID0gQnVmZmVyLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aClcbiAgfVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHRhcmdldClcbiAgICApXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0IC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXInKVxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFVzZSBidWlsdC1pbiB3aGVuIGF2YWlsYWJsZSwgbWlzc2luZyBmcm9tIElFMTFcbiAgICB0aGlzLmNvcHlXaXRoaW4odGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpXG4gIH0gZWxzZSBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmICgoZW5jb2RpbmcgPT09ICd1dGY4JyAmJiBjb2RlIDwgMTI4KSB8fFxuICAgICAgICAgIGVuY29kaW5nID09PSAnbGF0aW4xJykge1xuICAgICAgICAvLyBGYXN0IHBhdGg6IElmIGB2YWxgIGZpdHMgaW50byBhIHNpbmdsZSBieXRlLCB1c2UgdGhhdCBudW1lcmljIHZhbHVlLlxuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXG4gIHN0ciA9IHN0ci5zcGxpdCgnPScpWzBdXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSBvYmplY3RzIGZyb20gb3RoZXIgY29udGV4dHMgKGkuZS4gaWZyYW1lcykgZG8gbm90IHBhc3Ncbi8vIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2sgYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgb2YgdGhhdCB0eXBlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5mdW5jdGlvbiBpc0luc3RhbmNlIChvYmosIHR5cGUpIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHR5cGUgfHxcbiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZSlcbn1cbmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcbiAgLy8gRm9yIElFMTEgc3VwcG9ydFxuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsIi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCIvL1xuLy8gVEhJUyBGSUxFIElTIEFVVE9NQVRJQ0FMTFkgR0VORVJBVEVEISBETyBOT1QgRURJVCBCWSBIQU5EIVxuLy9cbjtcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KClcbiAgICAgICAgOiB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWRcbiAgICAgICAgICAgID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgICAgICAgICAgIC8vIGNmLiBodHRwczovL2dpdGh1Yi5jb20vZGFua29nYWkvanMtYmFzZTY0L2lzc3Vlcy8xMTlcbiAgICAgICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gZXhpc3RpbmcgdmVyc2lvbiBmb3Igbm9Db25mbGljdCgpXG4gICAgICAgICAgICAgICAgdmFyIF9CYXNlNjQgPSBnbG9iYWwuQmFzZTY0O1xuICAgICAgICAgICAgICAgIHZhciBnQmFzZTY0ID0gZmFjdG9yeSgpO1xuICAgICAgICAgICAgICAgIGdCYXNlNjQubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsLkJhc2U2NCA9IF9CYXNlNjQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnQmFzZTY0O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKGdsb2JhbC5NZXRlb3IpIHsgLy8gTWV0ZW9yLmpzXG4gICAgICAgICAgICAgICAgICAgIEJhc2U2NCA9IGdCYXNlNjQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdsb2JhbC5CYXNlNjQgPSBnQmFzZTY0O1xuICAgICAgICAgICAgfSkoKTtcbn0oKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGZcbiAgICA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93XG4gICAgICAgIDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxcbiAgICAgICAgICAgIDogdGhpcyksIGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLyoqXG4gICAgICogIGJhc2U2NC50c1xuICAgICAqXG4gICAgICogIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgMy1DbGF1c2UgTGljZW5zZS5cbiAgICAgKiAgICBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gICAgICpcbiAgICAgKiAgUmVmZXJlbmNlczpcbiAgICAgKiAgICBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NFxuICAgICAqXG4gICAgICogQGF1dGhvciBEYW4gS29nYWkgKGh0dHBzOi8vZ2l0aHViLmNvbS9kYW5rb2dhaSlcbiAgICAgKi9cbiAgICB2YXIgdmVyc2lvbiA9ICczLjcuMic7XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgdXNlIGxvd2VyY2FzZSBgdmVyc2lvbmAuXG4gICAgICovXG4gICAgdmFyIFZFUlNJT04gPSB2ZXJzaW9uO1xuICAgIHZhciBfaGFzYXRvYiA9IHR5cGVvZiBhdG9iID09PSAnZnVuY3Rpb24nO1xuICAgIHZhciBfaGFzYnRvYSA9IHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nO1xuICAgIHZhciBfaGFzQnVmZmVyID0gdHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJztcbiAgICB2YXIgX1REID0gdHlwZW9mIFRleHREZWNvZGVyID09PSAnZnVuY3Rpb24nID8gbmV3IFRleHREZWNvZGVyKCkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIF9URSA9IHR5cGVvZiBUZXh0RW5jb2RlciA9PT0gJ2Z1bmN0aW9uJyA/IG5ldyBUZXh0RW5jb2RlcigpIDogdW5kZWZpbmVkO1xuICAgIHZhciBiNjRjaCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG4gICAgdmFyIGI2NGNocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGI2NGNoKTtcbiAgICB2YXIgYjY0dGFiID0gKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciB0YWIgPSB7fTtcbiAgICAgICAgYS5mb3JFYWNoKGZ1bmN0aW9uIChjLCBpKSB7IHJldHVybiB0YWJbY10gPSBpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRhYjtcbiAgICB9KShiNjRjaHMpO1xuICAgIHZhciBiNjRyZSA9IC9eKD86W0EtWmEtelxcZCtcXC9dezR9KSo/KD86W0EtWmEtelxcZCtcXC9dezJ9KD86PT0pP3xbQS1aYS16XFxkK1xcL117M309Pyk/JC87XG4gICAgdmFyIF9mcm9tQ0MgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmJpbmQoU3RyaW5nKTtcbiAgICB2YXIgX1U4QWZyb20gPSB0eXBlb2YgVWludDhBcnJheS5mcm9tID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gVWludDhBcnJheS5mcm9tLmJpbmQoVWludDhBcnJheSlcbiAgICAgICAgOiBmdW5jdGlvbiAoaXQsIGZuKSB7XG4gICAgICAgICAgICBpZiAoZm4gPT09IHZvaWQgMCkgeyBmbiA9IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4OyB9OyB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaXQsIDApLm1hcChmbikpO1xuICAgICAgICB9O1xuICAgIHZhciBfbWtVcmlTYWZlID0gZnVuY3Rpb24gKHNyYykgeyByZXR1cm4gc3JjXG4gICAgICAgIC5yZXBsYWNlKC89L2csICcnKS5yZXBsYWNlKC9bK1xcL10vZywgZnVuY3Rpb24gKG0wKSB7IHJldHVybiBtMCA9PSAnKycgPyAnLScgOiAnXyc7IH0pOyB9O1xuICAgIHZhciBfdGlkeUI2NCA9IGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnJlcGxhY2UoL1teQS1aYS16MC05XFwrXFwvXS9nLCAnJyk7IH07XG4gICAgLyoqXG4gICAgICogcG9seWZpbGwgdmVyc2lvbiBvZiBgYnRvYWBcbiAgICAgKi9cbiAgICB2YXIgYnRvYVBvbHlmaWxsID0gZnVuY3Rpb24gKGJpbikge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygncG9seWZpbGxlZCcpO1xuICAgICAgICB2YXIgdTMyLCBjMCwgYzEsIGMyLCBhc2MgPSAnJztcbiAgICAgICAgdmFyIHBhZCA9IGJpbi5sZW5ndGggJSAzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJpbi5sZW5ndGg7KSB7XG4gICAgICAgICAgICBpZiAoKGMwID0gYmluLmNoYXJDb2RlQXQoaSsrKSkgPiAyNTUgfHxcbiAgICAgICAgICAgICAgICAoYzEgPSBiaW4uY2hhckNvZGVBdChpKyspKSA+IDI1NSB8fFxuICAgICAgICAgICAgICAgIChjMiA9IGJpbi5jaGFyQ29kZUF0KGkrKykpID4gMjU1KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgY2hhcmFjdGVyIGZvdW5kJyk7XG4gICAgICAgICAgICB1MzIgPSAoYzAgPDwgMTYpIHwgKGMxIDw8IDgpIHwgYzI7XG4gICAgICAgICAgICBhc2MgKz0gYjY0Y2hzW3UzMiA+PiAxOCAmIDYzXVxuICAgICAgICAgICAgICAgICsgYjY0Y2hzW3UzMiA+PiAxMiAmIDYzXVxuICAgICAgICAgICAgICAgICsgYjY0Y2hzW3UzMiA+PiA2ICYgNjNdXG4gICAgICAgICAgICAgICAgKyBiNjRjaHNbdTMyICYgNjNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYWQgPyBhc2Muc2xpY2UoMCwgcGFkIC0gMykgKyBcIj09PVwiLnN1YnN0cmluZyhwYWQpIDogYXNjO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogZG9lcyB3aGF0IGB3aW5kb3cuYnRvYWAgb2Ygd2ViIGJyb3dzZXJzIGRvLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBiaW4gYmluYXJ5IHN0cmluZ1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IEJhc2U2NC1lbmNvZGVkIHN0cmluZ1xuICAgICAqL1xuICAgIHZhciBfYnRvYSA9IF9oYXNidG9hID8gZnVuY3Rpb24gKGJpbikgeyByZXR1cm4gYnRvYShiaW4pOyB9XG4gICAgICAgIDogX2hhc0J1ZmZlciA/IGZ1bmN0aW9uIChiaW4pIHsgcmV0dXJuIEJ1ZmZlci5mcm9tKGJpbiwgJ2JpbmFyeScpLnRvU3RyaW5nKCdiYXNlNjQnKTsgfVxuICAgICAgICAgICAgOiBidG9hUG9seWZpbGw7XG4gICAgdmFyIF9mcm9tVWludDhBcnJheSA9IF9oYXNCdWZmZXJcbiAgICAgICAgPyBmdW5jdGlvbiAodThhKSB7IHJldHVybiBCdWZmZXIuZnJvbSh1OGEpLnRvU3RyaW5nKCdiYXNlNjQnKTsgfVxuICAgICAgICA6IGZ1bmN0aW9uICh1OGEpIHtcbiAgICAgICAgICAgIC8vIGNmLiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMjcxMDAwMS9ob3ctdG8tY29udmVydC11aW50OC1hcnJheS10by1iYXNlNjQtZW5jb2RlZC1zdHJpbmcvMTI3MTMzMjYjMTI3MTMzMjZcbiAgICAgICAgICAgIHZhciBtYXhhcmdzID0gMHgxMDAwO1xuICAgICAgICAgICAgdmFyIHN0cnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdThhLmxlbmd0aDsgaSA8IGw7IGkgKz0gbWF4YXJncykge1xuICAgICAgICAgICAgICAgIHN0cnMucHVzaChfZnJvbUNDLmFwcGx5KG51bGwsIHU4YS5zdWJhcnJheShpLCBpICsgbWF4YXJncykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfYnRvYShzdHJzLmpvaW4oJycpKTtcbiAgICAgICAgfTtcbiAgICAvKipcbiAgICAgKiBjb252ZXJ0cyBhIFVpbnQ4QXJyYXkgdG8gYSBCYXNlNjQgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VybHNhZmVdIFVSTC1hbmQtZmlsZW5hbWUtc2FmZSBhIGxhIFJGQzQ2NDggwqc1XG4gICAgICogQHJldHVybnMge3N0cmluZ30gQmFzZTY0IHN0cmluZ1xuICAgICAqL1xuICAgIHZhciBmcm9tVWludDhBcnJheSA9IGZ1bmN0aW9uICh1OGEsIHVybHNhZmUpIHtcbiAgICAgICAgaWYgKHVybHNhZmUgPT09IHZvaWQgMCkgeyB1cmxzYWZlID0gZmFsc2U7IH1cbiAgICAgICAgcmV0dXJuIHVybHNhZmUgPyBfbWtVcmlTYWZlKF9mcm9tVWludDhBcnJheSh1OGEpKSA6IF9mcm9tVWludDhBcnJheSh1OGEpO1xuICAgIH07XG4gICAgLy8gVGhpcyB0cmljayBpcyBmb3VuZCBicm9rZW4gaHR0cHM6Ly9naXRodWIuY29tL2RhbmtvZ2FpL2pzLWJhc2U2NC9pc3N1ZXMvMTMwXG4gICAgLy8gY29uc3QgdXRvYiA9IChzcmM6IHN0cmluZykgPT4gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHNyYykpO1xuICAgIC8vIHJldmVydGluZyBnb29kIG9sZCBmYXRpb25lZCByZWdleHBcbiAgICB2YXIgY2JfdXRvYiA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHZhciBjYyA9IGMuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIHJldHVybiBjYyA8IDB4ODAgPyBjXG4gICAgICAgICAgICAgICAgOiBjYyA8IDB4ODAwID8gKF9mcm9tQ0MoMHhjMCB8IChjYyA+Pj4gNikpXG4gICAgICAgICAgICAgICAgICAgICsgX2Zyb21DQygweDgwIHwgKGNjICYgMHgzZikpKVxuICAgICAgICAgICAgICAgICAgICA6IChfZnJvbUNDKDB4ZTAgfCAoKGNjID4+PiAxMikgJiAweDBmKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICsgX2Zyb21DQygweDgwIHwgKChjYyA+Pj4gNikgJiAweDNmKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICsgX2Zyb21DQygweDgwIHwgKGNjICYgMHgzZikpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjYyA9IDB4MTAwMDBcbiAgICAgICAgICAgICAgICArIChjLmNoYXJDb2RlQXQoMCkgLSAweEQ4MDApICogMHg0MDBcbiAgICAgICAgICAgICAgICArIChjLmNoYXJDb2RlQXQoMSkgLSAweERDMDApO1xuICAgICAgICAgICAgcmV0dXJuIChfZnJvbUNDKDB4ZjAgfCAoKGNjID4+PiAxOCkgJiAweDA3KSlcbiAgICAgICAgICAgICAgICArIF9mcm9tQ0MoMHg4MCB8ICgoY2MgPj4+IDEyKSAmIDB4M2YpKVxuICAgICAgICAgICAgICAgICsgX2Zyb21DQygweDgwIHwgKChjYyA+Pj4gNikgJiAweDNmKSlcbiAgICAgICAgICAgICAgICArIF9mcm9tQ0MoMHg4MCB8IChjYyAmIDB4M2YpKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZV91dG9iID0gL1tcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRkZdfFteXFx4MDAtXFx4N0ZdL2c7XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgc2hvdWxkIGhhdmUgYmVlbiBpbnRlcm5hbCB1c2Ugb25seS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3JjIFVURi04IHN0cmluZ1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFVURi0xNiBzdHJpbmdcbiAgICAgKi9cbiAgICB2YXIgdXRvYiA9IGZ1bmN0aW9uICh1KSB7IHJldHVybiB1LnJlcGxhY2UocmVfdXRvYiwgY2JfdXRvYik7IH07XG4gICAgLy9cbiAgICB2YXIgX2VuY29kZSA9IF9oYXNCdWZmZXJcbiAgICAgICAgPyBmdW5jdGlvbiAocykgeyByZXR1cm4gQnVmZmVyLmZyb20ocywgJ3V0ZjgnKS50b1N0cmluZygnYmFzZTY0Jyk7IH1cbiAgICAgICAgOiBfVEVcbiAgICAgICAgICAgID8gZnVuY3Rpb24gKHMpIHsgcmV0dXJuIF9mcm9tVWludDhBcnJheShfVEUuZW5jb2RlKHMpKTsgfVxuICAgICAgICAgICAgOiBmdW5jdGlvbiAocykgeyByZXR1cm4gX2J0b2EodXRvYihzKSk7IH07XG4gICAgLyoqXG4gICAgICogY29udmVydHMgYSBVVEYtOC1lbmNvZGVkIHN0cmluZyB0byBhIEJhc2U2NCBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbdXJsc2FmZV0gaWYgYHRydWVgIG1ha2UgdGhlIHJlc3VsdCBVUkwtc2FmZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IEJhc2U2NCBzdHJpbmdcbiAgICAgKi9cbiAgICB2YXIgZW5jb2RlID0gZnVuY3Rpb24gKHNyYywgdXJsc2FmZSkge1xuICAgICAgICBpZiAodXJsc2FmZSA9PT0gdm9pZCAwKSB7IHVybHNhZmUgPSBmYWxzZTsgfVxuICAgICAgICByZXR1cm4gdXJsc2FmZVxuICAgICAgICAgICAgPyBfbWtVcmlTYWZlKF9lbmNvZGUoc3JjKSlcbiAgICAgICAgICAgIDogX2VuY29kZShzcmMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogY29udmVydHMgYSBVVEYtOC1lbmNvZGVkIHN0cmluZyB0byBVUkwtc2FmZSBCYXNlNjQgUkZDNDY0OCDCpzUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gQmFzZTY0IHN0cmluZ1xuICAgICAqL1xuICAgIHZhciBlbmNvZGVVUkkgPSBmdW5jdGlvbiAoc3JjKSB7IHJldHVybiBlbmNvZGUoc3JjLCB0cnVlKTsgfTtcbiAgICAvLyBUaGlzIHRyaWNrIGlzIGZvdW5kIGJyb2tlbiBodHRwczovL2dpdGh1Yi5jb20vZGFua29nYWkvanMtYmFzZTY0L2lzc3Vlcy8xMzBcbiAgICAvLyBjb25zdCBidG91ID0gKHNyYzogc3RyaW5nKSA9PiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKHNyYykpO1xuICAgIC8vIHJldmVydGluZyBnb29kIG9sZCBmYXRpb25lZCByZWdleHBcbiAgICB2YXIgcmVfYnRvdSA9IC9bXFx4QzAtXFx4REZdW1xceDgwLVxceEJGXXxbXFx4RTAtXFx4RUZdW1xceDgwLVxceEJGXXsyfXxbXFx4RjAtXFx4RjddW1xceDgwLVxceEJGXXszfS9nO1xuICAgIHZhciBjYl9idG91ID0gZnVuY3Rpb24gKGNjY2MpIHtcbiAgICAgICAgc3dpdGNoIChjY2NjLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHZhciBjcCA9ICgoMHgwNyAmIGNjY2MuY2hhckNvZGVBdCgwKSkgPDwgMTgpXG4gICAgICAgICAgICAgICAgICAgIHwgKCgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDEpKSA8PCAxMilcbiAgICAgICAgICAgICAgICAgICAgfCAoKDB4M2YgJiBjY2NjLmNoYXJDb2RlQXQoMikpIDw8IDYpXG4gICAgICAgICAgICAgICAgICAgIHwgKDB4M2YgJiBjY2NjLmNoYXJDb2RlQXQoMykpLCBvZmZzZXQgPSBjcCAtIDB4MTAwMDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChfZnJvbUNDKChvZmZzZXQgPj4+IDEwKSArIDB4RDgwMClcbiAgICAgICAgICAgICAgICAgICAgKyBfZnJvbUNDKChvZmZzZXQgJiAweDNGRikgKyAweERDMDApKTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2Zyb21DQygoKDB4MGYgJiBjY2NjLmNoYXJDb2RlQXQoMCkpIDw8IDEyKVxuICAgICAgICAgICAgICAgICAgICB8ICgoMHgzZiAmIGNjY2MuY2hhckNvZGVBdCgxKSkgPDwgNilcbiAgICAgICAgICAgICAgICAgICAgfCAoMHgzZiAmIGNjY2MuY2hhckNvZGVBdCgyKSkpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2Zyb21DQygoKDB4MWYgJiBjY2NjLmNoYXJDb2RlQXQoMCkpIDw8IDYpXG4gICAgICAgICAgICAgICAgICAgIHwgKDB4M2YgJiBjY2NjLmNoYXJDb2RlQXQoMSkpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgc2hvdWxkIGhhdmUgYmVlbiBpbnRlcm5hbCB1c2Ugb25seS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3JjIFVURi0xNiBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBVVEYtOCBzdHJpbmdcbiAgICAgKi9cbiAgICB2YXIgYnRvdSA9IGZ1bmN0aW9uIChiKSB7IHJldHVybiBiLnJlcGxhY2UocmVfYnRvdSwgY2JfYnRvdSk7IH07XG4gICAgLyoqXG4gICAgICogcG9seWZpbGwgdmVyc2lvbiBvZiBgYXRvYmBcbiAgICAgKi9cbiAgICB2YXIgYXRvYlBvbHlmaWxsID0gZnVuY3Rpb24gKGFzYykge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygncG9seWZpbGxlZCcpO1xuICAgICAgICBhc2MgPSBhc2MucmVwbGFjZSgvXFxzKy9nLCAnJyk7XG4gICAgICAgIGlmICghYjY0cmUudGVzdChhc2MpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWFsZm9ybWVkIGJhc2U2NC4nKTtcbiAgICAgICAgYXNjICs9ICc9PScuc2xpY2UoMiAtIChhc2MubGVuZ3RoICYgMykpO1xuICAgICAgICB2YXIgdTI0LCBiaW4gPSAnJywgcjEsIHIyO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFzYy5sZW5ndGg7KSB7XG4gICAgICAgICAgICB1MjQgPSBiNjR0YWJbYXNjLmNoYXJBdChpKyspXSA8PCAxOFxuICAgICAgICAgICAgICAgIHwgYjY0dGFiW2FzYy5jaGFyQXQoaSsrKV0gPDwgMTJcbiAgICAgICAgICAgICAgICB8IChyMSA9IGI2NHRhYlthc2MuY2hhckF0KGkrKyldKSA8PCA2XG4gICAgICAgICAgICAgICAgfCAocjIgPSBiNjR0YWJbYXNjLmNoYXJBdChpKyspXSk7XG4gICAgICAgICAgICBiaW4gKz0gcjEgPT09IDY0ID8gX2Zyb21DQyh1MjQgPj4gMTYgJiAyNTUpXG4gICAgICAgICAgICAgICAgOiByMiA9PT0gNjQgPyBfZnJvbUNDKHUyNCA+PiAxNiAmIDI1NSwgdTI0ID4+IDggJiAyNTUpXG4gICAgICAgICAgICAgICAgICAgIDogX2Zyb21DQyh1MjQgPj4gMTYgJiAyNTUsIHUyNCA+PiA4ICYgMjU1LCB1MjQgJiAyNTUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiaW47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBkb2VzIHdoYXQgYHdpbmRvdy5hdG9iYCBvZiB3ZWIgYnJvd3NlcnMgZG8uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFzYyBCYXNlNjQtZW5jb2RlZCBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBiaW5hcnkgc3RyaW5nXG4gICAgICovXG4gICAgdmFyIF9hdG9iID0gX2hhc2F0b2IgPyBmdW5jdGlvbiAoYXNjKSB7IHJldHVybiBhdG9iKF90aWR5QjY0KGFzYykpOyB9XG4gICAgICAgIDogX2hhc0J1ZmZlciA/IGZ1bmN0aW9uIChhc2MpIHsgcmV0dXJuIEJ1ZmZlci5mcm9tKGFzYywgJ2Jhc2U2NCcpLnRvU3RyaW5nKCdiaW5hcnknKTsgfVxuICAgICAgICAgICAgOiBhdG9iUG9seWZpbGw7XG4gICAgLy9cbiAgICB2YXIgX3RvVWludDhBcnJheSA9IF9oYXNCdWZmZXJcbiAgICAgICAgPyBmdW5jdGlvbiAoYSkgeyByZXR1cm4gX1U4QWZyb20oQnVmZmVyLmZyb20oYSwgJ2Jhc2U2NCcpKTsgfVxuICAgICAgICA6IGZ1bmN0aW9uIChhKSB7IHJldHVybiBfVThBZnJvbShfYXRvYihhKSwgZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMuY2hhckNvZGVBdCgwKTsgfSk7IH07XG4gICAgLyoqXG4gICAgICogY29udmVydHMgYSBCYXNlNjQgc3RyaW5nIHRvIGEgVWludDhBcnJheS5cbiAgICAgKi9cbiAgICB2YXIgdG9VaW50OEFycmF5ID0gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIF90b1VpbnQ4QXJyYXkoX3VuVVJJKGEpKTsgfTtcbiAgICAvL1xuICAgIHZhciBfZGVjb2RlID0gX2hhc0J1ZmZlclxuICAgICAgICA/IGZ1bmN0aW9uIChhKSB7IHJldHVybiBCdWZmZXIuZnJvbShhLCAnYmFzZTY0JykudG9TdHJpbmcoJ3V0ZjgnKTsgfVxuICAgICAgICA6IF9URFxuICAgICAgICAgICAgPyBmdW5jdGlvbiAoYSkgeyByZXR1cm4gX1RELmRlY29kZShfdG9VaW50OEFycmF5KGEpKTsgfVxuICAgICAgICAgICAgOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gYnRvdShfYXRvYihhKSk7IH07XG4gICAgdmFyIF91blVSSSA9IGZ1bmN0aW9uIChhKSB7IHJldHVybiBfdGlkeUI2NChhLnJlcGxhY2UoL1stX10vZywgZnVuY3Rpb24gKG0wKSB7IHJldHVybiBtMCA9PSAnLScgPyAnKycgOiAnLyc7IH0pKTsgfTtcbiAgICAvKipcbiAgICAgKiBjb252ZXJ0cyBhIEJhc2U2NCBzdHJpbmcgdG8gYSBVVEYtOCBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNyYyBCYXNlNjQgc3RyaW5nLiAgQm90aCBub3JtYWwgYW5kIFVSTC1zYWZlIGFyZSBzdXBwb3J0ZWRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBVVEYtOCBzdHJpbmdcbiAgICAgKi9cbiAgICB2YXIgZGVjb2RlID0gZnVuY3Rpb24gKHNyYykgeyByZXR1cm4gX2RlY29kZShfdW5VUkkoc3JjKSk7IH07XG4gICAgLyoqXG4gICAgICogY2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHZhbGlkIEJhc2U2NCBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3JjIGEgdmFsdWUgdG8gY2hlY2tcbiAgICAgICovXG4gICAgdmFyIGlzVmFsaWQgPSBmdW5jdGlvbiAoc3JjKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3JjICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIHMgPSBzcmMucmVwbGFjZSgvXFxzKy9nLCAnJykucmVwbGFjZSgvPXswLDJ9JC8sICcnKTtcbiAgICAgICAgcmV0dXJuICEvW15cXHMwLTlhLXpBLVpcXCsvXS8udGVzdChzKSB8fCAhL1teXFxzMC05YS16QS1aXFwtX10vLnRlc3Qocyk7XG4gICAgfTtcbiAgICAvL1xuICAgIHZhciBfbm9FbnVtID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiB2LCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogZXh0ZW5kIFN0cmluZy5wcm90b3R5cGUgd2l0aCByZWxldmFudCBtZXRob2RzXG4gICAgICovXG4gICAgdmFyIGV4dGVuZFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hZGQgPSBmdW5jdGlvbiAobmFtZSwgYm9keSkgeyByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0cmluZy5wcm90b3R5cGUsIG5hbWUsIF9ub0VudW0oYm9keSkpOyB9O1xuICAgICAgICBfYWRkKCdmcm9tQmFzZTY0JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb2RlKHRoaXMpOyB9KTtcbiAgICAgICAgX2FkZCgndG9CYXNlNjQnLCBmdW5jdGlvbiAodXJsc2FmZSkgeyByZXR1cm4gZW5jb2RlKHRoaXMsIHVybHNhZmUpOyB9KTtcbiAgICAgICAgX2FkZCgndG9CYXNlNjRVUkknLCBmdW5jdGlvbiAoKSB7IHJldHVybiBlbmNvZGUodGhpcywgdHJ1ZSk7IH0pO1xuICAgICAgICBfYWRkKCd0b0Jhc2U2NFVSTCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuY29kZSh0aGlzLCB0cnVlKTsgfSk7XG4gICAgICAgIF9hZGQoJ3RvVWludDhBcnJheScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRvVWludDhBcnJheSh0aGlzKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBleHRlbmQgVWludDhBcnJheS5wcm90b3R5cGUgd2l0aCByZWxldmFudCBtZXRob2RzXG4gICAgICovXG4gICAgdmFyIGV4dGVuZFVpbnQ4QXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYWRkID0gZnVuY3Rpb24gKG5hbWUsIGJvZHkpIHsgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVaW50OEFycmF5LnByb3RvdHlwZSwgbmFtZSwgX25vRW51bShib2R5KSk7IH07XG4gICAgICAgIF9hZGQoJ3RvQmFzZTY0JywgZnVuY3Rpb24gKHVybHNhZmUpIHsgcmV0dXJuIGZyb21VaW50OEFycmF5KHRoaXMsIHVybHNhZmUpOyB9KTtcbiAgICAgICAgX2FkZCgndG9CYXNlNjRVUkknLCBmdW5jdGlvbiAoKSB7IHJldHVybiBmcm9tVWludDhBcnJheSh0aGlzLCB0cnVlKTsgfSk7XG4gICAgICAgIF9hZGQoJ3RvQmFzZTY0VVJMJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gZnJvbVVpbnQ4QXJyYXkodGhpcywgdHJ1ZSk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogZXh0ZW5kIEJ1aWx0aW4gcHJvdG90eXBlcyB3aXRoIHJlbGV2YW50IG1ldGhvZHNcbiAgICAgKi9cbiAgICB2YXIgZXh0ZW5kQnVpbHRpbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGV4dGVuZFN0cmluZygpO1xuICAgICAgICBleHRlbmRVaW50OEFycmF5KCk7XG4gICAgfTtcbiAgICB2YXIgZ0Jhc2U2NCA9IHtcbiAgICAgICAgdmVyc2lvbjogdmVyc2lvbixcbiAgICAgICAgVkVSU0lPTjogVkVSU0lPTixcbiAgICAgICAgYXRvYjogX2F0b2IsXG4gICAgICAgIGF0b2JQb2x5ZmlsbDogYXRvYlBvbHlmaWxsLFxuICAgICAgICBidG9hOiBfYnRvYSxcbiAgICAgICAgYnRvYVBvbHlmaWxsOiBidG9hUG9seWZpbGwsXG4gICAgICAgIGZyb21CYXNlNjQ6IGRlY29kZSxcbiAgICAgICAgdG9CYXNlNjQ6IGVuY29kZSxcbiAgICAgICAgZW5jb2RlOiBlbmNvZGUsXG4gICAgICAgIGVuY29kZVVSSTogZW5jb2RlVVJJLFxuICAgICAgICBlbmNvZGVVUkw6IGVuY29kZVVSSSxcbiAgICAgICAgdXRvYjogdXRvYixcbiAgICAgICAgYnRvdTogYnRvdSxcbiAgICAgICAgZGVjb2RlOiBkZWNvZGUsXG4gICAgICAgIGlzVmFsaWQ6IGlzVmFsaWQsXG4gICAgICAgIGZyb21VaW50OEFycmF5OiBmcm9tVWludDhBcnJheSxcbiAgICAgICAgdG9VaW50OEFycmF5OiB0b1VpbnQ4QXJyYXksXG4gICAgICAgIGV4dGVuZFN0cmluZzogZXh0ZW5kU3RyaW5nLFxuICAgICAgICBleHRlbmRVaW50OEFycmF5OiBleHRlbmRVaW50OEFycmF5LFxuICAgICAgICBleHRlbmRCdWlsdGluczogZXh0ZW5kQnVpbHRpbnNcbiAgICB9O1xuICAgIC8vXG4gICAgLy8gZXhwb3J0IEJhc2U2NCB0byB0aGUgbmFtZXNwYWNlXG4gICAgLy9cbiAgICAvLyBFUzUgaXMgeWV0IHRvIGhhdmUgT2JqZWN0LmFzc2lnbigpIHRoYXQgbWF5IG1ha2UgdHJhbnNwaWxlcnMgdW5oYXBweS5cbiAgICAvLyBnQmFzZTY0LkJhc2U2NCA9IE9iamVjdC5hc3NpZ24oe30sIGdCYXNlNjQpO1xuICAgIGdCYXNlNjQuQmFzZTY0ID0ge307XG4gICAgT2JqZWN0LmtleXMoZ0Jhc2U2NCkuZm9yRWFjaChmdW5jdGlvbiAoaykgeyByZXR1cm4gZ0Jhc2U2NC5CYXNlNjRba10gPSBnQmFzZTY0W2tdOyB9KTtcbiAgICByZXR1cm4gZ0Jhc2U2NDtcbn0pKTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gICwgdW5kZWY7XG5cbi8qKlxuICogRGVjb2RlIGEgVVJJIGVuY29kZWQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgVVJJIGVuY29kZWQgc3RyaW5nLlxuICogQHJldHVybnMge1N0cmluZ3xOdWxsfSBUaGUgZGVjb2RlZCBzdHJpbmcuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChpbnB1dC5yZXBsYWNlKC9cXCsvZywgJyAnKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGVuY29kZSBhIGdpdmVuIGlucHV0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIHRoYXQgbmVlZHMgdG8gYmUgZW5jb2RlZC5cbiAqIEByZXR1cm5zIHtTdHJpbmd8TnVsbH0gVGhlIGVuY29kZWQgc3RyaW5nLlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuICB0cnkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoaW5wdXQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBTaW1wbGUgcXVlcnkgc3RyaW5nIHBhcnNlci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcXVlcnkgVGhlIHF1ZXJ5IHN0cmluZyB0aGF0IG5lZWRzIHRvIGJlIHBhcnNlZC5cbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBxdWVyeXN0cmluZyhxdWVyeSkge1xuICB2YXIgcGFyc2VyID0gLyhbXj0/IyZdKyk9PyhbXiZdKikvZ1xuICAgICwgcmVzdWx0ID0ge31cbiAgICAsIHBhcnQ7XG5cbiAgd2hpbGUgKHBhcnQgPSBwYXJzZXIuZXhlYyhxdWVyeSkpIHtcbiAgICB2YXIga2V5ID0gZGVjb2RlKHBhcnRbMV0pXG4gICAgICAsIHZhbHVlID0gZGVjb2RlKHBhcnRbMl0pO1xuXG4gICAgLy9cbiAgICAvLyBQcmV2ZW50IG92ZXJyaWRpbmcgb2YgZXhpc3RpbmcgcHJvcGVydGllcy4gVGhpcyBlbnN1cmVzIHRoYXQgYnVpbGQtaW5cbiAgICAvLyBtZXRob2RzIGxpa2UgYHRvU3RyaW5nYCBvciBfX3Byb3RvX18gYXJlIG5vdCBvdmVycmlkZW4gYnkgbWFsaWNpb3VzXG4gICAgLy8gcXVlcnlzdHJpbmdzLlxuICAgIC8vXG4gICAgLy8gSW4gdGhlIGNhc2UgaWYgZmFpbGVkIGRlY29kaW5nLCB3ZSB3YW50IHRvIG9taXQgdGhlIGtleS92YWx1ZSBwYWlyc1xuICAgIC8vIGZyb20gdGhlIHJlc3VsdC5cbiAgICAvL1xuICAgIGlmIChrZXkgPT09IG51bGwgfHwgdmFsdWUgPT09IG51bGwgfHwga2V5IGluIHJlc3VsdCkgY29udGludWU7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgcXVlcnkgc3RyaW5nIHRvIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIE9iamVjdCB0aGF0IHNob3VsZCBiZSB0cmFuc2Zvcm1lZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXggT3B0aW9uYWwgcHJlZml4LlxuICogQHJldHVybnMge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5naWZ5KG9iaiwgcHJlZml4KSB7XG4gIHByZWZpeCA9IHByZWZpeCB8fCAnJztcblxuICB2YXIgcGFpcnMgPSBbXVxuICAgICwgdmFsdWVcbiAgICAsIGtleTtcblxuICAvL1xuICAvLyBPcHRpb25hbGx5IHByZWZpeCB3aXRoIGEgJz8nIGlmIG5lZWRlZFxuICAvL1xuICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBwcmVmaXgpIHByZWZpeCA9ICc/JztcblxuICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICBpZiAoaGFzLmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICB2YWx1ZSA9IG9ialtrZXldO1xuXG4gICAgICAvL1xuICAgICAgLy8gRWRnZSBjYXNlcyB3aGVyZSB3ZSBhY3R1YWxseSB3YW50IHRvIGVuY29kZSB0aGUgdmFsdWUgdG8gYW4gZW1wdHlcbiAgICAgIC8vIHN0cmluZyBpbnN0ZWFkIG9mIHRoZSBzdHJpbmdpZmllZCB2YWx1ZS5cbiAgICAgIC8vXG4gICAgICBpZiAoIXZhbHVlICYmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWYgfHwgaXNOYU4odmFsdWUpKSkge1xuICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSBlbmNvZGUoa2V5KTtcbiAgICAgIHZhbHVlID0gZW5jb2RlKHZhbHVlKTtcblxuICAgICAgLy9cbiAgICAgIC8vIElmIHdlIGZhaWxlZCB0byBlbmNvZGUgdGhlIHN0cmluZ3MsIHdlIHNob3VsZCBiYWlsIG91dCBhcyB3ZSBkb24ndFxuICAgICAgLy8gd2FudCB0byBhZGQgaW52YWxpZCBzdHJpbmdzIHRvIHRoZSBxdWVyeS5cbiAgICAgIC8vXG4gICAgICBpZiAoa2V5ID09PSBudWxsIHx8IHZhbHVlID09PSBudWxsKSBjb250aW51ZTtcbiAgICAgIHBhaXJzLnB1c2goa2V5ICsnPScrIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFpcnMubGVuZ3RoID8gcHJlZml4ICsgcGFpcnMuam9pbignJicpIDogJyc7XG59XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG5leHBvcnRzLnN0cmluZ2lmeSA9IHF1ZXJ5c3RyaW5naWZ5O1xuZXhwb3J0cy5wYXJzZSA9IHF1ZXJ5c3RyaW5nO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgcnVudGltZSA9IChmdW5jdGlvbiAoZXhwb3J0cykge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBvYmpba2V5XTtcbiAgfVxuICB0cnkge1xuICAgIC8vIElFIDggaGFzIGEgYnJva2VuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0aGF0IG9ubHkgd29ya3Mgb24gRE9NIG9iamVjdHMuXG4gICAgZGVmaW5lKHt9LCBcIlwiKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGVmaW5lID0gZnVuY3Rpb24ob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgZXhwb3J0cy53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgZGVmaW5lKEl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBkZWZpbmUoR3AsIFwiY29uc3RydWN0b3JcIiwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICBkZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgR2VuZXJhdG9yRnVuY3Rpb24pO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShcbiAgICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSxcbiAgICB0b1N0cmluZ1RhZ1N5bWJvbCxcbiAgICBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgKTtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBkZWZpbmUocHJvdG90eXBlLCBtZXRob2QsIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKTtcbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yLCBQcm9taXNlSW1wbCkge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAvLyBJZiBhIHJlamVjdGVkIFByb21pc2Ugd2FzIHlpZWxkZWQsIHRocm93IHRoZSByZWplY3Rpb24gYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgaGFuZGxlZCB0aGVyZS5cbiAgICAgICAgICByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIGRlZmluZShBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSwgYXN5bmNJdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KTtcbiAgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkge1xuICAgIGlmIChQcm9taXNlSW1wbCA9PT0gdm9pZCAwKSBQcm9taXNlSW1wbCA9IFByb21pc2U7XG5cbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksXG4gICAgICBQcm9taXNlSW1wbFxuICAgICk7XG5cbiAgICByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgLy8gTm90ZTogW1wicmV0dXJuXCJdIG11c3QgYmUgdXNlZCBmb3IgRVMzIHBhcnNpbmcgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgZGVmaW5lKEdwLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JcIik7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBkZWZpbmUoR3AsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG5cbiAgZGVmaW5lKEdwLCBcInRvU3RyaW5nXCIsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9KTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBleHBvcnRzLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGVcbiAgLy8gb3Igbm90LCByZXR1cm4gdGhlIHJ1bnRpbWUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGRlY2xhcmUgdGhlIHZhcmlhYmxlXG4gIC8vIHJlZ2VuZXJhdG9yUnVudGltZSBpbiB0aGUgb3V0ZXIgc2NvcGUsIHdoaWNoIGFsbG93cyB0aGlzIG1vZHVsZSB0byBiZVxuICAvLyBpbmplY3RlZCBlYXNpbHkgYnkgYGJpbi9yZWdlbmVyYXRvciAtLWluY2x1ZGUtcnVudGltZSBzY3JpcHQuanNgLlxuICByZXR1cm4gZXhwb3J0cztcblxufShcbiAgLy8gSWYgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlLCB1c2UgbW9kdWxlLmV4cG9ydHNcbiAgLy8gYXMgdGhlIHJlZ2VuZXJhdG9yUnVudGltZSBuYW1lc3BhY2UuIE90aGVyd2lzZSBjcmVhdGUgYSBuZXcgZW1wdHlcbiAgLy8gb2JqZWN0LiBFaXRoZXIgd2F5LCB0aGUgcmVzdWx0aW5nIG9iamVjdCB3aWxsIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZVxuICAvLyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIHZhcmlhYmxlIGF0IHRoZSB0b3Agb2YgdGhpcyBmaWxlLlxuICB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiID8gbW9kdWxlLmV4cG9ydHMgOiB7fVxuKSk7XG5cbnRyeSB7XG4gIHJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG59IGNhdGNoIChhY2NpZGVudGFsU3RyaWN0TW9kZSkge1xuICAvLyBUaGlzIG1vZHVsZSBzaG91bGQgbm90IGJlIHJ1bm5pbmcgaW4gc3RyaWN0IG1vZGUsIHNvIHRoZSBhYm92ZVxuICAvLyBhc3NpZ25tZW50IHNob3VsZCBhbHdheXMgd29yayB1bmxlc3Mgc29tZXRoaW5nIGlzIG1pc2NvbmZpZ3VyZWQuIEp1c3RcbiAgLy8gaW4gY2FzZSBydW50aW1lLmpzIGFjY2lkZW50YWxseSBydW5zIGluIHN0cmljdCBtb2RlLCBpbiBtb2Rlcm4gZW5naW5lc1xuICAvLyB3ZSBjYW4gZXhwbGljaXRseSBhY2Nlc3MgZ2xvYmFsVGhpcy4gSW4gb2xkZXIgZW5naW5lcyB3ZSBjYW4gZXNjYXBlXG4gIC8vIHN0cmljdCBtb2RlIHVzaW5nIGEgZ2xvYmFsIEZ1bmN0aW9uIGNhbGwuIFRoaXMgY291bGQgY29uY2VpdmFibHkgZmFpbFxuICAvLyBpZiBhIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IGZvcmJpZHMgdXNpbmcgRnVuY3Rpb24sIGJ1dCBpbiB0aGF0IGNhc2VcbiAgLy8gdGhlIHByb3BlciBzb2x1dGlvbiBpcyB0byBmaXggdGhlIGFjY2lkZW50YWwgc3RyaWN0IG1vZGUgcHJvYmxlbS4gSWZcbiAgLy8geW91J3ZlIG1pc2NvbmZpZ3VyZWQgeW91ciBidW5kbGVyIHRvIGZvcmNlIHN0cmljdCBtb2RlIGFuZCBhcHBsaWVkIGFcbiAgLy8gQ1NQIHRvIGZvcmJpZCBGdW5jdGlvbiwgYW5kIHlvdSdyZSBub3Qgd2lsbGluZyB0byBmaXggZWl0aGVyIG9mIHRob3NlXG4gIC8vIHByb2JsZW1zLCBwbGVhc2UgZGV0YWlsIHlvdXIgdW5pcXVlIHByZWRpY2FtZW50IGluIGEgR2l0SHViIGlzc3VlLlxuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICBnbG9iYWxUaGlzLnJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG4gIH0gZWxzZSB7XG4gICAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENoZWNrIGlmIHdlJ3JlIHJlcXVpcmVkIHRvIGFkZCBhIHBvcnQgbnVtYmVyLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkZWZhdWx0LXBvcnRcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gcG9ydCBQb3J0IG51bWJlciB3ZSBuZWVkIHRvIGNoZWNrXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvdG9jb2wgUHJvdG9jb2wgd2UgbmVlZCB0byBjaGVjayBhZ2FpbnN0LlxuICogQHJldHVybnMge0Jvb2xlYW59IElzIGl0IGEgZGVmYXVsdCBwb3J0IGZvciB0aGUgZ2l2ZW4gcHJvdG9jb2xcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcXVpcmVkKHBvcnQsIHByb3RvY29sKSB7XG4gIHByb3RvY29sID0gcHJvdG9jb2wuc3BsaXQoJzonKVswXTtcbiAgcG9ydCA9ICtwb3J0O1xuXG4gIGlmICghcG9ydCkgcmV0dXJuIGZhbHNlO1xuXG4gIHN3aXRjaCAocHJvdG9jb2wpIHtcbiAgICBjYXNlICdodHRwJzpcbiAgICBjYXNlICd3cyc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDgwO1xuXG4gICAgY2FzZSAnaHR0cHMnOlxuICAgIGNhc2UgJ3dzcyc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDQ0MztcblxuICAgIGNhc2UgJ2Z0cCc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDIxO1xuXG4gICAgY2FzZSAnZ29waGVyJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gNzA7XG5cbiAgICBjYXNlICdmaWxlJzpcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gcG9ydCAhPT0gMDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByZXF1aXJlZCA9IHJlcXVpcmUoJ3JlcXVpcmVzLXBvcnQnKVxuICAsIHFzID0gcmVxdWlyZSgncXVlcnlzdHJpbmdpZnknKVxuICAsIGNvbnRyb2xPcldoaXRlc3BhY2UgPSAvXltcXHgwMC1cXHgyMFxcdTAwYTBcXHUxNjgwXFx1MjAwMC1cXHUyMDBhXFx1MjAyOFxcdTIwMjlcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHVmZWZmXSsvXG4gICwgQ1JIVExGID0gL1tcXG5cXHJcXHRdL2dcbiAgLCBzbGFzaGVzID0gL15bQS1aYS16XVtBLVphLXowLTkrLS5dKjpcXC9cXC8vXG4gICwgcG9ydCA9IC86XFxkKyQvXG4gICwgcHJvdG9jb2xyZSA9IC9eKFthLXpdW2EtejAtOS4rLV0qOik/KFxcL1xcLyk/KFtcXFxcL10rKT8oW1xcU1xcc10qKS9pXG4gICwgd2luZG93c0RyaXZlTGV0dGVyID0gL15bYS16QS1aXTovO1xuXG4vKipcbiAqIFJlbW92ZSBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHdoaXRlc3BhY2UgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gc3RyIFN0cmluZyB0byB0cmltLlxuICogQHJldHVybnMge1N0cmluZ30gQSBuZXcgc3RyaW5nIHJlcHJlc2VudGluZyBgc3RyYCBzdHJpcHBlZCBvZiBjb250cm9sXG4gKiAgICAgY2hhcmFjdGVycyBhbmQgd2hpdGVzcGFjZSBmcm9tIGl0cyBiZWdpbm5pbmcuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHRyaW1MZWZ0KHN0cikge1xuICByZXR1cm4gKHN0ciA/IHN0ciA6ICcnKS50b1N0cmluZygpLnJlcGxhY2UoY29udHJvbE9yV2hpdGVzcGFjZSwgJycpO1xufVxuXG4vKipcbiAqIFRoZXNlIGFyZSB0aGUgcGFyc2UgcnVsZXMgZm9yIHRoZSBVUkwgcGFyc2VyLCBpdCBpbmZvcm1zIHRoZSBwYXJzZXJcbiAqIGFib3V0OlxuICpcbiAqIDAuIFRoZSBjaGFyIGl0IE5lZWRzIHRvIHBhcnNlLCBpZiBpdCdzIGEgc3RyaW5nIGl0IHNob3VsZCBiZSBkb25lIHVzaW5nXG4gKiAgICBpbmRleE9mLCBSZWdFeHAgdXNpbmcgZXhlYyBhbmQgTmFOIG1lYW5zIHNldCBhcyBjdXJyZW50IHZhbHVlLlxuICogMS4gVGhlIHByb3BlcnR5IHdlIHNob3VsZCBzZXQgd2hlbiBwYXJzaW5nIHRoaXMgdmFsdWUuXG4gKiAyLiBJbmRpY2F0aW9uIGlmIGl0J3MgYmFja3dhcmRzIG9yIGZvcndhcmQgcGFyc2luZywgd2hlbiBzZXQgYXMgbnVtYmVyIGl0J3NcbiAqICAgIHRoZSB2YWx1ZSBvZiBleHRyYSBjaGFycyB0aGF0IHNob3VsZCBiZSBzcGxpdCBvZmYuXG4gKiAzLiBJbmhlcml0IGZyb20gbG9jYXRpb24gaWYgbm9uIGV4aXN0aW5nIGluIHRoZSBwYXJzZXIuXG4gKiA0LiBgdG9Mb3dlckNhc2VgIHRoZSByZXN1bHRpbmcgdmFsdWUuXG4gKi9cbnZhciBydWxlcyA9IFtcbiAgWycjJywgJ2hhc2gnXSwgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIFsnPycsICdxdWVyeSddLCAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBmdW5jdGlvbiBzYW5pdGl6ZShhZGRyZXNzLCB1cmwpIHsgICAgIC8vIFNhbml0aXplIHdoYXQgaXMgbGVmdCBvZiB0aGUgYWRkcmVzc1xuICAgIHJldHVybiBpc1NwZWNpYWwodXJsLnByb3RvY29sKSA/IGFkZHJlc3MucmVwbGFjZSgvXFxcXC9nLCAnLycpIDogYWRkcmVzcztcbiAgfSxcbiAgWycvJywgJ3BhdGhuYW1lJ10sICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIFsnQCcsICdhdXRoJywgMV0sICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBmcm9udC5cbiAgW05hTiwgJ2hvc3QnLCB1bmRlZmluZWQsIDEsIDFdLCAgICAgICAvLyBTZXQgbGVmdCBvdmVyIHZhbHVlLlxuICBbLzooXFxkKikkLywgJ3BvcnQnLCB1bmRlZmluZWQsIDFdLCAgICAvLyBSZWdFeHAgdGhlIGJhY2suXG4gIFtOYU4sICdob3N0bmFtZScsIHVuZGVmaW5lZCwgMSwgMV0gICAgLy8gU2V0IGxlZnQgb3Zlci5cbl07XG5cbi8qKlxuICogVGhlc2UgcHJvcGVydGllcyBzaG91bGQgbm90IGJlIGNvcGllZCBvciBpbmhlcml0ZWQgZnJvbS4gVGhpcyBpcyBvbmx5IG5lZWRlZFxuICogZm9yIGFsbCBub24gYmxvYiBVUkwncyBhcyBhIGJsb2IgVVJMIGRvZXMgbm90IGluY2x1ZGUgYSBoYXNoLCBvbmx5IHRoZVxuICogb3JpZ2luLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgaWdub3JlID0geyBoYXNoOiAxLCBxdWVyeTogMSB9O1xuXG4vKipcbiAqIFRoZSBsb2NhdGlvbiBvYmplY3QgZGlmZmVycyB3aGVuIHlvdXIgY29kZSBpcyBsb2FkZWQgdGhyb3VnaCBhIG5vcm1hbCBwYWdlLFxuICogV29ya2VyIG9yIHRocm91Z2ggYSB3b3JrZXIgdXNpbmcgYSBibG9iLiBBbmQgd2l0aCB0aGUgYmxvYmJsZSBiZWdpbnMgdGhlXG4gKiB0cm91YmxlIGFzIHRoZSBsb2NhdGlvbiBvYmplY3Qgd2lsbCBjb250YWluIHRoZSBVUkwgb2YgdGhlIGJsb2IsIG5vdCB0aGVcbiAqIGxvY2F0aW9uIG9mIHRoZSBwYWdlIHdoZXJlIG91ciBjb2RlIGlzIGxvYWRlZCBpbi4gVGhlIGFjdHVhbCBvcmlnaW4gaXNcbiAqIGVuY29kZWQgaW4gdGhlIGBwYXRobmFtZWAgc28gd2UgY2FuIHRoYW5rZnVsbHkgZ2VuZXJhdGUgYSBnb29kIFwiZGVmYXVsdFwiXG4gKiBsb2NhdGlvbiBmcm9tIGl0IHNvIHdlIGNhbiBnZW5lcmF0ZSBwcm9wZXIgcmVsYXRpdmUgVVJMJ3MgYWdhaW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBsb2MgT3B0aW9uYWwgZGVmYXVsdCBsb2NhdGlvbiBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBsb2xjYXRpb24gb2JqZWN0LlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBsb2xjYXRpb24obG9jKSB7XG4gIHZhciBnbG9iYWxWYXI7XG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSBnbG9iYWxWYXIgPSB3aW5kb3c7XG4gIGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSBnbG9iYWxWYXIgPSBnbG9iYWw7XG4gIGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykgZ2xvYmFsVmFyID0gc2VsZjtcbiAgZWxzZSBnbG9iYWxWYXIgPSB7fTtcblxuICB2YXIgbG9jYXRpb24gPSBnbG9iYWxWYXIubG9jYXRpb24gfHwge307XG4gIGxvYyA9IGxvYyB8fCBsb2NhdGlvbjtcblxuICB2YXIgZmluYWxkZXN0aW5hdGlvbiA9IHt9XG4gICAgLCB0eXBlID0gdHlwZW9mIGxvY1xuICAgICwga2V5O1xuXG4gIGlmICgnYmxvYjonID09PSBsb2MucHJvdG9jb2wpIHtcbiAgICBmaW5hbGRlc3RpbmF0aW9uID0gbmV3IFVybCh1bmVzY2FwZShsb2MucGF0aG5hbWUpLCB7fSk7XG4gIH0gZWxzZSBpZiAoJ3N0cmluZycgPT09IHR5cGUpIHtcbiAgICBmaW5hbGRlc3RpbmF0aW9uID0gbmV3IFVybChsb2MsIHt9KTtcbiAgICBmb3IgKGtleSBpbiBpZ25vcmUpIGRlbGV0ZSBmaW5hbGRlc3RpbmF0aW9uW2tleV07XG4gIH0gZWxzZSBpZiAoJ29iamVjdCcgPT09IHR5cGUpIHtcbiAgICBmb3IgKGtleSBpbiBsb2MpIHtcbiAgICAgIGlmIChrZXkgaW4gaWdub3JlKSBjb250aW51ZTtcbiAgICAgIGZpbmFsZGVzdGluYXRpb25ba2V5XSA9IGxvY1trZXldO1xuICAgIH1cblxuICAgIGlmIChmaW5hbGRlc3RpbmF0aW9uLnNsYXNoZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZmluYWxkZXN0aW5hdGlvbi5zbGFzaGVzID0gc2xhc2hlcy50ZXN0KGxvYy5ocmVmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmluYWxkZXN0aW5hdGlvbjtcbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGEgcHJvdG9jb2wgc2NoZW1lIGlzIHNwZWNpYWwuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFRoZSBwcm90b2NvbCBzY2hlbWUgb2YgdGhlIFVSTFxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBwcm90b2NvbCBzY2hlbWUgaXMgc3BlY2lhbCwgZWxzZSBgZmFsc2VgXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc1NwZWNpYWwoc2NoZW1lKSB7XG4gIHJldHVybiAoXG4gICAgc2NoZW1lID09PSAnZmlsZTonIHx8XG4gICAgc2NoZW1lID09PSAnZnRwOicgfHxcbiAgICBzY2hlbWUgPT09ICdodHRwOicgfHxcbiAgICBzY2hlbWUgPT09ICdodHRwczonIHx8XG4gICAgc2NoZW1lID09PSAnd3M6JyB8fFxuICAgIHNjaGVtZSA9PT0gJ3dzczonXG4gICk7XG59XG5cbi8qKlxuICogQHR5cGVkZWYgUHJvdG9jb2xFeHRyYWN0XG4gKiBAdHlwZSBPYmplY3RcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBwcm90b2NvbCBQcm90b2NvbCBtYXRjaGVkIGluIHRoZSBVUkwsIGluIGxvd2VyY2FzZS5cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc2xhc2hlcyBgdHJ1ZWAgaWYgcHJvdG9jb2wgaXMgZm9sbG93ZWQgYnkgXCIvL1wiLCBlbHNlIGBmYWxzZWAuXG4gKiBAcHJvcGVydHkge1N0cmluZ30gcmVzdCBSZXN0IG9mIHRoZSBVUkwgdGhhdCBpcyBub3QgcGFydCBvZiB0aGUgcHJvdG9jb2wuXG4gKi9cblxuLyoqXG4gKiBFeHRyYWN0IHByb3RvY29sIGluZm9ybWF0aW9uIGZyb20gYSBVUkwgd2l0aC93aXRob3V0IGRvdWJsZSBzbGFzaCAoXCIvL1wiKS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyBVUkwgd2Ugd2FudCB0byBleHRyYWN0IGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gbG9jYXRpb25cbiAqIEByZXR1cm4ge1Byb3RvY29sRXh0cmFjdH0gRXh0cmFjdGVkIGluZm9ybWF0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFByb3RvY29sKGFkZHJlc3MsIGxvY2F0aW9uKSB7XG4gIGFkZHJlc3MgPSB0cmltTGVmdChhZGRyZXNzKTtcbiAgYWRkcmVzcyA9IGFkZHJlc3MucmVwbGFjZShDUkhUTEYsICcnKTtcbiAgbG9jYXRpb24gPSBsb2NhdGlvbiB8fCB7fTtcblxuICB2YXIgbWF0Y2ggPSBwcm90b2NvbHJlLmV4ZWMoYWRkcmVzcyk7XG4gIHZhciBwcm90b2NvbCA9IG1hdGNoWzFdID8gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKSA6ICcnO1xuICB2YXIgZm9yd2FyZFNsYXNoZXMgPSAhIW1hdGNoWzJdO1xuICB2YXIgb3RoZXJTbGFzaGVzID0gISFtYXRjaFszXTtcbiAgdmFyIHNsYXNoZXNDb3VudCA9IDA7XG4gIHZhciByZXN0O1xuXG4gIGlmIChmb3J3YXJkU2xhc2hlcykge1xuICAgIGlmIChvdGhlclNsYXNoZXMpIHtcbiAgICAgIHJlc3QgPSBtYXRjaFsyXSArIG1hdGNoWzNdICsgbWF0Y2hbNF07XG4gICAgICBzbGFzaGVzQ291bnQgPSBtYXRjaFsyXS5sZW5ndGggKyBtYXRjaFszXS5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3QgPSBtYXRjaFsyXSArIG1hdGNoWzRdO1xuICAgICAgc2xhc2hlc0NvdW50ID0gbWF0Y2hbMl0ubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAob3RoZXJTbGFzaGVzKSB7XG4gICAgICByZXN0ID0gbWF0Y2hbM10gKyBtYXRjaFs0XTtcbiAgICAgIHNsYXNoZXNDb3VudCA9IG1hdGNoWzNdLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdCA9IG1hdGNoWzRdXG4gICAgfVxuICB9XG5cbiAgaWYgKHByb3RvY29sID09PSAnZmlsZTonKSB7XG4gICAgaWYgKHNsYXNoZXNDb3VudCA+PSAyKSB7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZSgyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNTcGVjaWFsKHByb3RvY29sKSkge1xuICAgIHJlc3QgPSBtYXRjaFs0XTtcbiAgfSBlbHNlIGlmIChwcm90b2NvbCkge1xuICAgIGlmIChmb3J3YXJkU2xhc2hlcykge1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoMik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHNsYXNoZXNDb3VudCA+PSAyICYmIGlzU3BlY2lhbChsb2NhdGlvbi5wcm90b2NvbCkpIHtcbiAgICByZXN0ID0gbWF0Y2hbNF07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHByb3RvY29sOiBwcm90b2NvbCxcbiAgICBzbGFzaGVzOiBmb3J3YXJkU2xhc2hlcyB8fCBpc1NwZWNpYWwocHJvdG9jb2wpLFxuICAgIHNsYXNoZXNDb3VudDogc2xhc2hlc0NvdW50LFxuICAgIHJlc3Q6IHJlc3RcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGEgcmVsYXRpdmUgVVJMIHBhdGhuYW1lIGFnYWluc3QgYSBiYXNlIFVSTCBwYXRobmFtZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVsYXRpdmUgUGF0aG5hbWUgb2YgdGhlIHJlbGF0aXZlIFVSTC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlIFBhdGhuYW1lIG9mIHRoZSBiYXNlIFVSTC5cbiAqIEByZXR1cm4ge1N0cmluZ30gUmVzb2x2ZWQgcGF0aG5hbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZXNvbHZlKHJlbGF0aXZlLCBiYXNlKSB7XG4gIGlmIChyZWxhdGl2ZSA9PT0gJycpIHJldHVybiBiYXNlO1xuXG4gIHZhciBwYXRoID0gKGJhc2UgfHwgJy8nKS5zcGxpdCgnLycpLnNsaWNlKDAsIC0xKS5jb25jYXQocmVsYXRpdmUuc3BsaXQoJy8nKSlcbiAgICAsIGkgPSBwYXRoLmxlbmd0aFxuICAgICwgbGFzdCA9IHBhdGhbaSAtIDFdXG4gICAgLCB1bnNoaWZ0ID0gZmFsc2VcbiAgICAsIHVwID0gMDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKHBhdGhbaV0gPT09ICcuJykge1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChwYXRoW2ldID09PSAnLi4nKSB7XG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgaWYgKGkgPT09IDApIHVuc2hpZnQgPSB0cnVlO1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIGlmICh1bnNoaWZ0KSBwYXRoLnVuc2hpZnQoJycpO1xuICBpZiAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHBhdGgucHVzaCgnJyk7XG5cbiAgcmV0dXJuIHBhdGguam9pbignLycpO1xufVxuXG4vKipcbiAqIFRoZSBhY3R1YWwgVVJMIGluc3RhbmNlLiBJbnN0ZWFkIG9mIHJldHVybmluZyBhbiBvYmplY3Qgd2UndmUgb3B0ZWQtaW4gdG9cbiAqIGNyZWF0ZSBhbiBhY3R1YWwgY29uc3RydWN0b3IgYXMgaXQncyBtdWNoIG1vcmUgbWVtb3J5IGVmZmljaWVudCBhbmRcbiAqIGZhc3RlciBhbmQgaXQgcGxlYXNlcyBteSBPQ0QuXG4gKlxuICogSXQgaXMgd29ydGggbm90aW5nIHRoYXQgd2Ugc2hvdWxkIG5vdCB1c2UgYFVSTGAgYXMgY2xhc3MgbmFtZSB0byBwcmV2ZW50XG4gKiBjbGFzaGVzIHdpdGggdGhlIGdsb2JhbCBVUkwgaW5zdGFuY2UgdGhhdCBnb3QgaW50cm9kdWNlZCBpbiBicm93c2Vycy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIFVSTCB3ZSB3YW50IHRvIHBhcnNlLlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBbbG9jYXRpb25dIExvY2F0aW9uIGRlZmF1bHRzIGZvciByZWxhdGl2ZSBwYXRocy5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gW3BhcnNlcl0gUGFyc2VyIGZvciB0aGUgcXVlcnkgc3RyaW5nLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gVXJsKGFkZHJlc3MsIGxvY2F0aW9uLCBwYXJzZXIpIHtcbiAgYWRkcmVzcyA9IHRyaW1MZWZ0KGFkZHJlc3MpO1xuICBhZGRyZXNzID0gYWRkcmVzcy5yZXBsYWNlKENSSFRMRiwgJycpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBVcmwpKSB7XG4gICAgcmV0dXJuIG5ldyBVcmwoYWRkcmVzcywgbG9jYXRpb24sIHBhcnNlcik7XG4gIH1cblxuICB2YXIgcmVsYXRpdmUsIGV4dHJhY3RlZCwgcGFyc2UsIGluc3RydWN0aW9uLCBpbmRleCwga2V5XG4gICAgLCBpbnN0cnVjdGlvbnMgPSBydWxlcy5zbGljZSgpXG4gICAgLCB0eXBlID0gdHlwZW9mIGxvY2F0aW9uXG4gICAgLCB1cmwgPSB0aGlzXG4gICAgLCBpID0gMDtcblxuICAvL1xuICAvLyBUaGUgZm9sbG93aW5nIGlmIHN0YXRlbWVudHMgYWxsb3dzIHRoaXMgbW9kdWxlIHR3byBoYXZlIGNvbXBhdGliaWxpdHkgd2l0aFxuICAvLyAyIGRpZmZlcmVudCBBUEk6XG4gIC8vXG4gIC8vIDEuIE5vZGUuanMncyBgdXJsLnBhcnNlYCBhcGkgd2hpY2ggYWNjZXB0cyBhIFVSTCwgYm9vbGVhbiBhcyBhcmd1bWVudHNcbiAgLy8gICAgd2hlcmUgdGhlIGJvb2xlYW4gaW5kaWNhdGVzIHRoYXQgdGhlIHF1ZXJ5IHN0cmluZyBzaG91bGQgYWxzbyBiZSBwYXJzZWQuXG4gIC8vXG4gIC8vIDIuIFRoZSBgVVJMYCBpbnRlcmZhY2Ugb2YgdGhlIGJyb3dzZXIgd2hpY2ggYWNjZXB0cyBhIFVSTCwgb2JqZWN0IGFzXG4gIC8vICAgIGFyZ3VtZW50cy4gVGhlIHN1cHBsaWVkIG9iamVjdCB3aWxsIGJlIHVzZWQgYXMgZGVmYXVsdCB2YWx1ZXMgLyBmYWxsLWJhY2tcbiAgLy8gICAgZm9yIHJlbGF0aXZlIHBhdGhzLlxuICAvL1xuICBpZiAoJ29iamVjdCcgIT09IHR5cGUgJiYgJ3N0cmluZycgIT09IHR5cGUpIHtcbiAgICBwYXJzZXIgPSBsb2NhdGlvbjtcbiAgICBsb2NhdGlvbiA9IG51bGw7XG4gIH1cblxuICBpZiAocGFyc2VyICYmICdmdW5jdGlvbicgIT09IHR5cGVvZiBwYXJzZXIpIHBhcnNlciA9IHFzLnBhcnNlO1xuXG4gIGxvY2F0aW9uID0gbG9sY2F0aW9uKGxvY2F0aW9uKTtcblxuICAvL1xuICAvLyBFeHRyYWN0IHByb3RvY29sIGluZm9ybWF0aW9uIGJlZm9yZSBydW5uaW5nIHRoZSBpbnN0cnVjdGlvbnMuXG4gIC8vXG4gIGV4dHJhY3RlZCA9IGV4dHJhY3RQcm90b2NvbChhZGRyZXNzIHx8ICcnLCBsb2NhdGlvbik7XG4gIHJlbGF0aXZlID0gIWV4dHJhY3RlZC5wcm90b2NvbCAmJiAhZXh0cmFjdGVkLnNsYXNoZXM7XG4gIHVybC5zbGFzaGVzID0gZXh0cmFjdGVkLnNsYXNoZXMgfHwgcmVsYXRpdmUgJiYgbG9jYXRpb24uc2xhc2hlcztcbiAgdXJsLnByb3RvY29sID0gZXh0cmFjdGVkLnByb3RvY29sIHx8IGxvY2F0aW9uLnByb3RvY29sIHx8ICcnO1xuICBhZGRyZXNzID0gZXh0cmFjdGVkLnJlc3Q7XG5cbiAgLy9cbiAgLy8gV2hlbiB0aGUgYXV0aG9yaXR5IGNvbXBvbmVudCBpcyBhYnNlbnQgdGhlIFVSTCBzdGFydHMgd2l0aCBhIHBhdGhcbiAgLy8gY29tcG9uZW50LlxuICAvL1xuICBpZiAoXG4gICAgZXh0cmFjdGVkLnByb3RvY29sID09PSAnZmlsZTonICYmIChcbiAgICAgIGV4dHJhY3RlZC5zbGFzaGVzQ291bnQgIT09IDIgfHwgd2luZG93c0RyaXZlTGV0dGVyLnRlc3QoYWRkcmVzcykpIHx8XG4gICAgKCFleHRyYWN0ZWQuc2xhc2hlcyAmJlxuICAgICAgKGV4dHJhY3RlZC5wcm90b2NvbCB8fFxuICAgICAgICBleHRyYWN0ZWQuc2xhc2hlc0NvdW50IDwgMiB8fFxuICAgICAgICAhaXNTcGVjaWFsKHVybC5wcm90b2NvbCkpKVxuICApIHtcbiAgICBpbnN0cnVjdGlvbnNbM10gPSBbLyguKikvLCAncGF0aG5hbWUnXTtcbiAgfVxuXG4gIGZvciAoOyBpIDwgaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgaW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbnNbaV07XG5cbiAgICBpZiAodHlwZW9mIGluc3RydWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhZGRyZXNzID0gaW5zdHJ1Y3Rpb24oYWRkcmVzcywgdXJsKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHBhcnNlID0gaW5zdHJ1Y3Rpb25bMF07XG4gICAga2V5ID0gaW5zdHJ1Y3Rpb25bMV07XG5cbiAgICBpZiAocGFyc2UgIT09IHBhcnNlKSB7XG4gICAgICB1cmxba2V5XSA9IGFkZHJlc3M7XG4gICAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHBhcnNlKSB7XG4gICAgICBpbmRleCA9IHBhcnNlID09PSAnQCdcbiAgICAgICAgPyBhZGRyZXNzLmxhc3RJbmRleE9mKHBhcnNlKVxuICAgICAgICA6IGFkZHJlc3MuaW5kZXhPZihwYXJzZSk7XG5cbiAgICAgIGlmICh+aW5kZXgpIHtcbiAgICAgICAgaWYgKCdudW1iZXInID09PSB0eXBlb2YgaW5zdHJ1Y3Rpb25bMl0pIHtcbiAgICAgICAgICB1cmxba2V5XSA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKGluZGV4ICsgaW5zdHJ1Y3Rpb25bMl0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVybFtrZXldID0gYWRkcmVzcy5zbGljZShpbmRleCk7XG4gICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgoaW5kZXggPSBwYXJzZS5leGVjKGFkZHJlc3MpKSkge1xuICAgICAgdXJsW2tleV0gPSBpbmRleFsxXTtcbiAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4LmluZGV4KTtcbiAgICB9XG5cbiAgICB1cmxba2V5XSA9IHVybFtrZXldIHx8IChcbiAgICAgIHJlbGF0aXZlICYmIGluc3RydWN0aW9uWzNdID8gbG9jYXRpb25ba2V5XSB8fCAnJyA6ICcnXG4gICAgKTtcblxuICAgIC8vXG4gICAgLy8gSG9zdG5hbWUsIGhvc3QgYW5kIHByb3RvY29sIHNob3VsZCBiZSBsb3dlcmNhc2VkIHNvIHRoZXkgY2FuIGJlIHVzZWQgdG9cbiAgICAvLyBjcmVhdGUgYSBwcm9wZXIgYG9yaWdpbmAuXG4gICAgLy9cbiAgICBpZiAoaW5zdHJ1Y3Rpb25bNF0pIHVybFtrZXldID0gdXJsW2tleV0udG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIC8vXG4gIC8vIEFsc28gcGFyc2UgdGhlIHN1cHBsaWVkIHF1ZXJ5IHN0cmluZyBpbiB0byBhbiBvYmplY3QuIElmIHdlJ3JlIHN1cHBsaWVkXG4gIC8vIHdpdGggYSBjdXN0b20gcGFyc2VyIGFzIGZ1bmN0aW9uIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgYnVpbGQtaW5cbiAgLy8gcGFyc2VyLlxuICAvL1xuICBpZiAocGFyc2VyKSB1cmwucXVlcnkgPSBwYXJzZXIodXJsLnF1ZXJ5KTtcblxuICAvL1xuICAvLyBJZiB0aGUgVVJMIGlzIHJlbGF0aXZlLCByZXNvbHZlIHRoZSBwYXRobmFtZSBhZ2FpbnN0IHRoZSBiYXNlIFVSTC5cbiAgLy9cbiAgaWYgKFxuICAgICAgcmVsYXRpdmVcbiAgICAmJiBsb2NhdGlvbi5zbGFzaGVzXG4gICAgJiYgdXJsLnBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nXG4gICAgJiYgKHVybC5wYXRobmFtZSAhPT0gJycgfHwgbG9jYXRpb24ucGF0aG5hbWUgIT09ICcnKVxuICApIHtcbiAgICB1cmwucGF0aG5hbWUgPSByZXNvbHZlKHVybC5wYXRobmFtZSwgbG9jYXRpb24ucGF0aG5hbWUpO1xuICB9XG5cbiAgLy9cbiAgLy8gRGVmYXVsdCB0byBhIC8gZm9yIHBhdGhuYW1lIGlmIG5vbmUgZXhpc3RzLiBUaGlzIG5vcm1hbGl6ZXMgdGhlIFVSTFxuICAvLyB0byBhbHdheXMgaGF2ZSBhIC9cbiAgLy9cbiAgaWYgKHVybC5wYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJyAmJiBpc1NwZWNpYWwodXJsLnByb3RvY29sKSkge1xuICAgIHVybC5wYXRobmFtZSA9ICcvJyArIHVybC5wYXRobmFtZTtcbiAgfVxuXG4gIC8vXG4gIC8vIFdlIHNob3VsZCBub3QgYWRkIHBvcnQgbnVtYmVycyBpZiB0aGV5IGFyZSBhbHJlYWR5IHRoZSBkZWZhdWx0IHBvcnQgbnVtYmVyXG4gIC8vIGZvciBhIGdpdmVuIHByb3RvY29sLiBBcyB0aGUgaG9zdCBhbHNvIGNvbnRhaW5zIHRoZSBwb3J0IG51bWJlciB3ZSdyZSBnb2luZ1xuICAvLyBvdmVycmlkZSBpdCB3aXRoIHRoZSBob3N0bmFtZSB3aGljaCBjb250YWlucyBubyBwb3J0IG51bWJlci5cbiAgLy9cbiAgaWYgKCFyZXF1aXJlZCh1cmwucG9ydCwgdXJsLnByb3RvY29sKSkge1xuICAgIHVybC5ob3N0ID0gdXJsLmhvc3RuYW1lO1xuICAgIHVybC5wb3J0ID0gJyc7XG4gIH1cblxuICAvL1xuICAvLyBQYXJzZSBkb3duIHRoZSBgYXV0aGAgZm9yIHRoZSB1c2VybmFtZSBhbmQgcGFzc3dvcmQuXG4gIC8vXG4gIHVybC51c2VybmFtZSA9IHVybC5wYXNzd29yZCA9ICcnO1xuXG4gIGlmICh1cmwuYXV0aCkge1xuICAgIGluZGV4ID0gdXJsLmF1dGguaW5kZXhPZignOicpO1xuXG4gICAgaWYgKH5pbmRleCkge1xuICAgICAgdXJsLnVzZXJuYW1lID0gdXJsLmF1dGguc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgdXJsLnVzZXJuYW1lID0gZW5jb2RlVVJJQ29tcG9uZW50KGRlY29kZVVSSUNvbXBvbmVudCh1cmwudXNlcm5hbWUpKTtcblxuICAgICAgdXJsLnBhc3N3b3JkID0gdXJsLmF1dGguc2xpY2UoaW5kZXggKyAxKTtcbiAgICAgIHVybC5wYXNzd29yZCA9IGVuY29kZVVSSUNvbXBvbmVudChkZWNvZGVVUklDb21wb25lbnQodXJsLnBhc3N3b3JkKSlcbiAgICB9IGVsc2Uge1xuICAgICAgdXJsLnVzZXJuYW1lID0gZW5jb2RlVVJJQ29tcG9uZW50KGRlY29kZVVSSUNvbXBvbmVudCh1cmwuYXV0aCkpO1xuICAgIH1cblxuICAgIHVybC5hdXRoID0gdXJsLnBhc3N3b3JkID8gdXJsLnVzZXJuYW1lICsnOicrIHVybC5wYXNzd29yZCA6IHVybC51c2VybmFtZTtcbiAgfVxuXG4gIHVybC5vcmlnaW4gPSB1cmwucHJvdG9jb2wgIT09ICdmaWxlOicgJiYgaXNTcGVjaWFsKHVybC5wcm90b2NvbCkgJiYgdXJsLmhvc3RcbiAgICA/IHVybC5wcm90b2NvbCArJy8vJysgdXJsLmhvc3RcbiAgICA6ICdudWxsJztcblxuICAvL1xuICAvLyBUaGUgaHJlZiBpcyBqdXN0IHRoZSBjb21waWxlZCByZXN1bHQuXG4gIC8vXG4gIHVybC5ocmVmID0gdXJsLnRvU3RyaW5nKCk7XG59XG5cbi8qKlxuICogVGhpcyBpcyBjb252ZW5pZW5jZSBtZXRob2QgZm9yIGNoYW5naW5nIHByb3BlcnRpZXMgaW4gdGhlIFVSTCBpbnN0YW5jZSB0b1xuICogaW5zdXJlIHRoYXQgdGhleSBhbGwgcHJvcGFnYXRlIGNvcnJlY3RseS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFydCAgICAgICAgICBQcm9wZXJ0eSB3ZSBuZWVkIHRvIGFkanVzdC5cbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlICAgICAgICAgIFRoZSBuZXdseSBhc3NpZ25lZCB2YWx1ZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gZm4gIFdoZW4gc2V0dGluZyB0aGUgcXVlcnksIGl0IHdpbGwgYmUgdGhlIGZ1bmN0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VkIHRvIHBhcnNlIHRoZSBxdWVyeS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdoZW4gc2V0dGluZyB0aGUgcHJvdG9jb2wsIGRvdWJsZSBzbGFzaCB3aWxsIGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkIGZyb20gdGhlIGZpbmFsIHVybCBpZiBpdCBpcyB0cnVlLlxuICogQHJldHVybnMge1VSTH0gVVJMIGluc3RhbmNlIGZvciBjaGFpbmluZy5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gc2V0KHBhcnQsIHZhbHVlLCBmbikge1xuICB2YXIgdXJsID0gdGhpcztcblxuICBzd2l0Y2ggKHBhcnQpIHtcbiAgICBjYXNlICdxdWVyeSc6XG4gICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB2YWx1ZSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgPSAoZm4gfHwgcXMucGFyc2UpKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3BvcnQnOlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG5cbiAgICAgIGlmICghcmVxdWlyZWQodmFsdWUsIHVybC5wcm90b2NvbCkpIHtcbiAgICAgICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWU7XG4gICAgICAgIHVybFtwYXJ0XSA9ICcnO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZSArJzonKyB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdob3N0bmFtZSc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKHVybC5wb3J0KSB2YWx1ZSArPSAnOicrIHVybC5wb3J0O1xuICAgICAgdXJsLmhvc3QgPSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaG9zdCc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKHBvcnQudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdCgnOicpO1xuICAgICAgICB1cmwucG9ydCA9IHZhbHVlLnBvcCgpO1xuICAgICAgICB1cmwuaG9zdG5hbWUgPSB2YWx1ZS5qb2luKCc6Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmwuaG9zdG5hbWUgPSB2YWx1ZTtcbiAgICAgICAgdXJsLnBvcnQgPSAnJztcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwcm90b2NvbCc6XG4gICAgICB1cmwucHJvdG9jb2wgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdXJsLnNsYXNoZXMgPSAhZm47XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3BhdGhuYW1lJzpcbiAgICBjYXNlICdoYXNoJzpcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB2YXIgY2hhciA9IHBhcnQgPT09ICdwYXRobmFtZScgPyAnLycgOiAnIyc7XG4gICAgICAgIHVybFtwYXJ0XSA9IHZhbHVlLmNoYXJBdCgwKSAhPT0gY2hhciA/IGNoYXIgKyB2YWx1ZSA6IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3VzZXJuYW1lJzpcbiAgICBjYXNlICdwYXNzd29yZCc6XG4gICAgICB1cmxbcGFydF0gPSBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdhdXRoJzpcbiAgICAgIHZhciBpbmRleCA9IHZhbHVlLmluZGV4T2YoJzonKTtcblxuICAgICAgaWYgKH5pbmRleCkge1xuICAgICAgICB1cmwudXNlcm5hbWUgPSB2YWx1ZS5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgIHVybC51c2VybmFtZSA9IGVuY29kZVVSSUNvbXBvbmVudChkZWNvZGVVUklDb21wb25lbnQodXJsLnVzZXJuYW1lKSk7XG5cbiAgICAgICAgdXJsLnBhc3N3b3JkID0gdmFsdWUuc2xpY2UoaW5kZXggKyAxKTtcbiAgICAgICAgdXJsLnBhc3N3b3JkID0gZW5jb2RlVVJJQ29tcG9uZW50KGRlY29kZVVSSUNvbXBvbmVudCh1cmwucGFzc3dvcmQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVybC51c2VybmFtZSA9IGVuY29kZVVSSUNvbXBvbmVudChkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcbiAgICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaW5zID0gcnVsZXNbaV07XG5cbiAgICBpZiAoaW5zWzRdKSB1cmxbaW5zWzFdXSA9IHVybFtpbnNbMV1dLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICB1cmwuYXV0aCA9IHVybC5wYXNzd29yZCA/IHVybC51c2VybmFtZSArJzonKyB1cmwucGFzc3dvcmQgOiB1cmwudXNlcm5hbWU7XG5cbiAgdXJsLm9yaWdpbiA9IHVybC5wcm90b2NvbCAhPT0gJ2ZpbGU6JyAmJiBpc1NwZWNpYWwodXJsLnByb3RvY29sKSAmJiB1cmwuaG9zdFxuICAgID8gdXJsLnByb3RvY29sICsnLy8nKyB1cmwuaG9zdFxuICAgIDogJ251bGwnO1xuXG4gIHVybC5ocmVmID0gdXJsLnRvU3RyaW5nKCk7XG5cbiAgcmV0dXJuIHVybDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIHByb3BlcnRpZXMgYmFjayBpbiB0byBhIHZhbGlkIGFuZCBmdWxsIFVSTCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5naWZ5IE9wdGlvbmFsIHF1ZXJ5IHN0cmluZ2lmeSBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IENvbXBpbGVkIHZlcnNpb24gb2YgdGhlIFVSTC5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcoc3RyaW5naWZ5KSB7XG4gIGlmICghc3RyaW5naWZ5IHx8ICdmdW5jdGlvbicgIT09IHR5cGVvZiBzdHJpbmdpZnkpIHN0cmluZ2lmeSA9IHFzLnN0cmluZ2lmeTtcblxuICB2YXIgcXVlcnlcbiAgICAsIHVybCA9IHRoaXNcbiAgICAsIGhvc3QgPSB1cmwuaG9zdFxuICAgICwgcHJvdG9jb2wgPSB1cmwucHJvdG9jb2w7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLmNoYXJBdChwcm90b2NvbC5sZW5ndGggLSAxKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgdmFyIHJlc3VsdCA9XG4gICAgcHJvdG9jb2wgK1xuICAgICgodXJsLnByb3RvY29sICYmIHVybC5zbGFzaGVzKSB8fCBpc1NwZWNpYWwodXJsLnByb3RvY29sKSA/ICcvLycgOiAnJyk7XG5cbiAgaWYgKHVybC51c2VybmFtZSkge1xuICAgIHJlc3VsdCArPSB1cmwudXNlcm5hbWU7XG4gICAgaWYgKHVybC5wYXNzd29yZCkgcmVzdWx0ICs9ICc6JysgdXJsLnBhc3N3b3JkO1xuICAgIHJlc3VsdCArPSAnQCc7XG4gIH0gZWxzZSBpZiAodXJsLnBhc3N3b3JkKSB7XG4gICAgcmVzdWx0ICs9ICc6JysgdXJsLnBhc3N3b3JkO1xuICAgIHJlc3VsdCArPSAnQCc7XG4gIH0gZWxzZSBpZiAoXG4gICAgdXJsLnByb3RvY29sICE9PSAnZmlsZTonICYmXG4gICAgaXNTcGVjaWFsKHVybC5wcm90b2NvbCkgJiZcbiAgICAhaG9zdCAmJlxuICAgIHVybC5wYXRobmFtZSAhPT0gJy8nXG4gICkge1xuICAgIC8vXG4gICAgLy8gQWRkIGJhY2sgdGhlIGVtcHR5IHVzZXJpbmZvLCBvdGhlcndpc2UgdGhlIG9yaWdpbmFsIGludmFsaWQgVVJMXG4gICAgLy8gbWlnaHQgYmUgdHJhbnNmb3JtZWQgaW50byBhIHZhbGlkIG9uZSB3aXRoIGB1cmwucGF0aG5hbWVgIGFzIGhvc3QuXG4gICAgLy9cbiAgICByZXN1bHQgKz0gJ0AnO1xuICB9XG5cbiAgLy9cbiAgLy8gVHJhaWxpbmcgY29sb24gaXMgcmVtb3ZlZCBmcm9tIGB1cmwuaG9zdGAgd2hlbiBpdCBpcyBwYXJzZWQuIElmIGl0IHN0aWxsXG4gIC8vIGVuZHMgd2l0aCBhIGNvbG9uLCB0aGVuIGFkZCBiYWNrIHRoZSB0cmFpbGluZyBjb2xvbiB0aGF0IHdhcyByZW1vdmVkLiBUaGlzXG4gIC8vIHByZXZlbnRzIGFuIGludmFsaWQgVVJMIGZyb20gYmVpbmcgdHJhbnNmb3JtZWQgaW50byBhIHZhbGlkIG9uZS5cbiAgLy9cbiAgaWYgKGhvc3RbaG9zdC5sZW5ndGggLSAxXSA9PT0gJzonIHx8IChwb3J0LnRlc3QodXJsLmhvc3RuYW1lKSAmJiAhdXJsLnBvcnQpKSB7XG4gICAgaG9zdCArPSAnOic7XG4gIH1cblxuICByZXN1bHQgKz0gaG9zdCArIHVybC5wYXRobmFtZTtcblxuICBxdWVyeSA9ICdvYmplY3QnID09PSB0eXBlb2YgdXJsLnF1ZXJ5ID8gc3RyaW5naWZ5KHVybC5xdWVyeSkgOiB1cmwucXVlcnk7XG4gIGlmIChxdWVyeSkgcmVzdWx0ICs9ICc/JyAhPT0gcXVlcnkuY2hhckF0KDApID8gJz8nKyBxdWVyeSA6IHF1ZXJ5O1xuXG4gIGlmICh1cmwuaGFzaCkgcmVzdWx0ICs9IHVybC5oYXNoO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblVybC5wcm90b3R5cGUgPSB7IHNldDogc2V0LCB0b1N0cmluZzogdG9TdHJpbmcgfTtcblxuLy9cbi8vIEV4cG9zZSB0aGUgVVJMIHBhcnNlciBhbmQgc29tZSBhZGRpdGlvbmFsIHByb3BlcnRpZXMgdGhhdCBtaWdodCBiZSB1c2VmdWwgZm9yXG4vLyBvdGhlcnMgb3IgdGVzdGluZy5cbi8vXG5VcmwuZXh0cmFjdFByb3RvY29sID0gZXh0cmFjdFByb3RvY29sO1xuVXJsLmxvY2F0aW9uID0gbG9sY2F0aW9uO1xuVXJsLnRyaW1MZWZ0ID0gdHJpbUxlZnQ7XG5VcmwucXMgPSBxcztcblxubW9kdWxlLmV4cG9ydHMgPSBVcmw7XG4iLCIvLyBUaGUgcmVnZW5lcmF0b3IgcnVudGltZSBpcyBuZWVkZWQgc2luY2UgdGhlIHRlc3QgdXNlIGZ1bmN0aW9uc1xuLy8gd2l0aCB0aGUgYXN5bmMvYXdhaXQga2V5d29yZHMuIFNlZVxuLy8gaHR0cHM6Ly9iYWJlbGpzLmlvL2RvY3MvZW4vYmFiZWwtcGx1Z2luLXRyYW5zZm9ybS1yZWdlbmVyYXRvclxuaW1wb3J0ICdyZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUnXG5cbmJlZm9yZUVhY2goKCkgPT4ge1xuICAvLyBDbGVhciBsb2NhbFN0b3JhZ2UgYmVmb3JlIGV2ZXJ5IHRlc3QgdG8gcHJldmVudCBzdG9yZWQgVVJMcyB0b1xuICAvLyBpbnRlcmZlcmUgd2l0aCBvdXIgc2V0dXAuXG4gIGxvY2FsU3RvcmFnZS5jbGVhcigpXG59KVxuXG5yZXF1aXJlKCcuL3Rlc3QtY29tbW9uJylcbnJlcXVpcmUoJy4vdGVzdC1icm93c2VyLXNwZWNpZmljJylcbnJlcXVpcmUoJy4vdGVzdC1wYXJhbGxlbC11cGxvYWRzJylcbnJlcXVpcmUoJy4vdGVzdC1wYXJhbGxlbC1zdGFnZ2VyLXVwbG9hZHMnKVxucmVxdWlyZSgnLi90ZXN0LXRlcm1pbmF0ZScpXG5yZXF1aXJlKCcuL3Rlc3QtZW5kLXRvLWVuZCcpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGFzeW5jIGZ1bmN0aW9uIGFzc2VydFVybFN0b3JhZ2UgKHVybFN0b3JhZ2UpIHtcbiAgLy8gSW4gdGhlIGJlZ2lubmluZyBvZiB0aGUgdGVzdCwgdGhlIHN0b3JhZ2Ugc2hvdWxkIGJlIGVtcHR5LlxuICBsZXQgcmVzdWx0ID0gYXdhaXQgdXJsU3RvcmFnZS5maW5kQWxsVXBsb2FkcygpXG4gIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoW10pXG5cbiAgLy8gQWRkIGEgZmV3IHVwbG9hZHMgaW50byB0aGUgc3RvcmFnZVxuICBjb25zdCBrZXkxID0gYXdhaXQgdXJsU3RvcmFnZS5hZGRVcGxvYWQoJ2ZpbmdlcnByaW50QScsIHsgaWQ6IDEgfSlcbiAgY29uc3Qga2V5MiA9IGF3YWl0IHVybFN0b3JhZ2UuYWRkVXBsb2FkKCdmaW5nZXJwcmludEEnLCB7IGlkOiAyIH0pXG4gIGNvbnN0IGtleTMgPSBhd2FpdCB1cmxTdG9yYWdlLmFkZFVwbG9hZCgnZmluZ2VycHJpbnRCJywgeyBpZDogMyB9KVxuXG4gIGV4cGVjdCgvXnR1czo6ZmluZ2VycHJpbnRBOjovLnRlc3Qoa2V5MSkpLnRvQmUodHJ1ZSlcbiAgZXhwZWN0KC9edHVzOjpmaW5nZXJwcmludEE6Oi8udGVzdChrZXkyKSkudG9CZSh0cnVlKVxuICBleHBlY3QoL150dXM6OmZpbmdlcnByaW50Qjo6Ly50ZXN0KGtleTMpKS50b0JlKHRydWUpXG5cbiAgLy8gUXVlcnkgdGhlIGp1c3Qgc3RvcmVkIHVwbG9hZHMgaW5kaXZpZHVhbGx5XG4gIHJlc3VsdCA9IGF3YWl0IHVybFN0b3JhZ2UuZmluZFVwbG9hZHNCeUZpbmdlcnByaW50KCdmaW5nZXJwcmludEEnKVxuICBzb3J0KHJlc3VsdClcbiAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChbXG4gICAgeyBpZDogMSwgdXJsU3RvcmFnZUtleToga2V5MSB9LFxuICAgIHsgaWQ6IDIsIHVybFN0b3JhZ2VLZXk6IGtleTIgfSxcbiAgXSlcblxuICByZXN1bHQgPSBhd2FpdCB1cmxTdG9yYWdlLmZpbmRVcGxvYWRzQnlGaW5nZXJwcmludCgnZmluZ2VycHJpbnRCJylcbiAgc29ydChyZXN1bHQpXG4gIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoW1xuICAgIHsgaWQ6IDMsIHVybFN0b3JhZ2VLZXk6IGtleTMgfSxcbiAgXSlcblxuICAvLyBDaGVjayB0aGF0IHdlIGNhbiByZXRyaWV2ZSBhbGwgc3RvcmVkIHVwbG9hZHNcbiAgcmVzdWx0ID0gYXdhaXQgdXJsU3RvcmFnZS5maW5kQWxsVXBsb2FkcygpXG4gIHNvcnQocmVzdWx0KVxuICBleHBlY3QocmVzdWx0KS50b0VxdWFsKFtcbiAgICB7IGlkOiAxLCB1cmxTdG9yYWdlS2V5OiBrZXkxIH0sXG4gICAgeyBpZDogMiwgdXJsU3RvcmFnZUtleToga2V5MiB9LFxuICAgIHsgaWQ6IDMsIHVybFN0b3JhZ2VLZXk6IGtleTMgfSxcbiAgXSlcblxuICAvLyBDaGVjayB0aGF0IGl0IGNhbiByZW1vdmUgYW4gdXBsb2FkIGFuZCB3aWxsIG5vdCByZXR1cm4gaXQgYmFja1xuICBhd2FpdCB1cmxTdG9yYWdlLnJlbW92ZVVwbG9hZChrZXkyKVxuICBhd2FpdCB1cmxTdG9yYWdlLnJlbW92ZVVwbG9hZChrZXkzKVxuXG4gIHJlc3VsdCA9IGF3YWl0IHVybFN0b3JhZ2UuZmluZFVwbG9hZHNCeUZpbmdlcnByaW50KCdmaW5nZXJwcmludEEnKVxuICBleHBlY3QocmVzdWx0KS50b0VxdWFsKFtcbiAgICB7IGlkOiAxLCB1cmxTdG9yYWdlS2V5OiBrZXkxIH0sXG4gIF0pXG5cbiAgcmVzdWx0ID0gYXdhaXQgdXJsU3RvcmFnZS5maW5kVXBsb2Fkc0J5RmluZ2VycHJpbnQoJ2ZpbmdlcnByaW50QicpXG4gIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoW10pXG59XG5cbi8vIFNvcnQgdGhlIHJlc3VsdHMgZnJvbSB0aGUgVVJMIHN0b3JhZ2Ugc2luY2UgdGhlIG9yZGVyIGluIG5vdCBkZXRlcm1pbmlzdGljLlxuZnVuY3Rpb24gc29ydCAocmVzdWx0KSB7XG4gIHJlc3VsdC5zb3J0KChhLCBiKSA9PiBhLmlkIC0gYi5pZClcbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIG1heC1jbGFzc2VzLXBlci1maWxlICovXG5jb25zdCBpc0Jyb3dzZXIgID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbmNvbnN0IGlzTm9kZSAgICAgPSAhaXNCcm93c2VyXG5cbi8qKlxuICogT2J0YWluIGEgcGxhdGZvcm0gc3BlY2lmaWMgYnVmZmVyIG9iamVjdCwgd2hpY2ggY2FuIGJlXG4gKiBoYW5kbGVkIGJ5IHR1cy1qcy1jbGllbnQuXG4gKi9cbmZ1bmN0aW9uIGdldEJsb2IgKHN0cikge1xuICBpZiAoaXNOb2RlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHN0cilcbiAgfVxuICByZXR1cm4gbmV3IEJsb2Ioc3RyLnNwbGl0KCcnKSlcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBwcm9taXNlIGFuZCBvYnRhaW4gdGhlIHJlc29sdmUvcmVqZWN0IGZ1bmN0aW9uc1xuICogb3V0c2lkZSBvZiB0aGUgUHJvbWlzZSBjYWxsYmFjay5cbiAqL1xuZnVuY3Rpb24gZmxhdFByb21pc2UgKCkge1xuICBsZXQgcmVzb2x2ZUZuXG4gIGxldCByZWplY3RGblxuICBjb25zdCBwID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHJlc29sdmVGbiA9IHJlc29sdmVcbiAgICByZWplY3RGbiA9IHJlamVjdFxuICB9KVxuXG4gIHJldHVybiBbcCwgcmVzb2x2ZUZuLCByZWplY3RGbl1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBzcHktYWJsZSBmdW5jdGlvbiB3aGljaCByZXNvbHZlcyBhIFByb21pc2VcbiAqIG9uY2UgaXQgaXMgY2FsbGVkLlxuICovXG5mdW5jdGlvbiB3YWl0YWJsZUZ1bmN0aW9uIChuYW1lID0gJ2Z1bmMnKSB7XG4gIGNvbnN0IFtwcm9taXNlLCByZXNvbHZlXSA9IGZsYXRQcm9taXNlKClcbiAgY29uc3QgZm4gPSBqYXNtaW5lLmNyZWF0ZVNweShuYW1lLCByZXNvbHZlKS5hbmQuY2FsbFRocm91Z2goKVxuXG4gIGZuLnRvQmVDYWxsZWQgPSBwcm9taXNlXG4gIHJldHVybiBmblxufVxuXG4vKipcbiAqIENyZWF0ZSBhIFByb21pc2UgdGhhdCByZXNvbHZlcyBhZnRlciB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uLlxuICovXG5mdW5jdGlvbiB3YWl0IChkZWxheSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXksICd0aW1lZCBvdXQnKSlcbn1cblxuLyoqXG4gKiBUZXN0SHR0cFN0YWNrIGltcGxlbWVudHMgdGhlIEhUVFAgc3RhY2sgaW50ZXJmYWNlIGZvciB0dXMtanMtY2xpZW50XG4gKiBhbmQgY2FuIGJlIHVzZWQgdG8gYXNzZXJ0IG91dGdvaW5nIHJlcXVlc3RzIGFuZCByZXNwb25kIHdpdGggbW9jayBkYXRhLlxuICovXG5jbGFzcyBUZXN0SHR0cFN0YWNrIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMuX3BlbmRpbmdSZXF1ZXN0cyA9IFtdXG4gICAgdGhpcy5fcGVuZGluZ1dhaXRzID0gW11cbiAgfVxuXG4gIGNyZWF0ZVJlcXVlc3QgKG1ldGhvZCwgdXJsKSB7XG4gICAgcmV0dXJuIG5ldyBUZXN0UmVxdWVzdChtZXRob2QsIHVybCwgKHJlcSkgPT4ge1xuICAgICAgaWYgKHRoaXMuX3BlbmRpbmdXYWl0cy5sZW5ndGggPj0gMSkge1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5fcGVuZGluZ1dhaXRzLnNoaWZ0KClcbiAgICAgICAgaGFuZGxlcihyZXEpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB0aGlzLl9wZW5kaW5nUmVxdWVzdHMucHVzaChyZXEpXG4gICAgfSlcbiAgfVxuXG4gIG5leHRSZXF1ZXN0ICgpIHtcbiAgICBpZiAodGhpcy5fcGVuZGluZ1JlcXVlc3RzLmxlbmd0aCA+PSAxKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX3BlbmRpbmdSZXF1ZXN0cy5zaGlmdCgpKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgdGhpcy5fcGVuZGluZ1dhaXRzLnB1c2gocmVzb2x2ZSlcbiAgICB9KVxuICB9XG59XG5cbmNsYXNzIFRlc3RSZXF1ZXN0IHtcbiAgY29uc3RydWN0b3IgKG1ldGhvZCwgdXJsLCBvblJlcXVlc3RTZW5kKSB7XG4gICAgdGhpcy5tZXRob2QgPSBtZXRob2RcbiAgICB0aGlzLnVybCA9IHVybFxuICAgIHRoaXMucmVxdWVzdEhlYWRlcnMgPSB7fVxuICAgIHRoaXMuYm9keSA9IG51bGxcblxuICAgIHRoaXMuX29uUmVxdWVzdFNlbmQgPSBvblJlcXVlc3RTZW5kXG4gICAgdGhpcy5fb25Qcm9ncmVzcyA9ICgpID0+IHt9O1xuXG4gICAgW3RoaXMuX3JlcXVlc3RQcm9taXNlLCB0aGlzLl9yZXNvbHZlUmVxdWVzdCwgdGhpcy5fcmVqZWN0UmVxdWVzdF0gPSBmbGF0UHJvbWlzZSgpXG4gIH1cblxuICBnZXRNZXRob2QgKCkge1xuICAgIHJldHVybiB0aGlzLm1ldGhvZFxuICB9XG5cbiAgZ2V0VVJMICgpIHtcbiAgICByZXR1cm4gdGhpcy51cmxcbiAgfVxuXG4gIHNldEhlYWRlciAoaGVhZGVyLCB2YWx1ZSkge1xuICAgIHRoaXMucmVxdWVzdEhlYWRlcnNbaGVhZGVyXSA9IHZhbHVlXG4gIH1cblxuICBnZXRIZWFkZXIgKGhlYWRlcikge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3RIZWFkZXJzW2hlYWRlcl0gfHwgbnVsbFxuICB9XG5cbiAgc2V0UHJvZ3Jlc3NIYW5kbGVyIChwcm9ncmVzc0hhbmRsZXIpIHtcbiAgICB0aGlzLl9vblByb2dyZXNzID0gcHJvZ3Jlc3NIYW5kbGVyXG4gIH1cblxuICBzZW5kIChib2R5ID0gbnVsbCkge1xuICAgIHRoaXMuYm9keSA9IGJvZHlcblxuICAgIGlmIChib2R5KSB7XG4gICAgICB0aGlzLl9vblByb2dyZXNzKDApXG4gICAgICB0aGlzLl9vblByb2dyZXNzKGJvZHkubGVuZ3RoIHx8IGJvZHkuc2l6ZSB8fCAwKVxuICAgIH1cblxuICAgIHRoaXMuX29uUmVxdWVzdFNlbmQodGhpcylcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdFByb21pc2VcbiAgfVxuXG4gIGFib3J0ICgpIHtcbiAgICB0aGlzLl9yZWplY3RSZXF1ZXN0KG5ldyBFcnJvcigncmVxdWVzdCBhYm9ydGVkJykpXG4gIH1cblxuICBnZXRVbmRlcmx5aW5nT2JqZWN0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpXG4gIH1cblxuICByZXNwb25kV2l0aCAocmVzRGF0YSkge1xuICAgIHJlc0RhdGEucmVzcG9uc2VIZWFkZXJzID0gcmVzRGF0YS5yZXNwb25zZUhlYWRlcnMgfHwge31cblxuICAgIGNvbnN0IHJlcyA9IG5ldyBUZXN0UmVzcG9uc2UocmVzRGF0YSlcbiAgICB0aGlzLl9yZXNvbHZlUmVxdWVzdChyZXMpXG4gIH1cblxuICByZXNwb25zZUVycm9yIChlcnIpIHtcbiAgICB0aGlzLl9yZWplY3RSZXF1ZXN0KGVycilcbiAgfVxufVxuXG5jbGFzcyBUZXN0UmVzcG9uc2Uge1xuICBjb25zdHJ1Y3RvciAocmVzKSB7XG4gICAgdGhpcy5fcmVzcG9uc2UgPSByZXNcbiAgfVxuXG4gIGdldFN0YXR1cyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc3BvbnNlLnN0YXR1c1xuICB9XG5cbiAgZ2V0SGVhZGVyIChoZWFkZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzcG9uc2UucmVzcG9uc2VIZWFkZXJzW2hlYWRlcl1cbiAgfVxuXG4gIGdldEJvZHkgKCkge1xuICAgIHJldHVybiB0aGlzLl9yZXNwb25zZS5yZXNwb25zZVRleHRcbiAgfVxuXG4gIGdldFVuZGVybHlpbmdPYmplY3QgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgVGVzdEh0dHBTdGFjayxcbiAgd2FpdGFibGVGdW5jdGlvbixcbiAgd2FpdCxcbiAgZ2V0QmxvYixcbn1cbiIsImNvbnN0IGFzc2VydFVybFN0b3JhZ2UgPSByZXF1aXJlKCcuL2hlbHBlcnMvYXNzZXJ0VXJsU3RvcmFnZScpXG5jb25zdCB7IFRlc3RIdHRwU3RhY2ssIHdhaXRhYmxlRnVuY3Rpb24sIHdhaXQgfSA9IHJlcXVpcmUoJy4vaGVscGVycy91dGlscycpXG5jb25zdCB0dXMgPSByZXF1aXJlKCcuLi8uLicpXG5cbmRlc2NyaWJlKCd0dXMnLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGxvY2FsU3RvcmFnZS5jbGVhcigpXG4gIH0pXG5cbiAgZGVzY3JpYmUoJyNVcGxvYWQnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXN1bWUgYW4gdXBsb2FkIGZyb20gYSBzdG9yZWQgdXJsJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3R1czo6ZmluZ2VycHJpbnRlZDo6MTMzNycsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgdXBsb2FkVXJsOiAnaHR0cDovL3R1cy5pby91cGxvYWRzL3Jlc3VtaW5nJyxcbiAgICAgIH0pKVxuXG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICBjb25zdCBmaWxlID0gbmV3IEJsb2IoJ2hlbGxvIHdvcmxkJy5zcGxpdCgnJykpXG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQgOiAnaHR0cDovL3R1cy5pby91cGxvYWRzJyxcbiAgICAgICAgb25Qcm9ncmVzcyAoKSB7fSxcbiAgICAgICAgZmluZ2VycHJpbnQgKCkge30sXG4gICAgICB9XG4gICAgICBzcHlPbihvcHRpb25zLCAnZmluZ2VycHJpbnQnKS5hbmQucmVzb2x2ZVRvKCdmaW5nZXJwcmludGVkJylcbiAgICAgIHNweU9uKG9wdGlvbnMsICdvblByb2dyZXNzJylcblxuICAgICAgY29uc3QgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucylcblxuICAgICAgY29uc3QgcHJldmlvdXNVcGxvYWRzID0gYXdhaXQgdXBsb2FkLmZpbmRQcmV2aW91c1VwbG9hZHMoKVxuICAgICAgZXhwZWN0KHByZXZpb3VzVXBsb2FkcykudG9FcXVhbChbe1xuICAgICAgICB1cGxvYWRVcmwgICAgOiAnaHR0cDovL3R1cy5pby91cGxvYWRzL3Jlc3VtaW5nJyxcbiAgICAgICAgdXJsU3RvcmFnZUtleTogJ3R1czo6ZmluZ2VycHJpbnRlZDo6MTMzNycsXG4gICAgICB9XSlcbiAgICAgIHVwbG9hZC5yZXN1bWVGcm9tUHJldmlvdXNVcGxvYWQocHJldmlvdXNVcGxvYWRzWzBdKVxuXG4gICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICBleHBlY3Qob3B0aW9ucy5maW5nZXJwcmludCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoZmlsZSwgdXBsb2FkLm9wdGlvbnMpXG5cbiAgICAgIGxldCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9yZXN1bWluZycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnSEVBRCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICdVcGxvYWQtTGVuZ3RoJzogMTEsXG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAzLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMvcmVzdW1pbmcnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLU9mZnNldCddKS50b0JlKDMpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXSkudG9CZSgnYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbScpXG4gICAgICBleHBlY3QocmVxLmJvZHkuc2l6ZSkudG9CZSgxMSAtIDMpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDExLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgZXhwZWN0KHVwbG9hZC51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9yZXN1bWluZycpXG4gICAgICBleHBlY3Qob3B0aW9ucy5vblByb2dyZXNzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgxMSwgMTEpXG4gICAgfSlcblxuICAgIGRlc2NyaWJlKCdzdG9yaW5nIG9mIHVwbG9hZCB1cmxzJywgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50IDogJ2h0dHA6Ly90dXMuaW8vdXBsb2FkcycsXG4gICAgICAgIGZpbmdlcnByaW50ICgpIHt9LFxuICAgICAgfVxuXG4gICAgICBhc3luYyBmdW5jdGlvbiBzdGFydFVwbG9hZCAoKSB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSBuZXcgQmxvYignaGVsbG8gd29ybGQnLnNwbGl0KCcnKSlcbiAgICAgICAgc3B5T24ob3B0aW9ucywgJ2ZpbmdlcnByaW50JykuYW5kLnJlc29sdmVUbygnZmluZ2VycHJpbnRlZCcpXG4gICAgICAgIG9wdGlvbnMub25TdWNjZXNzID0gd2FpdGFibGVGdW5jdGlvbignb25TdWNjZXNzJylcblxuICAgICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKVxuICAgICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICAgIGV4cGVjdChvcHRpb25zLmZpbmdlcnByaW50KS50b0hhdmVCZWVuQ2FsbGVkKClcblxuICAgICAgICBjb25zdCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDEsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICBMb2NhdGlvbjogJy91cGxvYWRzL2JsYXJnaCcsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICAvLyBXYWl0IGEgc2hvcnQgZGVsYXkgdG8gYWxsb3cgdGhlIFByb21pc2VzIHRvIHNldHRsZVxuICAgICAgICBhd2FpdCB3YWl0KDEwKVxuICAgICAgfVxuXG4gICAgICBhc3luYyBmdW5jdGlvbiBmaW5pc2hVcGxvYWQgKCkge1xuICAgICAgICBjb25zdCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaCcpXG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMTEsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICBhd2FpdCBvcHRpb25zLm9uU3VjY2Vzcy50b0JlQ2FsbGVkXG4gICAgICB9XG5cbiAgICAgIGl0KCdzaG91bGQgc3RvcmUgYW5kIHJldGFpbiB3aXRoIGRlZmF1bHQgb3B0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgb3B0aW9ucy5yZW1vdmVGaW5nZXJwcmludE9uU3VjY2VzcyA9IGZhbHNlXG4gICAgICAgIGF3YWl0IHN0YXJ0VXBsb2FkKClcblxuICAgICAgICBjb25zdCBrZXkgPSBsb2NhbFN0b3JhZ2Uua2V5KDApXG4gICAgICAgIGV4cGVjdChrZXkuaW5kZXhPZigndHVzOjpmaW5nZXJwcmludGVkOjonKSkudG9CZSgwKVxuXG4gICAgICAgIGNvbnN0IHN0b3JlZFVwbG9hZCA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KSlcbiAgICAgICAgZXhwZWN0KHN0b3JlZFVwbG9hZC51cGxvYWRVcmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2gnKVxuICAgICAgICBleHBlY3Qoc3RvcmVkVXBsb2FkLnNpemUpLnRvQmUoMTEpXG5cbiAgICAgICAgYXdhaXQgZmluaXNoVXBsb2FkKClcblxuICAgICAgICBleHBlY3QobG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KSkudG9CZShKU09OLnN0cmluZ2lmeShzdG9yZWRVcGxvYWQpKVxuICAgICAgfSlcblxuICAgICAgaXQoJ3Nob3VsZCBzdG9yZSBhbmQgcmVtb3ZlIHdpdGggb3B0aW9uIHJlbW92ZUZpbmdlcnByaW50T25TdWNjZXNzIHNldCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgb3B0aW9ucy5yZW1vdmVGaW5nZXJwcmludE9uU3VjY2VzcyA9IHRydWVcbiAgICAgICAgYXdhaXQgc3RhcnRVcGxvYWQoKVxuXG4gICAgICAgIGNvbnN0IGtleSA9IGxvY2FsU3RvcmFnZS5rZXkoMClcbiAgICAgICAgZXhwZWN0KGtleS5pbmRleE9mKCd0dXM6OmZpbmdlcnByaW50ZWQ6OicpKS50b0JlKDApXG5cbiAgICAgICAgY29uc3Qgc3RvcmVkVXBsb2FkID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpKVxuICAgICAgICBleHBlY3Qoc3RvcmVkVXBsb2FkLnVwbG9hZFVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaCcpXG4gICAgICAgIGV4cGVjdChzdG9yZWRVcGxvYWQuc2l6ZSkudG9CZSgxMSlcblxuICAgICAgICBhd2FpdCBmaW5pc2hVcGxvYWQoKVxuICAgICAgICBleHBlY3QobG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KSkudG9CZShudWxsKVxuICAgICAgfSlcblxuICAgICAgaXQoJ3Nob3VsZCBzdG9yZSBVUkxzIHBhc3NlZCBpbiB1c2luZyB0aGUgdXBsb2FkVXJsIG9wdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgZmlsZSA9IG5ldyBCbG9iKCdoZWxsbyB3b3JsZCcuc3BsaXQoJycpKVxuICAgICAgICBjb25zdCBvcHRpb25zMiA9IHtcbiAgICAgICAgICBodHRwU3RhY2sgICAgICAgICAgICAgICAgIDogdGVzdFN0YWNrLFxuICAgICAgICAgIHVwbG9hZFVybCAgICAgICAgICAgICAgICAgOiAnaHR0cDovL3R1cy5pby91cGxvYWRzL3N0b3JlZFVybCcsXG4gICAgICAgICAgZmluZ2VycHJpbnQgKCkge30sXG4gICAgICAgICAgb25TdWNjZXNzICAgICAgICAgICAgICAgICA6IHdhaXRhYmxlRnVuY3Rpb24oJ29uU3VjY2VzcycpLFxuICAgICAgICAgIHJlbW92ZUZpbmdlcnByaW50T25TdWNjZXNzOiB0cnVlLFxuICAgICAgICB9XG4gICAgICAgIHNweU9uKG9wdGlvbnMyLCAnZmluZ2VycHJpbnQnKS5hbmQucmVzb2x2ZVRvKCdmaW5nZXJwcmludGVkJylcblxuICAgICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zMilcbiAgICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgICBleHBlY3Qob3B0aW9uczIuZmluZ2VycHJpbnQpLnRvSGF2ZUJlZW5DYWxsZWQoKVxuXG4gICAgICAgIGxldCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzL3N0b3JlZFVybCcpXG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdIRUFEJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgICdVcGxvYWQtTGVuZ3RoJzogMTEsXG4gICAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDMsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICAvLyBXYWl0IGEgc2hvcnQgZGVsYXkgdG8gYWxsb3cgdGhlIFByb21pc2VzIHRvIHNldHRsZVxuICAgICAgICBhd2FpdCB3YWl0KDEwKVxuXG4gICAgICAgIGNvbnN0IGtleSA9IGxvY2FsU3RvcmFnZS5rZXkoMClcbiAgICAgICAgZXhwZWN0KGtleS5pbmRleE9mKCd0dXM6OmZpbmdlcnByaW50ZWQ6OicpKS50b0JlKDApXG5cbiAgICAgICAgY29uc3Qgc3RvcmVkVXBsb2FkID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpKVxuICAgICAgICBleHBlY3Qoc3RvcmVkVXBsb2FkLnVwbG9hZFVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzL3N0b3JlZFVybCcpXG4gICAgICAgIGV4cGVjdChzdG9yZWRVcGxvYWQuc2l6ZSkudG9CZSgxMSlcblxuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzL3N0b3JlZFVybCcpXG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtT2Zmc2V0J10pLnRvQmUoMylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snQ29udGVudC1UeXBlJ10pLnRvQmUoJ2FwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW0nKVxuICAgICAgICBleHBlY3QocmVxLmJvZHkuc2l6ZSkudG9CZSgxMSAtIDMpXG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMTEsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICBhd2FpdCBvcHRpb25zMi5vblN1Y2Nlc3MudG9CZUNhbGxlZFxuXG4gICAgICAgIC8vIEVudHJ5IGluIGxvY2FsU3RvcmFnZSBzaG91bGQgYmUgcmVtb3ZlZCBhZnRlciBzdWNjZXNzZnVsIHVwbG9hZFxuICAgICAgICBleHBlY3QobG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KSkudG9CZShudWxsKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBkZWxldGUgdXBsb2FkIHVybHMgb24gYSA0WFgnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICBjb25zdCBmaWxlID0gbmV3IEJsb2IoJ2hlbGxvIHdvcmxkJy5zcGxpdCgnJykpXG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQgOiAnaHR0cDovL3R1cy5pby91cGxvYWRzJyxcbiAgICAgICAgZmluZ2VycHJpbnQgKCkge30sXG4gICAgICB9XG4gICAgICBzcHlPbihvcHRpb25zLCAnZmluZ2VycHJpbnQnKS5hbmQucmVzb2x2ZVRvKCdmaW5nZXJwcmludGVkJylcblxuICAgICAgY29uc3QgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucylcblxuICAgICAgdXBsb2FkLnJlc3VtZUZyb21QcmV2aW91c1VwbG9hZCh7XG4gICAgICAgIHVwbG9hZFVybCAgICA6ICdodHRwOi8vdHVzLmlvL3VwbG9hZHMvcmVzdW1pbmcnLFxuICAgICAgICB1cmxTdG9yYWdlS2V5OiAndHVzOjpmaW5nZXJwcmludGVkOjoxMzM3JyxcbiAgICAgIH0pXG5cbiAgICAgIHVwbG9hZC5zdGFydCgpXG5cbiAgICAgIGNvbnN0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzL3Jlc3VtaW5nJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdIRUFEJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiA0MDAsXG4gICAgICB9KVxuXG4gICAgICBhd2FpdCB3YWl0KDEwKVxuXG4gICAgICBleHBlY3QobG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3R1czo6ZmluZ2VycHJpbnRlZDo6MTMzNycpKS50b0JlKG51bGwpXG4gICAgfSlcblxuICAgIGRlc2NyaWJlKCd1cGxvYWRpbmcgZGF0YSBmcm9tIGEgUmVhZGVyJywgKCkgPT4ge1xuICAgICAgZnVuY3Rpb24gbWFrZVJlYWRlciAoY29udGVudCwgcmVhZFNpemUgPSBjb250ZW50Lmxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSB7XG4gICAgICAgICAgdmFsdWU6IGNvbnRlbnQuc3BsaXQoJycpLFxuICAgICAgICAgIHJlYWQgKCkge1xuICAgICAgICAgICAgbGV0IHZhbHVlXG4gICAgICAgICAgICBsZXQgZG9uZSA9IGZhbHNlXG4gICAgICAgICAgICBpZiAodGhpcy52YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gdGhpcy52YWx1ZS5zbGljZSgwLCByZWFkU2l6ZSlcbiAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudmFsdWUuc2xpY2UocmVhZFNpemUpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkb25lID0gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IHZhbHVlLCBkb25lIH0pXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjYW5jZWw6IHdhaXRhYmxlRnVuY3Rpb24oJ2NhbmNlbCcpLFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlYWRlclxuICAgICAgfVxuXG4gICAgICBhc3luYyBmdW5jdGlvbiBhc3NlcnRSZWFkZXJVcGxvYWQgKHsgcmVhZFNpemUsIGNodW5rU2l6ZSB9KSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IG1ha2VSZWFkZXIoJ2hlbGxvIHdvcmxkJywgcmVhZFNpemUpXG5cbiAgICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgIGh0dHBTdGFjayAgICAgICAgICAgOiB0ZXN0U3RhY2ssXG4gICAgICAgICAgZW5kcG9pbnQgICAgICAgICAgICA6ICdodHRwOi8vdHVzLmlvL3VwbG9hZHMnLFxuICAgICAgICAgIGNodW5rU2l6ZSxcbiAgICAgICAgICBvblByb2dyZXNzICAgICAgICAgIDogd2FpdGFibGVGdW5jdGlvbignb25Qcm9ncmVzcycpLFxuICAgICAgICAgIG9uU3VjY2VzcyAgICAgICAgICAgOiB3YWl0YWJsZUZ1bmN0aW9uKCdvblN1Y2Nlc3MnKSxcbiAgICAgICAgICBmaW5nZXJwcmludCAoKSB7fSxcbiAgICAgICAgICB1cGxvYWRMZW5ndGhEZWZlcnJlZDogdHJ1ZSxcbiAgICAgICAgfVxuICAgICAgICBzcHlPbihvcHRpb25zLCAnZmluZ2VycHJpbnQnKS5hbmQucmVzb2x2ZVRvKCdmaW5nZXJwcmludGVkJylcblxuICAgICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChyZWFkZXIsIG9wdGlvbnMpXG4gICAgICAgIHVwbG9hZC5zdGFydCgpXG5cbiAgICAgICAgZXhwZWN0KG9wdGlvbnMuZmluZ2VycHJpbnQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHJlYWRlciwgdXBsb2FkLm9wdGlvbnMpXG5cbiAgICAgICAgbGV0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMnKVxuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1MZW5ndGgnXSkudG9CZSh1bmRlZmluZWQpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1EZWZlci1MZW5ndGgnXSkudG9CZSgxKVxuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDEsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICBMb2NhdGlvbjogJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2gnLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2gnKVxuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtT2Zmc2V0J10pLnRvQmUoMClcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snQ29udGVudC1UeXBlJ10pLnRvQmUoJ2FwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW0nKVxuICAgICAgICBleHBlY3QocmVxLmJvZHkubGVuZ3RoKS50b0JlKDExKVxuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDExLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgYXdhaXQgb3B0aW9ucy5vblByb2dyZXNzLnRvQmVDYWxsZWRcbiAgICAgICAgZXhwZWN0KG9wdGlvbnMub25Qcm9ncmVzcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMTEsIG51bGwpXG5cbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2gnKVxuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtT2Zmc2V0J10pLnRvQmUoMTEpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1MZW5ndGgnXSkudG9CZSgxMSlcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snQ29udGVudC1UeXBlJ10pLnRvQmUoJ2FwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW0nKVxuICAgICAgICBleHBlY3QocmVxLmJvZHkpLnRvQmUobnVsbClcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAxMSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuXG4gICAgICAgIGF3YWl0IG9wdGlvbnMub25TdWNjZXNzLnRvQmVDYWxsZWRcbiAgICAgICAgZXhwZWN0KHVwbG9hZC51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2gnKVxuICAgICAgICBleHBlY3Qob3B0aW9ucy5vblByb2dyZXNzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgxMSwgMTEpXG4gICAgICB9XG5cbiAgICAgIGl0KCdzaG91bGQgdXBsb2FkIGRhdGEnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IGFzc2VydFJlYWRlclVwbG9hZCh7IGNodW5rU2l6ZTogMTAwLCByZWFkU2l6ZTogMTAwIH0pXG4gICAgICB9KVxuXG4gICAgICBpdCgnc2hvdWxkIHJlYWQgbXVsdGlwbGUgdGltZXMgZnJvbSB0aGUgcmVhZGVyJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCBhc3NlcnRSZWFkZXJVcGxvYWQoeyBjaHVua1NpemU6IDEwMCwgcmVhZFNpemU6IDYgfSlcbiAgICAgIH0pXG5cbiAgICAgIGl0KCdzaG91bGQgdXNlIG11bHRpcGxlIFBBVENIIHJlcXVlc3RzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBtYWtlUmVhZGVyKCdoZWxsbyB3b3JsZCcsIDEpXG5cbiAgICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgIGh0dHBTdGFjayAgICAgICAgICAgOiB0ZXN0U3RhY2ssXG4gICAgICAgICAgZW5kcG9pbnQgICAgICAgICAgICA6ICdodHRwOi8vdHVzLmlvL3VwbG9hZHMnLFxuICAgICAgICAgIGNodW5rU2l6ZSAgICAgICAgICAgOiA2LFxuICAgICAgICAgIG9uUHJvZ3Jlc3MgICAgICAgICAgOiB3YWl0YWJsZUZ1bmN0aW9uKCdvblByb2dyZXNzJyksXG4gICAgICAgICAgb25TdWNjZXNzICAgICAgICAgICA6IHdhaXRhYmxlRnVuY3Rpb24oJ29uU3VjY2VzcycpLFxuICAgICAgICAgIGZpbmdlcnByaW50ICgpIHt9LFxuICAgICAgICAgIHVwbG9hZExlbmd0aERlZmVycmVkOiB0cnVlLFxuICAgICAgICB9XG4gICAgICAgIHNweU9uKG9wdGlvbnMsICdmaW5nZXJwcmludCcpLmFuZC5yZXNvbHZlVG8oJ2ZpbmdlcnByaW50ZWQnKVxuXG4gICAgICAgIGNvbnN0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKHJlYWRlciwgb3B0aW9ucylcbiAgICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgICBleHBlY3Qob3B0aW9ucy5maW5nZXJwcmludCkudG9IYXZlQmVlbkNhbGxlZFdpdGgocmVhZGVyLCB1cGxvYWQub3B0aW9ucylcblxuICAgICAgICBsZXQgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2FkcycpXG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQT1NUJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLUxlbmd0aCddKS50b0JlKHVuZGVmaW5lZClcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLURlZmVyLUxlbmd0aCddKS50b0JlKDEpXG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwMSxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgIExvY2F0aW9uOiAnaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaCcsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaCcpXG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1PZmZzZXQnXSkudG9CZSgwKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXSkudG9CZSgnYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbScpXG4gICAgICAgIGV4cGVjdChyZXEuYm9keS5sZW5ndGgpLnRvQmUoNilcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiA2LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgYXdhaXQgb3B0aW9ucy5vblByb2dyZXNzLnRvQmVDYWxsZWRcbiAgICAgICAgZXhwZWN0KG9wdGlvbnMub25Qcm9ncmVzcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNiwgbnVsbClcblxuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaCcpXG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtT2Zmc2V0J10pLnRvQmUoNilcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snQ29udGVudC1UeXBlJ10pLnRvQmUoJ2FwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW0nKVxuICAgICAgICBleHBlY3QocmVxLmJvZHkubGVuZ3RoKS50b0JlKDUpXG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMTEsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaCcpXG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1PZmZzZXQnXSkudG9CZSgxMSlcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLUxlbmd0aCddKS50b0JlKDExKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXSkudG9CZSgnYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbScpXG4gICAgICAgIGV4cGVjdChyZXEuYm9keSkudG9CZShudWxsKVxuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDExLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgYXdhaXQgb3B0aW9ucy5vblN1Y2Nlc3MudG9CZUNhbGxlZFxuICAgICAgICBleHBlY3QodXBsb2FkLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaCcpXG4gICAgICAgIGV4cGVjdChvcHRpb25zLm9uUHJvZ3Jlc3MpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDExLCAxMSlcbiAgICAgIH0pXG5cbiAgICAgIGl0KCdzaG91bGQgcmV0cnkgdGhlIFBPU1QgcmVxdWVzdCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gbWFrZVJlYWRlcignaGVsbG8gd29ybGQnLCAxKVxuXG4gICAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICBodHRwU3RhY2sgICAgICAgICAgIDogdGVzdFN0YWNrLFxuICAgICAgICAgIGVuZHBvaW50ICAgICAgICAgICAgOiAnaHR0cDovL3R1cy5pby9maWxlcy8nLFxuICAgICAgICAgIGNodW5rU2l6ZSAgICAgICAgICAgOiAxMSxcbiAgICAgICAgICByZXRyeURlbGF5cyAgICAgICAgIDogWzEwLCAxMCwgMTBdLFxuICAgICAgICAgIG9uU3VjY2VzcyAgICAgICAgICAgOiB3YWl0YWJsZUZ1bmN0aW9uKCdvblN1Y2Nlc3MnKSxcbiAgICAgICAgICB1cGxvYWRMZW5ndGhEZWZlcnJlZDogdHJ1ZSxcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKHJlYWRlciwgb3B0aW9ucylcbiAgICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgICBsZXQgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDEsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICBMb2NhdGlvbjogJy9maWxlcy9mb28nLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvZm9vJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAxMSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuXG4gICAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL2ZvbycpXG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1MZW5ndGgnXSkudG9CZSgxMSlcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAxMSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuXG4gICAgICAgIGF3YWl0IG9wdGlvbnMub25TdWNjZXNzLnRvQmVDYWxsZWRcbiAgICAgIH0pXG5cbiAgICAgIGl0KCdzaG91bGQgcmV0cnkgdGhlIGZpcnN0IFBBVENIIHJlcXVlc3QnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IG1ha2VSZWFkZXIoJ2hlbGxvIHdvcmxkJywgMSlcblxuICAgICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgaHR0cFN0YWNrICAgICAgICAgICA6IHRlc3RTdGFjayxcbiAgICAgICAgICBlbmRwb2ludCAgICAgICAgICAgIDogJ2h0dHA6Ly90dXMuaW8vZmlsZXMvJyxcbiAgICAgICAgICBjaHVua1NpemUgICAgICAgICAgIDogMTEsXG4gICAgICAgICAgcmV0cnlEZWxheXMgICAgICAgICA6IFsxMCwgMTAsIDEwXSxcbiAgICAgICAgICBvblN1Y2Nlc3MgICAgICAgICAgIDogd2FpdGFibGVGdW5jdGlvbignb25TdWNjZXNzJyksXG4gICAgICAgICAgdXBsb2FkTGVuZ3RoRGVmZXJyZWQ6IHRydWUsXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChyZWFkZXIsIG9wdGlvbnMpXG4gICAgICAgIHVwbG9hZC5zdGFydCgpXG5cbiAgICAgICAgbGV0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzLycpXG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQT1NUJylcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1cyAgICAgICAgIDogMjAxLFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgTG9jYXRpb246ICcvZmlsZXMvZm9vJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuXG4gICAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL2ZvbycpXG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXM6IDUwMCxcbiAgICAgICAgfSlcblxuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy9mb28nKVxuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnSEVBRCcpXG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMCxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuXG4gICAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL2ZvbycpXG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMTEsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy9mb28nKVxuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtTGVuZ3RoJ10pLnRvQmUoMTEpXG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMTEsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICBhd2FpdCBvcHRpb25zLm9uU3VjY2Vzcy50b0JlQ2FsbGVkXG4gICAgICB9KVxuXG4gICAgICBpdCgnc2hvdWxkIHJldHJ5IGZvbGxvd2luZyBQQVRDSCByZXF1ZXN0cycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gbWFrZVJlYWRlcignaGVsbG8gd29ybGQgdGhlcmUhJylcblxuICAgICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgaHR0cFN0YWNrICAgICAgICAgICA6IHRlc3RTdGFjayxcbiAgICAgICAgICBlbmRwb2ludCAgICAgICAgICAgIDogJ2h0dHA6Ly90dXMuaW8vZmlsZXMvJyxcbiAgICAgICAgICBjaHVua1NpemUgICAgICAgICAgIDogNixcbiAgICAgICAgICByZXRyeURlbGF5cyAgICAgICAgIDogWzEwLCAxMCwgMTBdLFxuICAgICAgICAgIG9uU3VjY2VzcyAoKSB7fSxcbiAgICAgICAgICB1cGxvYWRMZW5ndGhEZWZlcnJlZDogdHJ1ZSxcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKHJlYWRlciwgb3B0aW9ucylcbiAgICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgICBsZXQgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDEsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICBMb2NhdGlvbjogJy9maWxlcy9mb28nLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvZm9vJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiA2LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvZm9vJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgICB9KVxuXG4gICAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL2ZvbycpXG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdIRUFEJylcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiA2LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvZm9vJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAxMixcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuXG4gICAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL2ZvbycpXG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMTgsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy9mb28nKVxuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtTGVuZ3RoJ10pLnRvQmUoMTgpXG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMTgsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICBhd2FpdCBvcHRpb25zLm9uU3VjY2Vzcy50b0JlQ2FsbGVkXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBkZXNjcmliZSgncmVzb2x2aW5nIG9mIFVSSXMnLCAoKSA9PiB7XG4gICAgICAvLyBEaXNhYmxlIHRoZXNlIHRlc3RzIGZvciBJRSAxMCBhbmQgMTEgYmVjYXVzZSBpdCdzIG5vdCBwb3NzaWJsZSB0byBvdmVyd3JpdGVcbiAgICAgIC8vIHRoZSBuYXZpZ2F0b3IucHJvZHVjdCBwcm9wZXJ0eS5cbiAgICAgIGNvbnN0IGlzSUUgPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ1RyaWRlbnQvJykgPiAwXG4gICAgICBpZiAoaXNJRSkge1xuICAgICAgICBjb25zb2xlLmxvZygnU2tpcHBpbmcgdGVzdHMgZm9yIFJlYWN0IE5hdGl2ZSBpbiBJbnRlcm5ldCBFeHBsb3JlcicpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3JpZ2luYWxQcm9kdWN0ID0gbmF2aWdhdG9yLnByb2R1Y3RcblxuICAgICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICAgIGphc21pbmUuQWpheC5pbnN0YWxsKClcbiAgICAgICAgLy8gU2ltdWxhdGUgUmVhY3QgTmF0aXZlIGVudmlyb25tZW50IHRvIGVuYWJsZSBVUklzIGFzIGlucHV0IG9iamVjdHMuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuYXZpZ2F0b3IsICdwcm9kdWN0Jywge1xuICAgICAgICAgIHZhbHVlICAgICAgIDogJ1JlYWN0TmF0aXZlJyxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIH0pXG4gICAgICB9KVxuXG4gICAgICBhZnRlckVhY2goKCkgPT4ge1xuICAgICAgICBqYXNtaW5lLkFqYXgudW5pbnN0YWxsKClcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5hdmlnYXRvciwgJ3Byb2R1Y3QnLCB7XG4gICAgICAgICAgdmFsdWUgICAgICAgOiBvcmlnaW5hbFByb2R1Y3QsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB9KVxuICAgICAgfSlcblxuICAgICAgaXQoJ3Nob3VsZCB1cGxvYWQgYSBmaWxlIGZyb20gYW4gVVJJJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBmaWxlID0ge1xuICAgICAgICAgIHVyaTogJ2ZpbGU6Ly8vbXkvZmlsZS5kYXQnLFxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgICBlbmRwb2ludCA6ICdodHRwOi8vdHVzLmlvL3VwbG9hZHMnLFxuICAgICAgICAgIG9uU3VjY2Vzczogd2FpdGFibGVGdW5jdGlvbignb25TdWNjZXNzJyksXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKVxuICAgICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICAgIC8vIFdhaXQgYSBzaG9ydCBpbnRlcnZhbCB0byBtYWtlIHN1cmUgdGhhdCB0aGUgWEhSIGhhcyBiZWVuIHNlbnQuXG4gICAgICAgIGF3YWl0IHdhaXQoMClcblxuICAgICAgICBsZXQgcmVxID0gamFzbWluZS5BamF4LnJlcXVlc3RzLm1vc3RSZWNlbnQoKVxuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnZmlsZTovLy9teS9maWxlLmRhdCcpXG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdHRVQnKVxuICAgICAgICBleHBlY3QocmVxLnJlc3BvbnNlVHlwZSkudG9CZSgnYmxvYicpXG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwMCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgICdVcGxvYWQtTGVuZ3RoJzogMTEsXG4gICAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDMsXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNwb25zZTogbmV3IEJsb2IoJ2hlbGxvIHdvcmxkJy5zcGxpdCgnJykpLFxuICAgICAgICB9KVxuXG4gICAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMnKVxuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1MZW5ndGgnXSkudG9CZSgxMSlcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1cyAgICAgICAgIDogMjAxLFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgTG9jYXRpb246ICcvdXBsb2Fkcy9ibGFyZ2gnLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2gnKVxuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLU9mZnNldCddKS50b0JlKDApXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKS50b0JlKCdhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtJylcbiAgICAgICAgZXhwZWN0KHJlcS5ib2R5LnNpemUpLnRvQmUoMTEpXG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMTEsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICBhd2FpdCBvcHRpb25zLm9uU3VjY2Vzcy50b0JlQ2FsbGVkXG4gICAgICAgIGV4cGVjdCh1cGxvYWQudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoJylcbiAgICAgIH0pXG5cbiAgICAgIGl0KFwic2hvdWxkIGVtaXQgYW4gZXJyb3IgaWYgaXQgY2FuJ3QgcmVzb2x2ZSB0aGUgVVJJXCIsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgZmlsZSA9IHtcbiAgICAgICAgICB1cmk6ICdmaWxlOi8vL215L2ZpbGUuZGF0JyxcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgIGVuZHBvaW50OiAnaHR0cDovL3R1cy5pby91cGxvYWRzJyxcbiAgICAgICAgICBvbkVycm9yIDogd2FpdGFibGVGdW5jdGlvbignb25FcnJvcicpLFxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucylcbiAgICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgICAvLyBXYWl0IGEgc2hvcnQgaW50ZXJ2YWwgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIFhIUiBoYXMgYmVlbiBzZW50LlxuICAgICAgICBhd2FpdCB3YWl0KDApXG5cbiAgICAgICAgY29uc3QgcmVxID0gamFzbWluZS5BamF4LnJlcXVlc3RzLm1vc3RSZWNlbnQoKVxuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnZmlsZTovLy9teS9maWxlLmRhdCcpXG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdHRVQnKVxuICAgICAgICBleHBlY3QocmVxLnJlc3BvbnNlVHlwZSkudG9CZSgnYmxvYicpXG5cbiAgICAgICAgcmVxLnJlc3BvbnNlRXJyb3IoKVxuXG4gICAgICAgIGF3YWl0IG9wdGlvbnMub25FcnJvci50b0JlQ2FsbGVkXG4gICAgICAgIGV4cGVjdChvcHRpb25zLm9uRXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKG5ldyBFcnJvcigndHVzOiBjYW5ub3QgZmV0Y2ggYGZpbGUudXJpYCBhcyBCbG9iLCBtYWtlIHN1cmUgdGhlIHVyaSBpcyBjb3JyZWN0IGFuZCBhY2Nlc3NpYmxlLiBbb2JqZWN0IE9iamVjdF0nKSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnI0xvY2FsU3RvcmFnZVVybFN0b3JhZ2UnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBhbGxvdyBzdG9yaW5nIGFuZCByZXRyaWV2aW5nIHVwbG9hZHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBhc3NlcnRVcmxTdG9yYWdlKHR1cy5kZWZhdWx0T3B0aW9ucy51cmxTdG9yYWdlKVxuICAgIH0pXG4gIH0pXG59KVxuIiwiY29uc3QgeyBUZXN0SHR0cFN0YWNrLCB3YWl0YWJsZUZ1bmN0aW9uLCB3YWl0LCBnZXRCbG9iIH0gPSByZXF1aXJlKCcuL2hlbHBlcnMvdXRpbHMnKVxuY29uc3QgdHVzID0gcmVxdWlyZSgnLi4vLi4nKVxuXG4vLyBVbmNvbW1lbnQgdG8gZW5hYmxlIGRlYnVnIGxvZyBmcm9tIHR1cy1qcy1jbGllbnRcbi8vIHR1cy5lbmFibGVEZWJ1Z0xvZygpO1xuXG5kZXNjcmliZSgndHVzJywgKCkgPT4ge1xuICBkZXNjcmliZSgnI2lzU3VwcG9ydGVkJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgYmUgdHJ1ZScsICgpID0+IHtcbiAgICAgIGV4cGVjdCh0dXMuaXNTdXBwb3J0ZWQpLnRvQmUodHJ1ZSlcbiAgICB9KVxuICB9KVxuXG4gIGRlc2NyaWJlKCcjVXBsb2FkJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgdGhyb3cgaWYgbm8gZXJyb3IgaGFuZGxlciBpcyBhdmFpbGFibGUnLCAoKSA9PiB7XG4gICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChudWxsKVxuICAgICAgZXhwZWN0KHVwbG9hZC5zdGFydC5iaW5kKHVwbG9hZCkpLnRvVGhyb3dFcnJvcigndHVzOiBubyBmaWxlIG9yIHN0cmVhbSB0byB1cGxvYWQgcHJvdmlkZWQnKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIHRocm93IGlmIG5vIGVuZHBvaW50IGFuZCB1cGxvYWQgVVJMIGlzIHByb3ZpZGVkJywgKCkgPT4ge1xuICAgICAgY29uc3QgZmlsZSA9IGdldEJsb2IoJ2hlbGxvIHdvcmxkJylcbiAgICAgIGNvbnN0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUpXG4gICAgICBleHBlY3QodXBsb2FkLnN0YXJ0LmJpbmQodXBsb2FkKSkudG9UaHJvd0Vycm9yKCd0dXM6IG5laXRoZXIgYW4gZW5kcG9pbnQgb3IgYW4gdXBsb2FkIFVSTCBpcyBwcm92aWRlZCcpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgdXBsb2FkIGEgZmlsZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcbiAgICAgIGNvbnN0IGZpbGUgPSBnZXRCbG9iKCdoZWxsbyB3b3JsZCcpXG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQgOiAnaHR0cHM6Ly90dXMuaW8vdXBsb2FkcycsXG4gICAgICAgIGhlYWRlcnMgIDoge1xuICAgICAgICAgIEN1c3RvbTogJ2JsYXJnaCcsXG4gICAgICAgIH0sXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgZm9vICAgICA6ICdoZWxsbycsXG4gICAgICAgICAgYmFyICAgICA6ICd3b3JsZCcsXG4gICAgICAgICAgbm9ubGF0aW46ICdzxYJvxYRjZScsXG4gICAgICAgICAgbnVtYmVyICA6IDEwMCxcbiAgICAgICAgfSxcbiAgICAgICAgd2l0aENyZWRlbnRpYWxzOiB0cnVlLFxuICAgICAgICBvblByb2dyZXNzICgpIHt9LFxuICAgICAgICBvblN1Y2Nlc3MgICAgICA6IHdhaXRhYmxlRnVuY3Rpb24oKSxcbiAgICAgIH1cbiAgICAgIHNweU9uKG9wdGlvbnMsICdvblByb2dyZXNzJylcblxuICAgICAgY29uc3QgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucylcbiAgICAgIHVwbG9hZC5zdGFydCgpXG5cbiAgICAgIGxldCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cHM6Ly90dXMuaW8vdXBsb2FkcycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzLkN1c3RvbSkudG9CZSgnYmxhcmdoJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLUxlbmd0aCddKS50b0JlKDExKVxuICAgICAgLy8gaWYgKGlzQnJvd3NlcikgZXhwZWN0KHJlcS53aXRoQ3JlZGVudGlhbHMpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtTWV0YWRhdGEnXSkudG9CZSgnZm9vIGFHVnNiRzg9LGJhciBkMjl5YkdRPSxub25sYXRpbiBjOFdDYjhXRVkyVT0sbnVtYmVyIE1UQXcnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb246ICdodHRwczovL3R1cy5pby91cGxvYWRzL2JsYXJnaCcsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2gnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnMuQ3VzdG9tKS50b0JlKCdibGFyZ2gnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtT2Zmc2V0J10pLnRvQmUoMClcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKS50b0JlKCdhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtJylcbiAgICAgIGV4cGVjdChyZXEuYm9keS5zaXplKS50b0JlKDExKVxuICAgICAgLy8gaWYgKGlzQnJvd3NlcikgZXhwZWN0KHJlcS53aXRoQ3JlZGVudGlhbHMpLnRvQmUodHJ1ZSk7XG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDExLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgYXdhaXQgb3B0aW9ucy5vblN1Y2Nlc3MudG9CZUNhbGxlZFxuXG4gICAgICBleHBlY3QodXBsb2FkLnVybCkudG9CZSgnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2gnKVxuICAgICAgZXhwZWN0KG9wdGlvbnMub25Qcm9ncmVzcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMTEsIDExKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIGNyZWF0ZSBhbiB1cGxvYWQgaWYgcmVzdW1pbmcgZmFpbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICBjb25zdCBmaWxlID0gZ2V0QmxvYignaGVsbG8gd29ybGQnKVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50IDogJ2h0dHA6Ly90dXMuaW8vdXBsb2FkcycsXG4gICAgICAgIHVwbG9hZFVybDogJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9yZXN1bWluZycsXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpXG4gICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICBsZXQgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMvcmVzdW1pbmcnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ0hFQUQnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogNDA0LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtTGVuZ3RoJ10pLnRvQmUoMTEpXG5cbiAgICAgIC8vIFRoZSB1cGxvYWQgVVJMIHNob3VsZCBiZSBjbGVhcmVkIHdoZW4gdHVzLWpzLmNsaWVudCB0cmllcyB0byBjcmVhdGUgYSBuZXcgdXBsb2FkLlxuICAgICAgZXhwZWN0KHVwbG9hZC51cmwpLnRvQmUobnVsbClcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBjcmVhdGUgYW4gdXBsb2FkIHVzaW5nIHRoZSBjcmVhdGlvbi13aXRoLWRhdGEgZXh0ZW5zaW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuICAgICAgY29uc3QgZmlsZSA9IGdldEJsb2IoJ2hlbGxvIHdvcmxkJylcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjayAgICAgICAgICAgICAgIDogdGVzdFN0YWNrLFxuICAgICAgICBlbmRwb2ludCAgICAgICAgICAgICAgICA6ICdodHRwOi8vdHVzLmlvL3VwbG9hZHMnLFxuICAgICAgICB1cGxvYWREYXRhRHVyaW5nQ3JlYXRpb246IHRydWUsXG4gICAgICAgIG9uUHJvZ3Jlc3MgKCkge30sXG4gICAgICAgIG9uQ2h1bmtDb21wbGV0ZSAoKSB7fSxcbiAgICAgICAgb25TdWNjZXNzICAgICAgICAgICAgICAgOiB3YWl0YWJsZUZ1bmN0aW9uKCdvblN1Y2Nlc3MnKSxcbiAgICAgIH1cblxuICAgICAgc3B5T24ob3B0aW9ucywgJ29uUHJvZ3Jlc3MnKVxuICAgICAgc3B5T24ob3B0aW9ucywgJ29uQ2h1bmtDb21wbGV0ZScpXG5cbiAgICAgIGNvbnN0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpXG4gICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICBjb25zdCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2FkcycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1MZW5ndGgnXSkudG9CZSgxMSlcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKS50b0JlKCdhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtJylcbiAgICAgIGV4cGVjdChyZXEuYm9keS5zaXplKS50b0JlKDExKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb24gICAgICAgOiAnaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaCcsXG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAxMSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGF3YWl0IG9wdGlvbnMub25TdWNjZXNzLnRvQmVDYWxsZWRcblxuICAgICAgZXhwZWN0KG9wdGlvbnMub25Qcm9ncmVzcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMTEsIDExKVxuICAgICAgZXhwZWN0KG9wdGlvbnMub25DaHVua0NvbXBsZXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgxMSwgMTEsIDExKVxuICAgICAgZXhwZWN0KG9wdGlvbnMub25TdWNjZXNzKS50b0hhdmVCZWVuQ2FsbGVkKClcblxuICAgICAgZXhwZWN0KHVwbG9hZC51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2gnKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIGNyZWF0ZSBhbiB1cGxvYWQgd2l0aCBwYXJ0aWFsIGRhdGEgYW5kIGNvbnRpbnVlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuICAgICAgY29uc3QgZmlsZSA9IGdldEJsb2IoJ2hlbGxvIHdvcmxkJylcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjayAgICAgICAgICAgICAgIDogdGVzdFN0YWNrLFxuICAgICAgICBlbmRwb2ludCAgICAgICAgICAgICAgICA6ICdodHRwOi8vdHVzLmlvL3VwbG9hZHMnLFxuICAgICAgICB1cGxvYWREYXRhRHVyaW5nQ3JlYXRpb246IHRydWUsXG4gICAgICAgIGNodW5rU2l6ZSAgICAgICAgICAgICAgIDogNixcbiAgICAgICAgb25Qcm9ncmVzcyAoKSB7fSxcbiAgICAgICAgb25DaHVua0NvbXBsZXRlICgpIHt9LFxuICAgICAgICBvblN1Y2Nlc3MgICAgICAgICAgICAgICA6IHdhaXRhYmxlRnVuY3Rpb24oJ29uU3VjY2VzcycpLFxuICAgICAgfVxuXG4gICAgICBzcHlPbihvcHRpb25zLCAnb25Qcm9ncmVzcycpXG4gICAgICBzcHlPbihvcHRpb25zLCAnb25DaHVua0NvbXBsZXRlJylcblxuICAgICAgY29uc3QgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucylcbiAgICAgIHVwbG9hZC5zdGFydCgpXG5cbiAgICAgIGxldCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2FkcycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1MZW5ndGgnXSkudG9CZSgxMSlcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKS50b0JlKCdhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtJylcbiAgICAgIGV4cGVjdChyZXEuYm9keS5zaXplKS50b0JlKDYpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjAxLFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBMb2NhdGlvbiAgICAgICA6ICdodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoJyxcbiAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDYsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuXG4gICAgICAvLyBPbmNlIHRoZSBzZWNvbmQgcmVxdWVzdCBoYXMgYmVlbiBzZW50LCB0aGUgcHJvZ3Jlc3MgaGFuZGxlciBtdXN0IGhhdmUgYmVlbiBpbnZva2VkLlxuICAgICAgZXhwZWN0KG9wdGlvbnMub25Qcm9ncmVzcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNiwgMTEpXG4gICAgICBleHBlY3Qob3B0aW9ucy5vbkNodW5rQ29tcGxldGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDYsIDYsIDExKVxuICAgICAgZXhwZWN0KG9wdGlvbnMub25TdWNjZXNzKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpXG4gICAgICBleHBlY3QodXBsb2FkLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaCcpXG5cbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1PZmZzZXQnXSkudG9CZSg2KVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snQ29udGVudC1UeXBlJ10pLnRvQmUoJ2FwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW0nKVxuICAgICAgZXhwZWN0KHJlcS5ib2R5LnNpemUpLnRvQmUoNSlcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uICAgICAgIDogJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2gnLFxuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMTEsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBhd2FpdCBvcHRpb25zLm9uU3VjY2Vzcy50b0JlQ2FsbGVkXG5cbiAgICAgIGV4cGVjdChvcHRpb25zLm9uUHJvZ3Jlc3MpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDExLCAxMSlcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uQ2h1bmtDb21wbGV0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoNSwgMTEsIDExKVxuICAgICAgZXhwZWN0KG9wdGlvbnMub25TdWNjZXNzKS50b0hhdmVCZWVuQ2FsbGVkKClcbiAgICB9KVxuXG4gICAgaXQoXCJzaG91bGQgYWRkIHRoZSByZXF1ZXN0J3MgYm9keSBhbmQgSUQgdG8gZXJyb3JzXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcbiAgICAgIGNvbnN0IGZpbGUgPSBnZXRCbG9iKCdoZWxsbyB3b3JsZCcpXG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2sgICA6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQgICAgOiAnaHR0cDovL3R1cy5pby91cGxvYWRzJyxcbiAgICAgICAgYWRkUmVxdWVzdElkOiB0cnVlLFxuICAgICAgICByZXRyeURlbGF5cyA6IG51bGwsXG4gICAgICAgIG9uRXJyb3IgICAgIDogd2FpdGFibGVGdW5jdGlvbignb25FcnJvcicpLFxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKVxuICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgY29uc3QgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuXG4gICAgICBjb25zdCByZXFJZCA9IHJlcS5yZXF1ZXN0SGVhZGVyc1snWC1SZXF1ZXN0LUlEJ11cbiAgICAgIGV4cGVjdCh0eXBlb2YgcmVxSWQpLnRvQmUoJ3N0cmluZycpXG4gICAgICBleHBlY3QocmVxSWQubGVuZ3RoKS50b0JlKDM2KVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICA6IDUwMCxcbiAgICAgICAgcmVzcG9uc2VUZXh0OiAnc2VydmVyX2Vycm9yJyxcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IGVyciA9IGF3YWl0IG9wdGlvbnMub25FcnJvci50b0JlQ2FsbGVkXG5cbiAgICAgIGV4cGVjdChlcnIubWVzc2FnZSkudG9CZShgdHVzOiB1bmV4cGVjdGVkIHJlc3BvbnNlIHdoaWxlIGNyZWF0aW5nIHVwbG9hZCwgb3JpZ2luYXRlZCBmcm9tIHJlcXVlc3QgKG1ldGhvZDogUE9TVCwgdXJsOiBodHRwOi8vdHVzLmlvL3VwbG9hZHMsIHJlc3BvbnNlIGNvZGU6IDUwMCwgcmVzcG9uc2UgdGV4dDogc2VydmVyX2Vycm9yLCByZXF1ZXN0IGlkOiAke3JlcUlkfSlgKVxuICAgICAgZXhwZWN0KGVyci5vcmlnaW5hbFJlcXVlc3QpLnRvQmVEZWZpbmVkKClcbiAgICAgIGV4cGVjdChlcnIub3JpZ2luYWxSZXNwb25zZSkudG9CZURlZmluZWQoKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIGludm9rZSB0aGUgcmVxdWVzdCBhbmQgcmVzcG9uc2UgY2FsbGJhY2tzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuICAgICAgY29uc3QgZmlsZSA9IGdldEJsb2IoJ2hlbGxvIHdvcmxkJylcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjazogdGVzdFN0YWNrLFxuICAgICAgICB1cGxvYWRVcmw6ICdodHRwOi8vdHVzLmlvL3VwbG9hZHMvZm9vJyxcbiAgICAgICAgb25CZWZvcmVSZXF1ZXN0IChyZXEpIHtcbiAgICAgICAgICBleHBlY3QocmVxLmdldFVSTCgpKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMvZm9vJylcbiAgICAgICAgICBleHBlY3QocmVxLmdldE1ldGhvZCgpKS50b0JlKCdIRUFEJylcbiAgICAgICAgfSxcbiAgICAgICAgb25BZnRlclJlc3BvbnNlIChyZXEsIHJlcykge1xuICAgICAgICAgIGV4cGVjdChyZXEuZ2V0VVJMKCkpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9mb28nKVxuICAgICAgICAgIGV4cGVjdChyZXEuZ2V0TWV0aG9kKCkpLnRvQmUoJ0hFQUQnKVxuICAgICAgICAgIGV4cGVjdChyZXMuZ2V0U3RhdHVzKCkpLnRvQmUoMjA0KVxuICAgICAgICAgIGV4cGVjdChyZXMuZ2V0SGVhZGVyKCdVcGxvYWQtT2Zmc2V0JykpLnRvQmUoMTEpXG4gICAgICAgIH0sXG4gICAgICAgIG9uU3VjY2Vzczogd2FpdGFibGVGdW5jdGlvbignb25TdWNjZXNzJyksXG4gICAgICB9XG4gICAgICBzcHlPbihvcHRpb25zLCAnb25CZWZvcmVSZXF1ZXN0JylcbiAgICAgIHNweU9uKG9wdGlvbnMsICdvbkFmdGVyUmVzcG9uc2UnKVxuXG4gICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKVxuICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgY29uc3QgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMvZm9vJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdIRUFEJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMTEsXG4gICAgICAgICAgJ1VwbG9hZC1MZW5ndGgnOiAxMSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGF3YWl0IG9wdGlvbnMub25TdWNjZXNzLnRvQmVDYWxsZWRcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uQmVmb3JlUmVxdWVzdCkudG9IYXZlQmVlbkNhbGxlZCgpXG4gICAgICBleHBlY3Qob3B0aW9ucy5vbkFmdGVyUmVzcG9uc2UpLnRvSGF2ZUJlZW5DYWxsZWQoKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIHRocm93IGFuIGVycm9yIGlmIHJlc3VtaW5nIGZhaWxzIGFuZCBubyBlbmRwb2ludCBpcyBwcm92aWRlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcbiAgICAgIGNvbnN0IGZpbGUgPSBnZXRCbG9iKCdoZWxsbyB3b3JsZCcpXG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgdXBsb2FkVXJsOiAnaHR0cDovL3R1cy5pby91cGxvYWRzL3Jlc3VtaW5nJyxcbiAgICAgICAgb25FcnJvciAgOiB3YWl0YWJsZUZ1bmN0aW9uKCdvbkVycm9yJyksXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpXG4gICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICBjb25zdCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9yZXN1bWluZycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnSEVBRCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiA0MDQsXG4gICAgICB9KVxuXG4gICAgICBjb25zdCBlcnIgPSBhd2FpdCBvcHRpb25zLm9uRXJyb3IudG9CZUNhbGxlZFxuICAgICAgZXhwZWN0KGVyci5tZXNzYWdlKS50b0JlKCd0dXM6IHVuYWJsZSB0byByZXN1bWUgdXBsb2FkIChuZXcgdXBsb2FkIGNhbm5vdCBiZSBjcmVhdGVkIHdpdGhvdXQgYW4gZW5kcG9pbnQpLCBvcmlnaW5hdGVkIGZyb20gcmVxdWVzdCAobWV0aG9kOiBIRUFELCB1cmw6IGh0dHA6Ly90dXMuaW8vdXBsb2Fkcy9yZXN1bWluZywgcmVzcG9uc2UgY29kZTogNDA0LCByZXNwb25zZSB0ZXh0OiAsIHJlcXVlc3QgaWQ6IG4vYSknKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIHJlc29sdmUgcmVsYXRpdmUgVVJMcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcbiAgICAgIGNvbnN0IGZpbGUgPSBnZXRCbG9iKCdoZWxsbyB3b3JsZCcpXG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQgOiAnaHR0cDovL3R1cy5pbzoxMDgwL2ZpbGVzLycsXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpXG4gICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICBsZXQgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvOjEwODAvZmlsZXMvJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQT1NUJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uOiAnLy9sb2NhbGhvc3QvdXBsb2Fkcy9mb28nLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vbG9jYWxob3N0L3VwbG9hZHMvZm9vJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDExLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgZXhwZWN0KHVwbG9hZC51cmwpLnRvQmUoJ2h0dHA6Ly9sb2NhbGhvc3QvdXBsb2Fkcy9mb28nKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIHVwbG9hZCBhIGZpbGUgaW4gY2h1bmtzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuICAgICAgY29uc3QgZmlsZSA9IGdldEJsb2IoJ2hlbGxvIHdvcmxkJylcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjazogdGVzdFN0YWNrLFxuICAgICAgICBlbmRwb2ludCA6ICdodHRwOi8vdHVzLmlvL3VwbG9hZHMnLFxuICAgICAgICBjaHVua1NpemU6IDcsXG4gICAgICAgIG9uU3VjY2Vzczogd2FpdGFibGVGdW5jdGlvbignb25TdWNjZXNzJyksXG4gICAgICAgIG9uUHJvZ3Jlc3MgKCkge30sXG4gICAgICAgIG9uQ2h1bmtDb21wbGV0ZSAoKSB7fSxcbiAgICAgIH1cbiAgICAgIHNweU9uKG9wdGlvbnMsICdvblByb2dyZXNzJylcbiAgICAgIHNweU9uKG9wdGlvbnMsICdvbkNodW5rQ29tcGxldGUnKVxuXG4gICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKVxuICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgbGV0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQT1NUJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLUxlbmd0aCddKS50b0JlKDExKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb246ICcvdXBsb2Fkcy9ibGFyZ2gnLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1PZmZzZXQnXSkudG9CZSgwKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snQ29udGVudC1UeXBlJ10pLnRvQmUoJ2FwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW0nKVxuICAgICAgZXhwZWN0KHJlcS5ib2R5LnNpemUpLnRvQmUoNylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogNyxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaCcpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtT2Zmc2V0J10pLnRvQmUoNylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKS50b0JlKCdhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtJylcbiAgICAgIGV4cGVjdChyZXEuYm9keS5zaXplKS50b0JlKDQpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDExLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgYXdhaXQgb3B0aW9ucy5vblN1Y2Nlc3MudG9CZUNhbGxlZFxuXG4gICAgICBleHBlY3QodXBsb2FkLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaCcpXG4gICAgICBleHBlY3Qob3B0aW9ucy5vblByb2dyZXNzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgxMSwgMTEpXG4gICAgICBleHBlY3Qob3B0aW9ucy5vbkNodW5rQ29tcGxldGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDcsIDcsIDExKVxuICAgICAgZXhwZWN0KG9wdGlvbnMub25DaHVua0NvbXBsZXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg0LCAxMSwgMTEpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgYWRkIHRoZSBvcmlnaW5hbCByZXF1ZXN0IHRvIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcbiAgICAgIGNvbnN0IGZpbGUgPSBnZXRCbG9iKCdoZWxsbyB3b3JsZCcpXG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2sgIDogdGVzdFN0YWNrLFxuICAgICAgICBlbmRwb2ludCAgIDogJ2h0dHA6Ly90dXMuaW8vdXBsb2FkcycsXG4gICAgICAgIHJldHJ5RGVsYXlzOiBudWxsLFxuICAgICAgICBvbkVycm9yICAgIDogd2FpdGFibGVGdW5jdGlvbignb25FcnJvcicpLFxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKVxuICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgY29uc3QgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDUwMCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgQ3VzdG9tOiAnYmxhcmdoJyxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IGVyciA9IGF3YWl0IG9wdGlvbnMub25FcnJvci50b0JlQ2FsbGVkXG5cbiAgICAgIGV4cGVjdCh1cGxvYWQudXJsKS50b0JlKG51bGwpXG4gICAgICBleHBlY3QoZXJyLm1lc3NhZ2UpLnRvQmUoJ3R1czogdW5leHBlY3RlZCByZXNwb25zZSB3aGlsZSBjcmVhdGluZyB1cGxvYWQsIG9yaWdpbmF0ZWQgZnJvbSByZXF1ZXN0IChtZXRob2Q6IFBPU1QsIHVybDogaHR0cDovL3R1cy5pby91cGxvYWRzLCByZXNwb25zZSBjb2RlOiA1MDAsIHJlc3BvbnNlIHRleHQ6ICwgcmVxdWVzdCBpZDogbi9hKScpXG4gICAgICBleHBlY3QoZXJyLm9yaWdpbmFsUmVxdWVzdCkudG9CZURlZmluZWQoKVxuICAgICAgZXhwZWN0KGVyci5vcmlnaW5hbFJlc3BvbnNlKS50b0JlRGVmaW5lZCgpXG4gICAgICBleHBlY3QoZXJyLm9yaWdpbmFsUmVzcG9uc2UuZ2V0SGVhZGVyKCdDdXN0b20nKSkudG9CZSgnYmxhcmdoJylcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBvbmx5IGNyZWF0ZSBhbiB1cGxvYWQgZm9yIGVtcHR5IGZpbGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuICAgICAgY29uc3QgZmlsZSA9IGdldEJsb2IoJycpXG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQgOiAnaHR0cDovL3R1cy5pby91cGxvYWRzJyxcbiAgICAgICAgb25TdWNjZXNzOiB3YWl0YWJsZUZ1bmN0aW9uKCdvblN1Y2Nlc3MnKSxcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucylcbiAgICAgIHVwbG9hZC5zdGFydCgpXG5cbiAgICAgIGNvbnN0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQT1NUJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLUxlbmd0aCddKS50b0JlKDApXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjAxLFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBMb2NhdGlvbjogJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9lbXB0eScsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBhd2FpdCBvcHRpb25zLm9uU3VjY2Vzcy50b0JlQ2FsbGVkXG4gICAgICBleHBlY3Qob3B0aW9ucy5vblN1Y2Nlc3MpLnRvSGF2ZUJlZW5DYWxsZWQoKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIG5vdCByZXN1bWUgYSBmaW5pc2hlZCB1cGxvYWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICBjb25zdCBmaWxlID0gZ2V0QmxvYignaGVsbG8gd29ybGQnKVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50IDogJ2h0dHA6Ly90dXMuaW8vdXBsb2FkcycsXG4gICAgICAgIG9uUHJvZ3Jlc3MgKCkge30sXG4gICAgICAgIG9uU3VjY2Vzczogd2FpdGFibGVGdW5jdGlvbignb25TdWNjZXNzJyksXG4gICAgICAgIHVwbG9hZFVybDogJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9yZXN1bWluZycsXG4gICAgICB9XG4gICAgICBzcHlPbihvcHRpb25zLCAnb25Qcm9ncmVzcycpXG5cbiAgICAgIGNvbnN0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpXG4gICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICBjb25zdCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9yZXN1bWluZycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnSEVBRCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICdVcGxvYWQtTGVuZ3RoJzogJzExJyxcbiAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6ICcxMScsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBhd2FpdCBvcHRpb25zLm9uU3VjY2Vzcy50b0JlQ2FsbGVkXG5cbiAgICAgIGV4cGVjdChvcHRpb25zLm9uUHJvZ3Jlc3MpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDExLCAxMSlcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uU3VjY2VzcykudG9IYXZlQmVlbkNhbGxlZCgpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgcmVzdW1lIGFuIHVwbG9hZCBmcm9tIGEgc3BlY2lmaWVkIHVybCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcbiAgICAgIGNvbnN0IGZpbGUgPSBnZXRCbG9iKCdoZWxsbyB3b3JsZCcpXG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQgOiAnaHR0cDovL3R1cy5pby91cGxvYWRzJyxcbiAgICAgICAgdXBsb2FkVXJsOiAnaHR0cDovL3R1cy5pby9maWxlcy91cGxvYWQnLFxuICAgICAgICBvblByb2dyZXNzICgpIHt9LFxuICAgICAgICBvblN1Y2Nlc3M6IHdhaXRhYmxlRnVuY3Rpb24oJ29uU3VjY2VzcycpLFxuICAgICAgICBmaW5nZXJwcmludCAoKSB7fSxcbiAgICAgIH1cbiAgICAgIHNweU9uKG9wdGlvbnMsICdmaW5nZXJwcmludCcpLmFuZC5yZXNvbHZlVG8oJ2ZpbmdlcnByaW50ZWQnKVxuICAgICAgc3B5T24ob3B0aW9ucywgJ29uUHJvZ3Jlc3MnKVxuXG4gICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKVxuICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgZXhwZWN0KG9wdGlvbnMuZmluZ2VycHJpbnQpLnRvSGF2ZUJlZW5DYWxsZWQoKVxuXG4gICAgICBsZXQgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL3VwbG9hZCcpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnSEVBRCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICdVcGxvYWQtTGVuZ3RoJzogMTEsXG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAzLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL3VwbG9hZCcpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtT2Zmc2V0J10pLnRvQmUoMylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKS50b0JlKCdhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtJylcbiAgICAgIGV4cGVjdChyZXEuYm9keS5zaXplKS50b0JlKDExIC0gMylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMTEsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBhd2FpdCBvcHRpb25zLm9uU3VjY2Vzcy50b0JlQ2FsbGVkXG4gICAgICBleHBlY3Qob3B0aW9ucy5vblByb2dyZXNzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgxMSwgMTEpXG4gICAgICBleHBlY3QodXBsb2FkLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy91cGxvYWQnKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIHJlc3VtZSBhIHByZXZpb3VzbHkgc3RhcnRlZCB1cGxvYWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICBjb25zdCBmaWxlID0gZ2V0QmxvYignaGVsbG8gd29ybGQnKVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50IDogJ2h0dHA6Ly90dXMuaW8vdXBsb2FkcycsXG4gICAgICAgIG9uU3VjY2Vzczogd2FpdGFibGVGdW5jdGlvbignb25TdWNjZXNzJyksXG4gICAgICAgIG9uRXJyb3IgKCkge30sXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpXG4gICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICBsZXQgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb246ICdodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoJyxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaCcpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuXG4gICAgICB1cGxvYWQuYWJvcnQoKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiA1LFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdIRUFEJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogNSxcbiAgICAgICAgICAnVXBsb2FkLUxlbmd0aCc6IDExLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDExLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgYXdhaXQgb3B0aW9ucy5vblN1Y2Nlc3MudG9CZUNhbGxlZFxuICAgICAgZXhwZWN0KG9wdGlvbnMub25TdWNjZXNzKS50b0hhdmVCZWVuQ2FsbGVkKClcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBvdmVycmlkZSB0aGUgUEFUQ0ggbWV0aG9kJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuICAgICAgY29uc3QgZmlsZSA9IGdldEJsb2IoJ2hlbGxvIHdvcmxkJylcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjayAgICAgICAgICA6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQgICAgICAgICAgIDogJ2h0dHA6Ly90dXMuaW8vdXBsb2FkcycsXG4gICAgICAgIHVwbG9hZFVybCAgICAgICAgICA6ICdodHRwOi8vdHVzLmlvL2ZpbGVzL3VwbG9hZCcsXG4gICAgICAgIG92ZXJyaWRlUGF0Y2hNZXRob2Q6IHRydWUsXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpXG4gICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICBsZXQgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL3VwbG9hZCcpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnSEVBRCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICdVcGxvYWQtTGVuZ3RoJzogMTEsXG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAzLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL3VwbG9hZCcpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1PZmZzZXQnXSkudG9CZSgzKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snWC1IVFRQLU1ldGhvZC1PdmVycmlkZSddKS50b0JlKCdQQVRDSCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDExLFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBlbWl0IGFuIGVycm9yIGlmIGFuIHVwbG9hZCBpcyBsb2NrZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICBjb25zdCBmaWxlID0gZ2V0QmxvYignaGVsbG8gd29ybGQnKVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrICA6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQgICA6ICdodHRwOi8vdHVzLmlvL3VwbG9hZHMnLFxuICAgICAgICB1cGxvYWRVcmwgIDogJ2h0dHA6Ly90dXMuaW8vZmlsZXMvdXBsb2FkJyxcbiAgICAgICAgb25FcnJvciAgICA6IHdhaXRhYmxlRnVuY3Rpb24oJ29uRXJyb3InKSxcbiAgICAgICAgcmV0cnlEZWxheXM6IG51bGwsXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpXG4gICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICBjb25zdCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvdXBsb2FkJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdIRUFEJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiA0MjMsIC8vIExvY2tlZFxuICAgICAgfSlcblxuICAgICAgYXdhaXQgb3B0aW9ucy5vbkVycm9yLnRvQmVDYWxsZWRcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uRXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKG5ldyBFcnJvcigndHVzOiB1cGxvYWQgaXMgY3VycmVudGx5IGxvY2tlZDsgcmV0cnkgbGF0ZXIsIG9yaWdpbmF0ZWQgZnJvbSByZXF1ZXN0IChtZXRob2Q6IEhFQUQsIHVybDogaHR0cDovL3R1cy5pby9maWxlcy91cGxvYWQsIHJlc3BvbnNlIGNvZGU6IDQyMywgcmVzcG9uc2UgdGV4dDogLCByZXF1ZXN0IGlkOiBuL2EpJykpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgZW1pdCBhbiBlcnJvciBpZiBubyBMb2NhdGlvbiBoZWFkZXIgaXMgcHJlc2VudGVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuICAgICAgY29uc3QgZmlsZSA9IGdldEJsb2IoJ2hlbGxvIHdvcmxkJylcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjayAgOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50ICAgOiAnaHR0cDovL3R1cy5pby91cGxvYWRzJyxcbiAgICAgICAgb25FcnJvciAgICA6IHdhaXRhYmxlRnVuY3Rpb24oJ29uRXJyb3InKSxcbiAgICAgICAgcmV0cnlEZWxheXM6IG51bGwsXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpXG4gICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICBjb25zdCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2FkcycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG5cbiAgICAgIC8vIFRoZSBMb2NhdGlvbiBoZWFkZXIgaXMgb21pdHRlZCBvbiBwdXJwb3NlIGhlcmVcbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogMjAxLFxuICAgICAgfSlcblxuICAgICAgYXdhaXQgb3B0aW9ucy5vbkVycm9yLnRvQmVDYWxsZWRcblxuICAgICAgZXhwZWN0KG9wdGlvbnMub25FcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgobmV3IEVycm9yKCd0dXM6IGludmFsaWQgb3IgbWlzc2luZyBMb2NhdGlvbiBoZWFkZXIsIG9yaWdpbmF0ZWQgZnJvbSByZXF1ZXN0IChtZXRob2Q6IFBPU1QsIHVybDogaHR0cDovL3R1cy5pby91cGxvYWRzLCByZXNwb25zZSBjb2RlOiAyMDEsIHJlc3BvbnNlIHRleHQ6ICwgcmVxdWVzdCBpZDogbi9hKScpKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIHRocm93IGlmIHJldHJ5RGVsYXlzIGlzIG5vdCBhbiBhcnJheScsICgpID0+IHtcbiAgICAgIGNvbnN0IGZpbGUgPSBnZXRCbG9iKCdoZWxsbyB3b3JsZCcpXG4gICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCB7XG4gICAgICAgIGVuZHBvaW50ICAgOiAnaHR0cDovL2VuZHBvaW50LycsXG4gICAgICAgIHJldHJ5RGVsYXlzOiA0NCxcbiAgICAgIH0pXG4gICAgICBleHBlY3QodXBsb2FkLnN0YXJ0LmJpbmQodXBsb2FkKSkudG9UaHJvd0Vycm9yKCd0dXM6IHRoZSBgcmV0cnlEZWxheXNgIG9wdGlvbiBtdXN0IGVpdGhlciBiZSBhbiBhcnJheSBvciBudWxsJylcbiAgICB9KVxuXG4gICAgLy8gVGhpcyB0ZXN0cyBlbnN1cmVzIHRoYXQgdHVzLWpzLWNsaWVudCBjb3JyZWN0bHkgcmV0cmllcyBpZiB0aGVcbiAgICAvLyByZXNwb25zZSBoYXMgdGhlIGNvZGUgNTAwIEludGVybmFsIEVycm9yLCA0MjMgTG9ja2VkIG9yIDQwOSBDb25mbGljdC5cbiAgICBpdCgnc2hvdWxkIHJldHJ5IHRoZSB1cGxvYWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICBjb25zdCBmaWxlID0gZ2V0QmxvYignaGVsbG8gd29ybGQnKVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrICA6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQgICA6ICdodHRwOi8vdHVzLmlvL2ZpbGVzLycsXG4gICAgICAgIHJldHJ5RGVsYXlzOiBbMTAsIDEwLCAxMF0sXG4gICAgICAgIG9uU3VjY2VzcyAgOiB3YWl0YWJsZUZ1bmN0aW9uKCdvblN1Y2Nlc3MnKSxcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucylcbiAgICAgIHVwbG9hZC5zdGFydCgpXG5cbiAgICAgIGxldCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQT1NUJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQT1NUJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uOiAnL2ZpbGVzL2ZvbycsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvZm9vJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogNDIzLFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL2ZvbycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnSEVBRCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjAxLFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDAsXG4gICAgICAgICAgJ1VwbG9hZC1MZW5ndGgnOiAxMSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy9mb28nKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiA0MDksXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvZm9vJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdIRUFEJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMCxcbiAgICAgICAgICAnVXBsb2FkLUxlbmd0aCc6IDExLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL2ZvbycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAxMSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGF3YWl0IG9wdGlvbnMub25TdWNjZXNzLnRvQmVDYWxsZWRcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uU3VjY2VzcykudG9IYXZlQmVlbkNhbGxlZCgpXG4gICAgfSlcblxuICAgIC8vIFRoaXMgdGVzdHMgZW5zdXJlcyB0aGF0IHR1cy1qcy1jbGllbnQgY29ycmVjdGx5IHJldHJpZXMgaWYgdGhlXG4gICAgLy8gcmV0dXJuIHZhbHVlIG9mIG9uU2hvdWxkUmV0cnkgaXMgdHJ1ZS5cbiAgICBpdCgnc2hvdWxkIHJldHJ5IHRoZSB1cGxvYWQgd2hlbiBvblNob3VsZFJldHJ5IHNwZWNpZmllZCBhbmQgcmV0dXJucyB0cnVlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuICAgICAgY29uc3QgZmlsZSA9IGdldEJsb2IoJ2hlbGxvIHdvcmxkJylcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjayAgICA6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQgICAgIDogJ2h0dHA6Ly90dXMuaW8vZmlsZXMvJyxcbiAgICAgICAgcmV0cnlEZWxheXMgIDogWzEwLCAxMCwgMTBdLFxuICAgICAgICBvblN1Y2Nlc3MgICAgOiB3YWl0YWJsZUZ1bmN0aW9uKCdvblN1Y2Nlc3MnKSxcbiAgICAgICAgb25TaG91bGRSZXRyeTogKCkgPT4gdHJ1ZSxcbiAgICAgIH1cblxuICAgICAgc3B5T24ob3B0aW9ucywgJ29uU2hvdWxkUmV0cnknKS5hbmQuY2FsbFRocm91Z2goKVxuICAgICAgc3B5T24odHVzLlVwbG9hZC5wcm90b3R5cGUsICdfZW1pdEVycm9yJykuYW5kLmNhbGxUaHJvdWdoKClcblxuICAgICAgY29uc3QgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucylcbiAgICAgIHVwbG9hZC5zdGFydCgpXG5cbiAgICAgIGxldCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQT1NUJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQT1NUJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uOiAnL2ZpbGVzL2ZvbycsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvZm9vJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogNDIzLFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL2ZvbycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnSEVBRCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjAxLFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDAsXG4gICAgICAgICAgJ1VwbG9hZC1MZW5ndGgnOiAxMSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy9mb28nKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiA0MDksXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvZm9vJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdIRUFEJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMCxcbiAgICAgICAgICAnVXBsb2FkLUxlbmd0aCc6IDExLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL2ZvbycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAxMSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGF3YWl0IG9wdGlvbnMub25TdWNjZXNzLnRvQmVDYWxsZWRcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uU3VjY2VzcykudG9IYXZlQmVlbkNhbGxlZCgpXG5cbiAgICAgIGNvbnN0IFtlcnJvcjFdICA9IHVwbG9hZC5fZW1pdEVycm9yLmNhbGxzLmFyZ3NGb3IoMClcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uU2hvdWxkUmV0cnkpLnRvSGF2ZUJlZW5DYWxsZWQoKVxuICAgICAgZXhwZWN0KG9wdGlvbnMub25TaG91bGRSZXRyeS5jYWxscy5hcmdzRm9yKDApKS50b0VxdWFsKFtlcnJvcjEsIDAsIHVwbG9hZC5vcHRpb25zXSlcbiAgICAgIGNvbnN0IFtlcnJvcjJdID0gdXBsb2FkLl9lbWl0RXJyb3IuY2FsbHMuYXJnc0ZvcigxKVxuICAgICAgZXhwZWN0KG9wdGlvbnMub25TaG91bGRSZXRyeS5jYWxscy5hcmdzRm9yKDEpKS50b0VxdWFsKFtlcnJvcjIsIDEsIHVwbG9hZC5vcHRpb25zXSlcbiAgICB9KVxuXG4gICAgLy8gVGhpcyB0ZXN0cyBlbnN1cmVzIHRoYXQgdHVzLWpzLWNsaWVudCBjb3JyZWN0bHkgYWJvcnRzIGlmIHRoZVxuICAgIC8vIHJldHVybiB2YWx1ZSBvZiBvblNob3VsZFJldHJ5IGlzIGZhbHNlLlxuICAgIGl0KCdzaG91bGQgbm90IHJldHJ5IHRoZSB1cGxvYWQgd2hlbiBjYWxsYmFjayBzcGVjaWZpZWQgYW5kIHJldHVybnMgZmFsc2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICBjb25zdCBmaWxlID0gZ2V0QmxvYignaGVsbG8gd29ybGQnKVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrICAgIDogdGVzdFN0YWNrLFxuICAgICAgICBlbmRwb2ludCAgICAgOiAnaHR0cDovL3R1cy5pby9maWxlcy8nLFxuICAgICAgICByZXRyeURlbGF5cyAgOiBbMTAsIDEwLCAxMF0sXG4gICAgICAgIG9uU3VjY2VzcyAgICA6IHdhaXRhYmxlRnVuY3Rpb24oJ29uU3VjY2VzcycpLFxuICAgICAgICBvbkVycm9yICAgICAgOiB3YWl0YWJsZUZ1bmN0aW9uKCdvbkVycm9yJyksXG4gICAgICAgIG9uU2hvdWxkUmV0cnk6ICgpID0+IGZhbHNlLFxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKVxuICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgY29uc3QgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzLycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG5cbiAgICAgIC8vIFRoZSBlcnJvciBjYWxsYmFjayBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIHRoZSBmaXJzdCBlcnJvciByZXNwb25zZS5cbiAgICAgIGV4cGVjdChvcHRpb25zLm9uRXJyb3IpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKClcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICB9KVxuXG4gICAgICBhd2FpdCBvcHRpb25zLm9uRXJyb3IudG9CZUNhbGxlZFxuXG4gICAgICBleHBlY3Qob3B0aW9ucy5vblN1Y2Nlc3MpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKClcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uRXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIG5vdCByZXRyeSBpZiB0aGUgZXJyb3IgaGFzIG5vdCBiZWVuIGNhdXNlZCBieSBhIHJlcXVlc3QnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBmaWxlID0gZ2V0QmxvYignaGVsbG8gd29ybGQnKVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrICA6IG5ldyBUZXN0SHR0cFN0YWNrKCksXG4gICAgICAgIGVuZHBvaW50ICAgOiAnaHR0cDovL3R1cy5pby9maWxlcy8nLFxuICAgICAgICByZXRyeURlbGF5czogWzEwLCAxMCwgMTBdLFxuICAgICAgICBvblN1Y2Nlc3MgKCkge30sXG4gICAgICAgIG9uRXJyb3IgKCkge30sXG4gICAgICB9XG5cbiAgICAgIHNweU9uKG9wdGlvbnMsICdvblN1Y2Nlc3MnKVxuICAgICAgc3B5T24ob3B0aW9ucywgJ29uRXJyb3InKVxuXG4gICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKVxuICAgICAgc3B5T24odXBsb2FkLCAnX2NyZWF0ZVVwbG9hZCcpXG4gICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICBhd2FpdCB3YWl0KDIwMClcblxuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ2N1c3RvbSBlcnJvcicpXG4gICAgICB1cGxvYWQuX2VtaXRFcnJvcihlcnJvcilcblxuICAgICAgZXhwZWN0KHVwbG9hZC5fY3JlYXRlVXBsb2FkKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSlcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uRXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGVycm9yKVxuICAgICAgZXhwZWN0KG9wdGlvbnMub25TdWNjZXNzKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgc3RvcCByZXRyeWluZyBhZnRlciBhbGwgZGVsYXlzIGhhdmUgYmVlbiB1c2VkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuICAgICAgY29uc3QgZmlsZSA9IGdldEJsb2IoJ2hlbGxvIHdvcmxkJylcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjayAgOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50ICAgOiAnaHR0cDovL3R1cy5pby9maWxlcy8nLFxuICAgICAgICByZXRyeURlbGF5czogWzEwXSxcbiAgICAgICAgb25TdWNjZXNzICgpIHt9LFxuICAgICAgICBvbkVycm9yICAgIDogd2FpdGFibGVGdW5jdGlvbignb25FcnJvcicpLFxuICAgICAgfVxuICAgICAgc3B5T24ob3B0aW9ucywgJ29uU3VjY2VzcycpXG5cbiAgICAgIGNvbnN0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpXG4gICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICBsZXQgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzLycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzLycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG5cbiAgICAgIC8vIFRoZSBlcnJvciBjYWxsYmFjayBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIHRoZSBmaXJzdCBlcnJvciByZXNwb25zZS5cbiAgICAgIGV4cGVjdChvcHRpb25zLm9uRXJyb3IpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKClcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICB9KVxuXG4gICAgICBhd2FpdCBvcHRpb25zLm9uRXJyb3IudG9CZUNhbGxlZFxuXG4gICAgICBleHBlY3Qob3B0aW9ucy5vblN1Y2Nlc3MpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKClcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uRXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIHN0b3AgcmV0cnlpbmcgd2hlbiB0aGUgYWJvcnQgZnVuY3Rpb24gaXMgY2FsbGVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuICAgICAgY29uc3QgZmlsZSA9IGdldEJsb2IoJ2hlbGxvIHdvcmxkJylcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjayAgOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50ICAgOiAnaHR0cDovL3R1cy5pby9maWxlcy8nLFxuICAgICAgICByZXRyeURlbGF5czogWzEwXSxcbiAgICAgICAgb25FcnJvciAoKSB7fSxcbiAgICAgIH1cblxuICAgICAgc3B5T24ob3B0aW9ucywgJ29uRXJyb3InKVxuXG4gICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKVxuICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgY29uc3QgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzLycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG5cbiAgICAgIHNweU9uKHVwbG9hZCwgJ3N0YXJ0JykuYW5kLmNhbGxUaHJvdWdoKClcblxuICAgICAgdXBsb2FkLmFib3J0KClcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICB9KVxuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLnJhY2UoW1xuICAgICAgICB0ZXN0U3RhY2submV4dFJlcXVlc3QoKSxcbiAgICAgICAgd2FpdCgxMDApLFxuICAgICAgXSlcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSgndGltZWQgb3V0JylcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBzdG9wIHVwbG9hZCB3aGVuIHRoZSBhYm9ydCBmdW5jdGlvbiBpcyBjYWxsZWQgZHVyaW5nIGEgY2FsbGJhY2snLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICBjb25zdCBmaWxlID0gZ2V0QmxvYignaGVsbG8gd29ybGQnKVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50IDogJ2h0dHA6Ly90dXMuaW8vZmlsZXMvJyxcbiAgICAgICAgY2h1bmtTaXplOiA1LFxuICAgICAgICBvbkNodW5rQ29tcGxldGUgKCkge1xuICAgICAgICAgIHVwbG9hZC5hYm9ydCgpXG4gICAgICAgIH0sXG4gICAgICB9XG5cbiAgICAgIHNweU9uKG9wdGlvbnMsICdvbkNodW5rQ29tcGxldGUnKS5hbmQuY2FsbFRocm91Z2goKVxuXG4gICAgICBsZXQgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucylcbiAgICAgIHVwbG9hZC5zdGFydCgpXG5cbiAgICAgIGxldCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQT1NUJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uOiAnL2ZpbGVzL2ZvbycsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvZm9vJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDUsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLnJhY2UoW1xuICAgICAgICB0ZXN0U3RhY2submV4dFJlcXVlc3QoKSxcbiAgICAgICAgd2FpdCgyMDApLFxuICAgICAgXSlcblxuICAgICAgZXhwZWN0KG9wdGlvbnMub25DaHVua0NvbXBsZXRlKS50b0hhdmVCZWVuQ2FsbGVkKClcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoJ3RpbWVkIG91dCcpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgc3RvcCB1cGxvYWQgd2hlbiB0aGUgYWJvcnQgZnVuY3Rpb24gaXMgY2FsbGVkIGR1cmluZyB0aGUgUE9TVCByZXF1ZXN0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuICAgICAgY29uc3QgZmlsZSA9IGdldEJsb2IoJ2hlbGxvIHdvcmxkJylcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjazogdGVzdFN0YWNrLFxuICAgICAgICBlbmRwb2ludCA6ICdodHRwOi8vdHVzLmlvL2ZpbGVzLycsXG4gICAgICAgIG9uRXJyb3IgKCkge30sXG4gICAgICB9XG5cbiAgICAgIHNweU9uKG9wdGlvbnMsICdvbkVycm9yJykuYW5kLmNhbGxUaHJvdWdoKClcblxuICAgICAgY29uc3QgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucylcbiAgICAgIHVwbG9hZC5zdGFydCgpXG5cbiAgICAgIGNvbnN0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy8nKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuXG4gICAgICB1cGxvYWQuYWJvcnQoKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb246ICcvZmlsZXMvZm9vJyxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgIHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpLFxuICAgICAgICB3YWl0KDIwMCksXG4gICAgICBdKVxuXG4gICAgICBleHBlY3Qob3B0aW9ucy5vbkVycm9yKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKCd0aW1lZCBvdXQnKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIHJlc2V0IHRoZSBhdHRlbXB0IGNvdW50ZXIgaWYgYW4gdXBsb2FkIHByb2NlZWRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuICAgICAgY29uc3QgZmlsZSA9IGdldEJsb2IoJ2hlbGxvIHdvcmxkJylcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjayAgOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50ICAgOiAnaHR0cDovL3R1cy5pby9maWxlcy8nLFxuICAgICAgICByZXRyeURlbGF5czogWzEwXSxcbiAgICAgICAgb25FcnJvciAoKSB7fSxcbiAgICAgICAgb25TdWNjZXNzICA6IHdhaXRhYmxlRnVuY3Rpb24oJ29uU3VjY2VzcycpLFxuICAgICAgfVxuICAgICAgc3B5T24ob3B0aW9ucywgJ29uRXJyb3InKVxuXG4gICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKVxuICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgbGV0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy8nKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb246ICcvZmlsZXMvZm9vJyxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy9mb28nKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvZm9vJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdIRUFEJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMCxcbiAgICAgICAgICAnVXBsb2FkLUxlbmd0aCc6IDExLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL2ZvbycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiA1LFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL2ZvbycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDUwMCxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy9mb28nKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ0hFQUQnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiA1LFxuICAgICAgICAgICdVcGxvYWQtTGVuZ3RoJzogMTEsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvZm9vJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDExLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgYXdhaXQgb3B0aW9ucy5vblN1Y2Nlc3MudG9CZUNhbGxlZFxuICAgICAgZXhwZWN0KG9wdGlvbnMub25FcnJvcikubm90LnRvSGF2ZUJlZW5DYWxsZWQoKVxuICAgICAgZXhwZWN0KG9wdGlvbnMub25TdWNjZXNzKS50b0hhdmVCZWVuQ2FsbGVkKClcbiAgICB9KVxuICB9KVxufSlcbiIsImNvbnN0IGF4aW9zID0gcmVxdWlyZSgnYXhpb3MnKVxuY29uc3QgeyBnZXRCbG9iIH0gPSByZXF1aXJlKCcuL2hlbHBlcnMvdXRpbHMnKVxuY29uc3QgdHVzID0gcmVxdWlyZSgnLi4vLi4nKVxuXG4vLyBUZXN0IHRpbWVvdXQgZm9yIGVuZC10by1lbmQgdGVzdHMgd2hlbiB1cGxvYWRpbmcgdG8gcmVhbCBzZXJ2ZXIuXG5jb25zdCBFTkRfVE9fRU5EX1RJTUVPVVQgPSAyMCAqIDEwMDBcblxuZGVzY3JpYmUoJ3R1cycsICgpID0+IHtcbiAgZGVzY3JpYmUoJ2VuZC10by1lbmQnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCB1cGxvYWQgdG8gYSByZWFsIHR1cyBzZXJ2ZXInLCBhc3luYyAoKSA9PiB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBmaWxlID0gZ2V0QmxvYignaGVsbG8gd29ybGQnKVxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgIGVuZHBvaW50OiAnaHR0cHM6Ly90dXNkLnR1c2RlbW8ubmV0L2ZpbGVzLycsXG4gICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgIG5vbmxhdGluOiAnc8WCb8WEY2UnLFxuICAgICAgICAgICAgbnVtYmVyICA6IDEwMCxcbiAgICAgICAgICAgIGZpbGVuYW1lOiAnaGVsbG8udHh0JyxcbiAgICAgICAgICAgIGZpbGV0eXBlOiAndGV4dC9wbGFpbicsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvblN1Y2Nlc3MgKCkge1xuICAgICAgICAgICAgZXhwZWN0KHVwbG9hZC51cmwpLnRvTWF0Y2goL15odHRwczpcXC9cXC90dXNkXFwudHVzZGVtb1xcLm5ldFxcL2ZpbGVzXFwvLylcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdVcGxvYWQgVVJMOicsIHVwbG9hZC51cmwpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuXG4gICAgICAgICAgICByZXNvbHZlKHVwbG9hZClcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uRXJyb3IgKGVycikge1xuICAgICAgICAgICAgcmVqZWN0KGVycilcbiAgICAgICAgICB9LFxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucylcbiAgICAgICAgdXBsb2FkLnN0YXJ0KClcbiAgICAgIH0pXG4gICAgICAgIC50aGVuKHZhbGlkYXRlVXBsb2FkQ29udGVudClcbiAgICAgICAgLnRoZW4oKHVwbG9hZCkgPT4ge1xuICAgICAgICAgIHJldHVybiB1cGxvYWQuYWJvcnQodHJ1ZSlcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHVwbG9hZClcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4odmFsaWRhdGVVcGxvYWREZWxldGlvbilcbiAgICB9LCBFTkRfVE9fRU5EX1RJTUVPVVQpXG5cbiAgICBpdCgnc2hvdWxkIHVwbG9hZCB0byBhIHJlYWwgdHVzIHNlcnZlciB3aXRoIGNyZWF0aW9uLXdpdGgtdXBsb2FkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgZmlsZSA9IGdldEJsb2IoJ2hlbGxvIHdvcmxkJylcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICBlbmRwb2ludDogJ2h0dHBzOi8vdHVzZC50dXNkZW1vLm5ldC9maWxlcy8nLFxuICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICBub25sYXRpbjogJ3PFgm/FhGNlJyxcbiAgICAgICAgICAgIG51bWJlciAgOiAxMDAsXG4gICAgICAgICAgICBmaWxlbmFtZTogJ2hlbGxvLnR4dCcsXG4gICAgICAgICAgICBmaWxldHlwZTogJ3RleHQvcGxhaW4nLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgb25TdWNjZXNzICgpIHtcbiAgICAgICAgICAgIGV4cGVjdCh1cGxvYWQudXJsKS50b01hdGNoKC9eaHR0cHM6XFwvXFwvdHVzZFxcLnR1c2RlbW9cXC5uZXRcXC9maWxlc1xcLy8pXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnVXBsb2FkIFVSTDonLCB1cGxvYWQudXJsKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcblxuICAgICAgICAgICAgcmVzb2x2ZSh1cGxvYWQpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbkVycm9yIChlcnIpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnIpXG4gICAgICAgICAgfSxcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpXG4gICAgICAgIHVwbG9hZC5zdGFydCgpXG4gICAgICB9KVxuICAgICAgICAudGhlbih2YWxpZGF0ZVVwbG9hZENvbnRlbnQpXG4gICAgfSwgRU5EX1RPX0VORF9USU1FT1VUKVxuICB9KVxufSlcblxuZnVuY3Rpb24gdmFsaWRhdGVVcGxvYWRDb250ZW50ICh1cGxvYWQpIHtcbiAgcmV0dXJuIGF4aW9zLmdldCh1cGxvYWQudXJsKVxuICAgIC50aGVuKChyZXMpID0+IHtcbiAgICAgIGV4cGVjdChyZXMuc3RhdHVzKS50b0JlKDIwMClcbiAgICAgIGV4cGVjdChyZXMuZGF0YSkudG9CZSgnaGVsbG8gd29ybGQnKVxuXG4gICAgICByZXR1cm4gdmFsaWRhdGVVcGxvYWRNZXRhZGF0YSh1cGxvYWQpXG4gICAgfSlcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVVcGxvYWRNZXRhZGF0YSAodXBsb2FkKSB7XG4gIHJldHVybiBheGlvcy5oZWFkKHVwbG9hZC51cmwsIHtcbiAgICBoZWFkZXJzOiB7XG4gICAgICAnVHVzLVJlc3VtYWJsZSc6ICcxLjAuMCcsXG4gICAgfSxcbiAgfSkudGhlbigocmVzKSA9PiB7XG4gICAgZXhwZWN0KHJlcy5zdGF0dXMpLnRvQmUoMjAwKVxuICAgIGV4cGVjdChyZXMuZGF0YSkudG9CZSgnJylcbiAgICBleHBlY3QocmVzLmhlYWRlcnNbJ3R1cy1yZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuICAgIGV4cGVjdChyZXMuaGVhZGVyc1sndXBsb2FkLW9mZnNldCddKS50b0JlKCcxMScpXG4gICAgZXhwZWN0KHJlcy5oZWFkZXJzWyd1cGxvYWQtbGVuZ3RoJ10pLnRvQmUoJzExJylcblxuICAgIC8vIFRoZSB2YWx1ZXMgaW4gdGhlIFVwbG9hZC1NZXRhZGF0YSBoZWFkZXIgbWF5IG5vdCBiZSBpbiB0aGUgc2FtZVxuICAgIC8vIG9yZGVyIGFzIHdlIHN1Ym1pdHRlZCB0aGVtICh0aGUgc3BlY2lmaWNhdGlvbiBkb2VzIG5vdCByZXF1aXJlXG4gICAgLy8gdGhhdCkuIFRoZXJlZm9yZSwgd2Ugc3BsaXQgdGhlIHZhbHVlcyBhbmQgdmVyaWZ5IHRoYXQgZWFjaCBvbmVcbiAgICAvLyBpcyBwcmVzZW50LlxuICAgIGNvbnN0IG1ldGFkYXRhU3RyID0gcmVzLmhlYWRlcnNbJ3VwbG9hZC1tZXRhZGF0YSddXG4gICAgZXhwZWN0KG1ldGFkYXRhU3RyKS50b0JlVHJ1dGh5KClcbiAgICBjb25zdCBtZXRhZGF0YSA9IG1ldGFkYXRhU3RyLnNwbGl0KCcsJylcbiAgICBleHBlY3QobWV0YWRhdGEpLnRvQ29udGFpbignZmlsZW5hbWUgYUdWc2JHOHVkSGgwJylcbiAgICBleHBlY3QobWV0YWRhdGEpLnRvQ29udGFpbignZmlsZXR5cGUgZEdWNGRDOXdiR0ZwYmc9PScpXG4gICAgZXhwZWN0KG1ldGFkYXRhKS50b0NvbnRhaW4oJ25vbmxhdGluIGM4V0NiOFdFWTJVPScpXG4gICAgZXhwZWN0KG1ldGFkYXRhKS50b0NvbnRhaW4oJ251bWJlciBNVEF3JylcbiAgICBleHBlY3QobWV0YWRhdGEubGVuZ3RoKS50b0JlKDQpXG5cbiAgICByZXR1cm4gdXBsb2FkXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlVXBsb2FkRGVsZXRpb24gKHVwbG9hZCkge1xuICByZXR1cm4gYXhpb3MuZ2V0KHVwbG9hZC51cmwsIHtcbiAgICB2YWxpZGF0ZVN0YXR1czogKHN0YXR1cykgPT4gc3RhdHVzID09PSA0MDQsXG4gIH0pXG4gICAgLnRoZW4oKHJlcykgPT4ge1xuICAgICAgZXhwZWN0KHJlcy5zdGF0dXMpLnRvQmUoNDA0KVxuXG4gICAgICByZXR1cm4gdXBsb2FkXG4gICAgfSlcbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLWxvbmUtYmxvY2tzICovXG5cbmNvbnN0IHsgVGVzdEh0dHBTdGFjaywgd2FpdGFibGVGdW5jdGlvbiwgZ2V0QmxvYiB9ID0gcmVxdWlyZSgnLi9oZWxwZXJzL3V0aWxzJylcbmNvbnN0IHR1cyA9IHJlcXVpcmUoJy4uLy4uJylcblxuZGVzY3JpYmUoJ3R1cycsICgpID0+IHtcbiAgZGVzY3JpYmUoJ3BhcmFsbGVsIHVwbG9hZGluZyB3aXRoIHN0YWdnZXInLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBpZiBzdGFnZ2VyUGVyY2VudCBpcyBwYXNzZWQgd2l0aG91dCBwYXJhbGxlbFVwbG9hZHMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBmaWxlID0gZ2V0QmxvYignaGVsbG8gd29ybGQnKVxuICAgICAgY29uc3QgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwge1xuICAgICAgICBlbmRwb2ludCAgICAgIDogJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMnLFxuICAgICAgICBzdGFnZ2VyUGVyY2VudDogNTAsXG4gICAgICAgIHVwbG9hZFVybCAgICAgOiAnZm9vJyxcbiAgICAgIH0pXG4gICAgICBleHBlY3QodXBsb2FkLnN0YXJ0LmJpbmQodXBsb2FkKSkudG9UaHJvd0Vycm9yKCd0dXM6IGNhbm5vdCB1c2UgdGhlIHN0YWdnZXJQZXJjZW50IG9wdGlvbiB3aGVuIHBhcmFsbGVsVXBsb2FkcyBpcyBkaXNhYmxlZCcpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgc3RhZ2dlciBhIG11bHRpLXBhcnQgdXBsb2FkLCBvbmUgY2h1bmsgcGVyIHBhcnQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG5cbiAgICAgIGNvbnN0IHRlc3RVcmxTdG9yYWdlID0ge1xuICAgICAgICBhZGRVcGxvYWQ6IChmaW5nZXJwcmludCwgdXBsb2FkKSA9PiB7XG4gICAgICAgICAgZXhwZWN0KGZpbmdlcnByaW50KS50b0JlKCdmaW5nZXJwcmludGVkJylcbiAgICAgICAgICBleHBlY3QodXBsb2FkLnVwbG9hZFVybCkudG9CZVVuZGVmaW5lZCgpXG4gICAgICAgICAgZXhwZWN0KHVwbG9hZC5zaXplKS50b0JlKDEwKVxuICAgICAgICAgIGV4cGVjdCh1cGxvYWQucGFyYWxsZWxVcGxvYWRVcmxzKS50b0VxdWFsKFtcbiAgICAgICAgICAgICdodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDEnLFxuICAgICAgICAgICAgJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMicsXG4gICAgICAgICAgXSlcblxuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoJ3R1czo6ZmluZ2VycHJpbnRlZDo6MTMzNycpXG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZVVwbG9hZDogKHVybFN0b3JhZ2VLZXkpID0+IHtcbiAgICAgICAgICBleHBlY3QodXJsU3RvcmFnZUtleSkudG9CZSgndHVzOjpmaW5nZXJwcmludGVkOjoxMzM3JylcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICAgIHNweU9uKHRlc3RVcmxTdG9yYWdlLCAncmVtb3ZlVXBsb2FkJykuYW5kLmNhbGxUaHJvdWdoKClcbiAgICAgIHNweU9uKHRlc3RVcmxTdG9yYWdlLCAnYWRkVXBsb2FkJykuYW5kLmNhbGxUaHJvdWdoKClcblxuICAgICAgY29uc3QgZmlsZSA9IGdldEJsb2IoJ2hlbGxvd29ybGQnKVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrICAgICAgICAgICAgICAgICAgOiB0ZXN0U3RhY2ssXG4gICAgICAgIHVybFN0b3JhZ2UgICAgICAgICAgICAgICAgIDogdGVzdFVybFN0b3JhZ2UsXG4gICAgICAgIHN0b3JlRmluZ2VycHJpbnRGb3JSZXN1bWluZzogdHJ1ZSxcbiAgICAgICAgcmVtb3ZlRmluZ2VycHJpbnRPblN1Y2Nlc3MgOiB0cnVlLFxuICAgICAgICBjaHVua1NpemUgICAgICAgICAgICAgICAgICA6IDUsXG4gICAgICAgIHBhcmFsbGVsVXBsb2FkcyAgICAgICAgICAgIDogMixcbiAgICAgICAgc3BsaXRTaXplSW50b1BhcnRzICAgICAgICAgOiAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIFt7IHN0YXJ0OiAwLCBlbmQ6IDUgfSwgeyBzdGFydDogNSwgZW5kOiAxMCB9XVxuICAgICAgICB9LFxuICAgICAgICBzdGFnZ2VyUGVyY2VudDogNTAsXG4gICAgICAgIHJldHJ5RGVsYXlzICAgOiBbMTBdLFxuICAgICAgICBlbmRwb2ludCAgICAgIDogJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMnLFxuICAgICAgICBoZWFkZXJzICAgICAgIDoge1xuICAgICAgICAgIEN1c3RvbTogJ2JsYXJnaCcsXG4gICAgICAgIH0sXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgZm9vOiAnaGVsbG8nLFxuICAgICAgICB9LFxuICAgICAgICBvblByb2dyZXNzICgpIHt9LFxuICAgICAgICBvblN1Y2Nlc3MgIDogd2FpdGFibGVGdW5jdGlvbigpLFxuICAgICAgICBmaW5nZXJwcmludDogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCdmaW5nZXJwcmludGVkJyksXG4gICAgICB9XG4gICAgICBzcHlPbihvcHRpb25zLCAnb25Qcm9ncmVzcycpXG5cbiAgICAgIGNvbnN0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpXG4gICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICBsZXQgcmVxXG5cbiAgICAgIHtcbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMnKVxuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnMuQ3VzdG9tKS50b0JlKCdibGFyZ2gnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLUxlbmd0aCddKS50b0JlKDUpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1Db25jYXQnXSkudG9CZSgncGFydGlhbCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1NZXRhZGF0YSddKS50b0JlVW5kZWZpbmVkKClcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1cyAgICAgICAgIDogMjAxLFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgTG9jYXRpb246ICdodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDEnLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcblxuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQxJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVycy5DdXN0b20pLnRvQmUoJ2JsYXJnaCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtT2Zmc2V0J10pLnRvQmUoMClcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snQ29udGVudC1UeXBlJ10pLnRvQmUoJ2FwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW0nKVxuICAgICAgICBleHBlY3QocmVxLmJvZHkuc2l6ZSkudG9CZSg1KVxuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDUsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAge1xuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuXG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwczovL3R1cy5pby91cGxvYWRzJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzLkN1c3RvbSkudG9CZSgnYmxhcmdoJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1MZW5ndGgnXSkudG9CZSg1KVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtQ29uY2F0J10pLnRvQmUoJ3BhcnRpYWwnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtTWV0YWRhdGEnXSkudG9CZVVuZGVmaW5lZCgpXG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwMSxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgIExvY2F0aW9uOiAnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQyJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG5cbiAgICAgICAgLy8gQXNzZXJ0IHRoYXQgdGhlIFVSTHMgaGF2ZSBiZWVuIHN0b3JlZC5cbiAgICAgICAgZXhwZWN0KHRlc3RVcmxTdG9yYWdlLmFkZFVwbG9hZCkudG9IYXZlQmVlbkNhbGxlZCgpXG5cbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMicpXG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnMuQ3VzdG9tKS50b0JlKCdibGFyZ2gnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLU9mZnNldCddKS50b0JlKDApXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKS50b0JlKCdhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtJylcbiAgICAgICAgZXhwZWN0KHJlcS5ib2R5LnNpemUpLnRvQmUoNSlcblxuICAgICAgICAvLyBSZXR1cm4gYW4gZXJyb3IgdG8gZW5zdXJlIHRoYXQgdGhlIGluZGl2aWR1YWwgcGFydGlhbCB1cGxvYWQgaXMgcHJvcGVybHkgcmV0cmllZC5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXM6IDUwMCxcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAge1xuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQyJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ0hFQUQnKVxuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICAnVXBsb2FkLUxlbmd0aCc6IDEwLFxuICAgICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAwLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMicpXG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnMuQ3VzdG9tKS50b0JlKCdibGFyZ2gnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLU9mZnNldCddKS50b0JlKDApXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKS50b0JlKCdhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtJylcbiAgICAgICAgZXhwZWN0KHJlcS5ib2R5LnNpemUpLnRvQmUoNSlcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiA1LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMnKVxuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnMuQ3VzdG9tKS50b0JlKCdibGFyZ2gnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLUxlbmd0aCddKS50b0JlVW5kZWZpbmVkKClcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLUNvbmNhdCddKS50b0JlKCdmaW5hbDtodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDEgaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQyJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLU1ldGFkYXRhJ10pLnRvQmUoJ2ZvbyBhR1ZzYkc4PScpXG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwMSxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgIExvY2F0aW9uOiAnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQzJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBhd2FpdCBvcHRpb25zLm9uU3VjY2Vzcy50b0JlQ2FsbGVkXG5cbiAgICAgIGV4cGVjdCh1cGxvYWQudXJsKS50b0JlKCdodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDMnKVxuICAgICAgZXhwZWN0KG9wdGlvbnMub25Qcm9ncmVzcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNSwgMTApXG4gICAgICBleHBlY3Qob3B0aW9ucy5vblByb2dyZXNzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgxMCwgMTApXG4gICAgICBleHBlY3QodGVzdFVybFN0b3JhZ2UucmVtb3ZlVXBsb2FkKS50b0hhdmVCZWVuQ2FsbGVkKClcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBzdGFnZ2VyIGEgbXVsdGktcGFydCB1cGxvYWQsIG1peCBvZiBjaHVuayBhbW91bnRzIHBlciBwYXJ0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuXG4gICAgICBjb25zdCB0ZXN0VXJsU3RvcmFnZSA9IHtcbiAgICAgICAgYWRkVXBsb2FkOiAoZmluZ2VycHJpbnQsIHVwbG9hZCkgPT4ge1xuICAgICAgICAgIGV4cGVjdChmaW5nZXJwcmludCkudG9CZSgnZmluZ2VycHJpbnRlZCcpXG4gICAgICAgICAgZXhwZWN0KHVwbG9hZC51cGxvYWRVcmwpLnRvQmVVbmRlZmluZWQoKVxuICAgICAgICAgIGV4cGVjdCh1cGxvYWQuc2l6ZSkudG9CZSgxNSlcbiAgICAgICAgICBleHBlY3QodXBsb2FkLnBhcmFsbGVsVXBsb2FkVXJscykudG9FcXVhbChbXG4gICAgICAgICAgICAnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQxJyxcbiAgICAgICAgICAgICdodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDInLFxuICAgICAgICAgIF0pXG5cbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCd0dXM6OmZpbmdlcnByaW50ZWQ6OjEzMzcnKVxuICAgICAgICB9LFxuICAgICAgICByZW1vdmVVcGxvYWQ6ICh1cmxTdG9yYWdlS2V5KSA9PiB7XG4gICAgICAgICAgZXhwZWN0KHVybFN0b3JhZ2VLZXkpLnRvQmUoJ3R1czo6ZmluZ2VycHJpbnRlZDo6MTMzNycpXG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgIH0sXG4gICAgICB9XG4gICAgICBzcHlPbih0ZXN0VXJsU3RvcmFnZSwgJ3JlbW92ZVVwbG9hZCcpLmFuZC5jYWxsVGhyb3VnaCgpXG4gICAgICBzcHlPbih0ZXN0VXJsU3RvcmFnZSwgJ2FkZFVwbG9hZCcpLmFuZC5jYWxsVGhyb3VnaCgpXG5cbiAgICAgIGNvbnN0IGZpbGUgPSBnZXRCbG9iKCdoZWxsbyB3b3JsZDEyMzQnKVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrICAgICAgICAgICAgICAgICAgOiB0ZXN0U3RhY2ssXG4gICAgICAgIHVybFN0b3JhZ2UgICAgICAgICAgICAgICAgIDogdGVzdFVybFN0b3JhZ2UsXG4gICAgICAgIHN0b3JlRmluZ2VycHJpbnRGb3JSZXN1bWluZzogdHJ1ZSxcbiAgICAgICAgcmVtb3ZlRmluZ2VycHJpbnRPblN1Y2Nlc3MgOiB0cnVlLFxuICAgICAgICBjaHVua1NpemUgICAgICAgICAgICAgICAgICA6IDUsXG4gICAgICAgIHBhcmFsbGVsVXBsb2FkcyAgICAgICAgICAgIDogMixcbiAgICAgICAgc3BsaXRTaXplSW50b1BhcnRzICAgICAgICAgOiAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIFt7IHN0YXJ0OiAwLCBlbmQ6IDEwIH0sIHsgc3RhcnQ6IDEwLCBlbmQ6IDE1IH1dXG4gICAgICAgIH0sXG4gICAgICAgIHN0YWdnZXJQZXJjZW50OiA1MCxcbiAgICAgICAgcmV0cnlEZWxheXMgICA6IFsxMF0sXG4gICAgICAgIGVuZHBvaW50ICAgICAgOiAnaHR0cHM6Ly90dXMuaW8vdXBsb2FkcycsXG4gICAgICAgIGhlYWRlcnMgICAgICAgOiB7XG4gICAgICAgICAgQ3VzdG9tOiAnYmxhcmdoJyxcbiAgICAgICAgfSxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICBmb286ICdoZWxsbycsXG4gICAgICAgIH0sXG4gICAgICAgIG9uUHJvZ3Jlc3MgKCkge30sXG4gICAgICAgIG9uU3VjY2VzcyAgOiB3YWl0YWJsZUZ1bmN0aW9uKCksXG4gICAgICAgIGZpbmdlcnByaW50OiAoKSA9PiBQcm9taXNlLnJlc29sdmUoJ2ZpbmdlcnByaW50ZWQnKSxcbiAgICAgIH1cbiAgICAgIHNweU9uKG9wdGlvbnMsICdvblByb2dyZXNzJylcblxuICAgICAgY29uc3QgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucylcbiAgICAgIHVwbG9hZC5zdGFydCgpXG5cbiAgICAgIGxldCByZXFcblxuICAgICAge1xuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cHM6Ly90dXMuaW8vdXBsb2FkcycpXG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQT1NUJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVycy5DdXN0b20pLnRvQmUoJ2JsYXJnaCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtTGVuZ3RoJ10pLnRvQmUoMTApXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1Db25jYXQnXSkudG9CZSgncGFydGlhbCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1NZXRhZGF0YSddKS50b0JlVW5kZWZpbmVkKClcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1cyAgICAgICAgIDogMjAxLFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgTG9jYXRpb246ICdodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDEnLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcblxuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQxJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVycy5DdXN0b20pLnRvQmUoJ2JsYXJnaCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtT2Zmc2V0J10pLnRvQmUoMClcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snQ29udGVudC1UeXBlJ10pLnRvQmUoJ2FwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW0nKVxuICAgICAgICBleHBlY3QocmVxLmJvZHkuc2l6ZSkudG9CZSg1KVxuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDUsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAge1xuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuXG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwczovL3R1cy5pby91cGxvYWRzJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzLkN1c3RvbSkudG9CZSgnYmxhcmdoJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1MZW5ndGgnXSkudG9CZSg1KVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtQ29uY2F0J10pLnRvQmUoJ3BhcnRpYWwnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtTWV0YWRhdGEnXSkudG9CZVVuZGVmaW5lZCgpXG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwMSxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgIExvY2F0aW9uOiAnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQyJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG5cbiAgICAgICAgLy8gQXNzZXJ0IHRoYXQgdGhlIFVSTHMgaGF2ZSBiZWVuIHN0b3JlZC5cbiAgICAgICAgZXhwZWN0KHRlc3RVcmxTdG9yYWdlLmFkZFVwbG9hZCkudG9IYXZlQmVlbkNhbGxlZCgpXG5cbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMicpXG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnMuQ3VzdG9tKS50b0JlKCdibGFyZ2gnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLU9mZnNldCddKS50b0JlKDApXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKS50b0JlKCdhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtJylcbiAgICAgICAgZXhwZWN0KHJlcS5ib2R5LnNpemUpLnRvQmUoNSlcblxuICAgICAgICAvLyBSZXR1cm4gYW4gZXJyb3IgdG8gZW5zdXJlIHRoYXQgdGhlIGluZGl2aWR1YWwgcGFydGlhbCB1cGxvYWQgaXMgcHJvcGVybHkgcmV0cmllZC5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXM6IDUwMCxcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAge1xuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuXG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDEnKVxuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzLkN1c3RvbSkudG9CZSgnYmxhcmdoJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1PZmZzZXQnXSkudG9CZSg1KVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXSkudG9CZSgnYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbScpXG4gICAgICAgIGV4cGVjdChyZXEuYm9keS5zaXplKS50b0JlKDUpXG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMTAsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAge1xuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQyJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ0hFQUQnKVxuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICAnVXBsb2FkLUxlbmd0aCc6IDE1LFxuICAgICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAwLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMicpXG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnMuQ3VzdG9tKS50b0JlKCdibGFyZ2gnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLU9mZnNldCddKS50b0JlKDApXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKS50b0JlKCdhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtJylcbiAgICAgICAgZXhwZWN0KHJlcS5ib2R5LnNpemUpLnRvQmUoNSlcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiA1LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMnKVxuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnMuQ3VzdG9tKS50b0JlKCdibGFyZ2gnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLUxlbmd0aCddKS50b0JlVW5kZWZpbmVkKClcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLUNvbmNhdCddKS50b0JlKCdmaW5hbDtodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDEgaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQyJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLU1ldGFkYXRhJ10pLnRvQmUoJ2ZvbyBhR1ZzYkc4PScpXG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwMSxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgIExvY2F0aW9uOiAnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQzJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBhd2FpdCBvcHRpb25zLm9uU3VjY2Vzcy50b0JlQ2FsbGVkXG5cbiAgICAgIGV4cGVjdCh1cGxvYWQudXJsKS50b0JlKCdodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDMnKVxuICAgICAgZXhwZWN0KG9wdGlvbnMub25Qcm9ncmVzcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNSwgMTUpXG4gICAgICBleHBlY3Qob3B0aW9ucy5vblByb2dyZXNzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgxMCwgMTUpXG4gICAgICBleHBlY3Qob3B0aW9ucy5vblByb2dyZXNzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgxNSwgMTUpXG4gICAgICBleHBlY3QodGVzdFVybFN0b3JhZ2UucmVtb3ZlVXBsb2FkKS50b0hhdmVCZWVuQ2FsbGVkKClcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBzdGFnZ2VyIGEgbXVsdGktcGFydCB1cGxvYWQsIG9uZSBjaHVuayBwZXIgcGFydCwgbGFzdCBwYXJ0IGhhdmluZyBsZWZ0b3ZlcicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcblxuICAgICAgY29uc3QgdGVzdFVybFN0b3JhZ2UgPSB7XG4gICAgICAgIGFkZFVwbG9hZDogKGZpbmdlcnByaW50LCB1cGxvYWQpID0+IHtcbiAgICAgICAgICBleHBlY3QoZmluZ2VycHJpbnQpLnRvQmUoJ2ZpbmdlcnByaW50ZWQnKVxuICAgICAgICAgIGV4cGVjdCh1cGxvYWQudXBsb2FkVXJsKS50b0JlVW5kZWZpbmVkKClcbiAgICAgICAgICBleHBlY3QodXBsb2FkLnNpemUpLnRvQmUoMTEpXG4gICAgICAgICAgZXhwZWN0KHVwbG9hZC5wYXJhbGxlbFVwbG9hZFVybHMpLnRvRXF1YWwoW1xuICAgICAgICAgICAgJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMScsXG4gICAgICAgICAgICAnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQyJyxcbiAgICAgICAgICBdKVxuXG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgndHVzOjpmaW5nZXJwcmludGVkOjoxMzM3JylcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlVXBsb2FkOiAodXJsU3RvcmFnZUtleSkgPT4ge1xuICAgICAgICAgIGV4cGVjdCh1cmxTdG9yYWdlS2V5KS50b0JlKCd0dXM6OmZpbmdlcnByaW50ZWQ6OjEzMzcnKVxuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICB9LFxuICAgICAgfVxuICAgICAgc3B5T24odGVzdFVybFN0b3JhZ2UsICdyZW1vdmVVcGxvYWQnKS5hbmQuY2FsbFRocm91Z2goKVxuICAgICAgc3B5T24odGVzdFVybFN0b3JhZ2UsICdhZGRVcGxvYWQnKS5hbmQuY2FsbFRocm91Z2goKVxuXG4gICAgICBjb25zdCBmaWxlID0gZ2V0QmxvYignaGVsbG8gd29ybGQnKVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrICAgICAgICAgICAgICAgICAgOiB0ZXN0U3RhY2ssXG4gICAgICAgIHVybFN0b3JhZ2UgICAgICAgICAgICAgICAgIDogdGVzdFVybFN0b3JhZ2UsXG4gICAgICAgIHN0b3JlRmluZ2VycHJpbnRGb3JSZXN1bWluZzogdHJ1ZSxcbiAgICAgICAgcmVtb3ZlRmluZ2VycHJpbnRPblN1Y2Nlc3MgOiB0cnVlLFxuICAgICAgICBjaHVua1NpemUgICAgICAgICAgICAgICAgICA6IDUsXG4gICAgICAgIHBhcmFsbGVsVXBsb2FkcyAgICAgICAgICAgIDogMixcbiAgICAgICAgc3BsaXRTaXplSW50b1BhcnRzICAgICAgICAgOiAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIFt7IHN0YXJ0OiAwLCBlbmQ6IDUgfSwgeyBzdGFydDogNSwgZW5kOiAxMSB9XVxuICAgICAgICB9LFxuICAgICAgICBzdGFnZ2VyUGVyY2VudDogNTAsXG4gICAgICAgIHJldHJ5RGVsYXlzICAgOiBbMTBdLFxuICAgICAgICBlbmRwb2ludCAgICAgIDogJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMnLFxuICAgICAgICBoZWFkZXJzICAgICAgIDoge1xuICAgICAgICAgIEN1c3RvbTogJ2JsYXJnaCcsXG4gICAgICAgIH0sXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgZm9vOiAnaGVsbG8nLFxuICAgICAgICB9LFxuICAgICAgICBvblByb2dyZXNzICgpIHt9LFxuICAgICAgICBvblN1Y2Nlc3MgIDogd2FpdGFibGVGdW5jdGlvbigpLFxuICAgICAgICBmaW5nZXJwcmludDogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCdmaW5nZXJwcmludGVkJyksXG4gICAgICB9XG4gICAgICBzcHlPbihvcHRpb25zLCAnb25Qcm9ncmVzcycpXG5cbiAgICAgIGNvbnN0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpXG4gICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICBsZXQgcmVxXG5cbiAgICAgIHtcbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMnKVxuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnMuQ3VzdG9tKS50b0JlKCdibGFyZ2gnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLUxlbmd0aCddKS50b0JlKDYpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1Db25jYXQnXSkudG9CZSgncGFydGlhbCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1NZXRhZGF0YSddKS50b0JlVW5kZWZpbmVkKClcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1cyAgICAgICAgIDogMjAxLFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgTG9jYXRpb246ICdodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDInLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcblxuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQyJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVycy5DdXN0b20pLnRvQmUoJ2JsYXJnaCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtT2Zmc2V0J10pLnRvQmUoMClcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snQ29udGVudC1UeXBlJ10pLnRvQmUoJ2FwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW0nKVxuICAgICAgICBleHBlY3QocmVxLmJvZHkuc2l6ZSkudG9CZSg1KVxuXG4gICAgICAgIC8vIFJldHVybiBhbiBlcnJvciB0byBlbnN1cmUgdGhhdCB0aGUgaW5kaXZpZHVhbCBwYXJ0aWFsIHVwbG9hZCBpcyBwcm9wZXJseSByZXRyaWVkLlxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG5cbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMnKVxuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnMuQ3VzdG9tKS50b0JlKCdibGFyZ2gnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLUxlbmd0aCddKS50b0JlKDUpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1Db25jYXQnXSkudG9CZSgncGFydGlhbCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1NZXRhZGF0YSddKS50b0JlVW5kZWZpbmVkKClcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1cyAgICAgICAgIDogMjAxLFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgTG9jYXRpb246ICdodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDEnLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcblxuICAgICAgICAvLyBBc3NlcnQgdGhhdCB0aGUgVVJMcyBoYXZlIGJlZW4gc3RvcmVkLlxuICAgICAgICBleHBlY3QodGVzdFVybFN0b3JhZ2UuYWRkVXBsb2FkKS50b0hhdmVCZWVuQ2FsbGVkKClcblxuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQxJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVycy5DdXN0b20pLnRvQmUoJ2JsYXJnaCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtT2Zmc2V0J10pLnRvQmUoMClcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snQ29udGVudC1UeXBlJ10pLnRvQmUoJ2FwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW0nKVxuICAgICAgICBleHBlY3QocmVxLmJvZHkuc2l6ZSkudG9CZSg1KVxuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDUsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAge1xuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQyJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ0hFQUQnKVxuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICAnVXBsb2FkLUxlbmd0aCc6IDExLFxuICAgICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAwLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMicpXG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnMuQ3VzdG9tKS50b0JlKCdibGFyZ2gnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLU9mZnNldCddKS50b0JlKDApXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKS50b0JlKCdhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtJylcbiAgICAgICAgZXhwZWN0KHJlcS5ib2R5LnNpemUpLnRvQmUoNSlcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiA2LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMnKVxuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnMuQ3VzdG9tKS50b0JlKCdibGFyZ2gnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLUxlbmd0aCddKS50b0JlVW5kZWZpbmVkKClcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLUNvbmNhdCddKS50b0JlKCdmaW5hbDtodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDEgaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQyJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLU1ldGFkYXRhJ10pLnRvQmUoJ2ZvbyBhR1ZzYkc4PScpXG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwMSxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgIExvY2F0aW9uOiAnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQzJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBhd2FpdCBvcHRpb25zLm9uU3VjY2Vzcy50b0JlQ2FsbGVkXG5cbiAgICAgIGV4cGVjdCh1cGxvYWQudXJsKS50b0JlKCdodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDMnKVxuICAgICAgZXhwZWN0KG9wdGlvbnMub25Qcm9ncmVzcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNSwgMTEpXG4gICAgICBleHBlY3Qob3B0aW9ucy5vblByb2dyZXNzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgxMCwgMTEpXG4gICAgICBleHBlY3Qob3B0aW9ucy5vblByb2dyZXNzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgxMSwgMTEpXG4gICAgICBleHBlY3QodGVzdFVybFN0b3JhZ2UucmVtb3ZlVXBsb2FkKS50b0hhdmVCZWVuQ2FsbGVkKClcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBzdGFnZ2VyIGEgbXVsdGktcGFydCB1cGxvYWQsIG1peCBvZiBjaHVuayBhbW91bnRzIHBlciBwYXJ0LCBsYXN0IHBhcnQgaGF2aW5nIGxlZnRvdmVyJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuXG4gICAgICBjb25zdCB0ZXN0VXJsU3RvcmFnZSA9IHtcbiAgICAgICAgYWRkVXBsb2FkOiAoZmluZ2VycHJpbnQsIHVwbG9hZCkgPT4ge1xuICAgICAgICAgIGV4cGVjdChmaW5nZXJwcmludCkudG9CZSgnZmluZ2VycHJpbnRlZCcpXG4gICAgICAgICAgZXhwZWN0KHVwbG9hZC51cGxvYWRVcmwpLnRvQmVVbmRlZmluZWQoKVxuICAgICAgICAgIGV4cGVjdCh1cGxvYWQuc2l6ZSkudG9CZSgxNilcbiAgICAgICAgICBleHBlY3QodXBsb2FkLnBhcmFsbGVsVXBsb2FkVXJscykudG9FcXVhbChbXG4gICAgICAgICAgICAnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQxJyxcbiAgICAgICAgICAgICdodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDInLFxuICAgICAgICAgIF0pXG5cbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCd0dXM6OmZpbmdlcnByaW50ZWQ6OjEzMzcnKVxuICAgICAgICB9LFxuICAgICAgICByZW1vdmVVcGxvYWQ6ICh1cmxTdG9yYWdlS2V5KSA9PiB7XG4gICAgICAgICAgZXhwZWN0KHVybFN0b3JhZ2VLZXkpLnRvQmUoJ3R1czo6ZmluZ2VycHJpbnRlZDo6MTMzNycpXG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgIH0sXG4gICAgICB9XG4gICAgICBzcHlPbih0ZXN0VXJsU3RvcmFnZSwgJ3JlbW92ZVVwbG9hZCcpLmFuZC5jYWxsVGhyb3VnaCgpXG4gICAgICBzcHlPbih0ZXN0VXJsU3RvcmFnZSwgJ2FkZFVwbG9hZCcpLmFuZC5jYWxsVGhyb3VnaCgpXG5cbiAgICAgIGNvbnN0IGZpbGUgPSBnZXRCbG9iKCdoZWxsbyB3b3JsZDEyMzQ1JylcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjayAgICAgICAgICAgICAgICAgIDogdGVzdFN0YWNrLFxuICAgICAgICB1cmxTdG9yYWdlICAgICAgICAgICAgICAgICA6IHRlc3RVcmxTdG9yYWdlLFxuICAgICAgICBzdG9yZUZpbmdlcnByaW50Rm9yUmVzdW1pbmc6IHRydWUsXG4gICAgICAgIHJlbW92ZUZpbmdlcnByaW50T25TdWNjZXNzIDogdHJ1ZSxcbiAgICAgICAgY2h1bmtTaXplICAgICAgICAgICAgICAgICAgOiA1LFxuICAgICAgICBwYXJhbGxlbFVwbG9hZHMgICAgICAgICAgICA6IDIsXG4gICAgICAgIHNwbGl0U2l6ZUludG9QYXJ0cyAgICAgICAgIDogKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBbeyBzdGFydDogMCwgZW5kOiAxMCB9LCB7IHN0YXJ0OiAxMCwgZW5kOiAxNiB9XVxuICAgICAgICB9LFxuICAgICAgICBzdGFnZ2VyUGVyY2VudDogNTAsXG4gICAgICAgIHJldHJ5RGVsYXlzICAgOiBbMTBdLFxuICAgICAgICBlbmRwb2ludCAgICAgIDogJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMnLFxuICAgICAgICBoZWFkZXJzICAgICAgIDoge1xuICAgICAgICAgIEN1c3RvbTogJ2JsYXJnaCcsXG4gICAgICAgIH0sXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgZm9vOiAnaGVsbG8nLFxuICAgICAgICB9LFxuICAgICAgICBvblByb2dyZXNzICgpIHt9LFxuICAgICAgICBvblN1Y2Nlc3MgIDogd2FpdGFibGVGdW5jdGlvbigpLFxuICAgICAgICBmaW5nZXJwcmludDogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCdmaW5nZXJwcmludGVkJyksXG4gICAgICB9XG4gICAgICBzcHlPbihvcHRpb25zLCAnb25Qcm9ncmVzcycpXG5cbiAgICAgIGNvbnN0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpXG4gICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICBsZXQgcmVxXG5cbiAgICAgIHtcbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMnKVxuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnMuQ3VzdG9tKS50b0JlKCdibGFyZ2gnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLUxlbmd0aCddKS50b0JlKDEwKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtQ29uY2F0J10pLnRvQmUoJ3BhcnRpYWwnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtTWV0YWRhdGEnXSkudG9CZVVuZGVmaW5lZCgpXG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwMSxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgIExvY2F0aW9uOiAnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQxJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG5cbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMScpXG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnMuQ3VzdG9tKS50b0JlKCdibGFyZ2gnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLU9mZnNldCddKS50b0JlKDApXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKS50b0JlKCdhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtJylcbiAgICAgICAgZXhwZWN0KHJlcS5ib2R5LnNpemUpLnRvQmUoNSlcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiA1LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcblxuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cHM6Ly90dXMuaW8vdXBsb2FkcycpXG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQT1NUJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVycy5DdXN0b20pLnRvQmUoJ2JsYXJnaCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtTGVuZ3RoJ10pLnRvQmUoNilcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLUNvbmNhdCddKS50b0JlKCdwYXJ0aWFsJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLU1ldGFkYXRhJ10pLnRvQmVVbmRlZmluZWQoKVxuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDEsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICBMb2NhdGlvbjogJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMicsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAge1xuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuXG4gICAgICAgIC8vIEFzc2VydCB0aGF0IHRoZSBVUkxzIGhhdmUgYmVlbiBzdG9yZWQuXG4gICAgICAgIGV4cGVjdCh0ZXN0VXJsU3RvcmFnZS5hZGRVcGxvYWQpLnRvSGF2ZUJlZW5DYWxsZWQoKVxuXG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDInKVxuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzLkN1c3RvbSkudG9CZSgnYmxhcmdoJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1PZmZzZXQnXSkudG9CZSgwKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXSkudG9CZSgnYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbScpXG4gICAgICAgIGV4cGVjdChyZXEuYm9keS5zaXplKS50b0JlKDUpXG5cbiAgICAgICAgLy8gUmV0dXJuIGFuIGVycm9yIHRvIGVuc3VyZSB0aGF0IHRoZSBpbmRpdmlkdWFsIHBhcnRpYWwgdXBsb2FkIGlzIHByb3Blcmx5IHJldHJpZWQuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcblxuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQxJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVycy5DdXN0b20pLnRvQmUoJ2JsYXJnaCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtT2Zmc2V0J10pLnRvQmUoNSlcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snQ29udGVudC1UeXBlJ10pLnRvQmUoJ2FwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW0nKVxuICAgICAgICBleHBlY3QocmVxLmJvZHkuc2l6ZSkudG9CZSg1KVxuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDEwLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMicpXG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdIRUFEJylcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgJ1VwbG9hZC1MZW5ndGgnOiAxNSxcbiAgICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMCxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDInKVxuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzLkN1c3RvbSkudG9CZSgnYmxhcmdoJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1PZmZzZXQnXSkudG9CZSgwKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXSkudG9CZSgnYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbScpXG4gICAgICAgIGV4cGVjdChyZXEuYm9keS5zaXplKS50b0JlKDUpXG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogNSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDInKVxuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzLkN1c3RvbSkudG9CZSgnYmxhcmdoJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1PZmZzZXQnXSkudG9CZSg1KVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXSkudG9CZSgnYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbScpXG4gICAgICAgIGV4cGVjdChyZXEuYm9keS5zaXplKS50b0JlKDEpXG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogNixcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwczovL3R1cy5pby91cGxvYWRzJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzLkN1c3RvbSkudG9CZSgnYmxhcmdoJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1MZW5ndGgnXSkudG9CZVVuZGVmaW5lZCgpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1Db25jYXQnXSkudG9CZSgnZmluYWw7aHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQxIGh0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMicpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1NZXRhZGF0YSddKS50b0JlKCdmb28gYUdWc2JHOD0nKVxuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDEsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICBMb2NhdGlvbjogJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMycsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgYXdhaXQgb3B0aW9ucy5vblN1Y2Nlc3MudG9CZUNhbGxlZFxuXG4gICAgICBleHBlY3QodXBsb2FkLnVybCkudG9CZSgnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQzJylcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uUHJvZ3Jlc3MpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDUsIDE2KVxuICAgICAgZXhwZWN0KG9wdGlvbnMub25Qcm9ncmVzcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMTAsIDE2KVxuICAgICAgZXhwZWN0KG9wdGlvbnMub25Qcm9ncmVzcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMTUsIDE2KVxuICAgICAgZXhwZWN0KG9wdGlvbnMub25Qcm9ncmVzcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMTYsIDE2KVxuICAgICAgZXhwZWN0KHRlc3RVcmxTdG9yYWdlLnJlbW92ZVVwbG9hZCkudG9IYXZlQmVlbkNhbGxlZCgpXG4gICAgfSlcbiAgfSlcbn0pXG4iLCJjb25zdCB7IFRlc3RIdHRwU3RhY2ssIHdhaXRhYmxlRnVuY3Rpb24sIHdhaXQsIGdldEJsb2IgfSA9IHJlcXVpcmUoJy4vaGVscGVycy91dGlscycpXG5jb25zdCB0dXMgPSByZXF1aXJlKCcuLi8uLicpXG5cbmRlc2NyaWJlKCd0dXMnLCAoKSA9PiB7XG4gIGRlc2NyaWJlKCdwYXJhbGxlbCB1cGxvYWRpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBpZiBpbmNvbXBhdGlibGUgb3B0aW9ucyBhcmUgdXNlZCcsICgpID0+IHtcbiAgICAgIGNvbnN0IGZpbGUgPSBnZXRCbG9iKCdoZWxsbyB3b3JsZCcpXG4gICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCB7XG4gICAgICAgIGVuZHBvaW50ICAgICAgIDogJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMnLFxuICAgICAgICBwYXJhbGxlbFVwbG9hZHM6IDIsXG4gICAgICAgIHVwbG9hZFVybCAgICAgIDogJ2ZvbycsXG4gICAgICB9KVxuICAgICAgZXhwZWN0KHVwbG9hZC5zdGFydC5iaW5kKHVwbG9hZCkpLnRvVGhyb3dFcnJvcigndHVzOiBjYW5ub3QgdXNlIHRoZSB1cGxvYWRVcmwgb3B0aW9uIHdoZW4gcGFyYWxsZWxVcGxvYWRzIGlzIGVuYWJsZWQnKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIHRocm93IGlmIHNwbGl0U2l6ZUludG9QYXJ0cyBpcyBwYXNzZWQgd2l0aG91dCBwYXJhbGxlbFVwbG9hZHMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBmaWxlID0gZ2V0QmxvYignaGVsbG8gd29ybGQnKVxuICAgICAgY29uc3QgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwge1xuICAgICAgICBlbmRwb2ludCAgICAgICAgICA6ICdodHRwczovL3R1cy5pby91cGxvYWRzJyxcbiAgICAgICAgc3BsaXRTaXplSW50b1BhcnRzOiAoKSA9PiB7fSxcbiAgICAgICAgdXBsb2FkVXJsICAgICAgICAgOiAnZm9vJyxcbiAgICAgIH0pXG4gICAgICBleHBlY3QodXBsb2FkLnN0YXJ0LmJpbmQodXBsb2FkKSkudG9UaHJvd0Vycm9yKCd0dXM6IGNhbm5vdCB1c2UgdGhlIHNwbGl0U2l6ZUludG9QYXJ0cyBvcHRpb24gd2hlbiBwYXJhbGxlbFVwbG9hZHMgaXMgZGlzYWJsZWQnKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIHNwbGl0IGEgZmlsZSBpbnRvIG11bHRpcGxlIHBhcnRzIGFuZCBjcmVhdGUgYW4gdXBsb2FkIGZvciBlYWNoJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuXG4gICAgICBjb25zdCB0ZXN0VXJsU3RvcmFnZSA9IHtcbiAgICAgICAgYWRkVXBsb2FkOiAoZmluZ2VycHJpbnQsIHVwbG9hZCkgPT4ge1xuICAgICAgICAgIGV4cGVjdChmaW5nZXJwcmludCkudG9CZSgnZmluZ2VycHJpbnRlZCcpXG4gICAgICAgICAgZXhwZWN0KHVwbG9hZC51cGxvYWRVcmwpLnRvQmVVbmRlZmluZWQoKVxuICAgICAgICAgIGV4cGVjdCh1cGxvYWQuc2l6ZSkudG9CZSgxMSlcbiAgICAgICAgICBleHBlY3QodXBsb2FkLnBhcmFsbGVsVXBsb2FkVXJscykudG9FcXVhbChbXG4gICAgICAgICAgICAnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQxJyxcbiAgICAgICAgICAgICdodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDInLFxuICAgICAgICAgIF0pXG5cbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCd0dXM6OmZpbmdlcnByaW50ZWQ6OjEzMzcnKVxuICAgICAgICB9LFxuICAgICAgICByZW1vdmVVcGxvYWQ6ICh1cmxTdG9yYWdlS2V5KSA9PiB7XG4gICAgICAgICAgZXhwZWN0KHVybFN0b3JhZ2VLZXkpLnRvQmUoJ3R1czo6ZmluZ2VycHJpbnRlZDo6MTMzNycpXG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgIH0sXG4gICAgICB9XG4gICAgICBzcHlPbih0ZXN0VXJsU3RvcmFnZSwgJ3JlbW92ZVVwbG9hZCcpLmFuZC5jYWxsVGhyb3VnaCgpXG4gICAgICBzcHlPbih0ZXN0VXJsU3RvcmFnZSwgJ2FkZFVwbG9hZCcpLmFuZC5jYWxsVGhyb3VnaCgpXG5cbiAgICAgIGNvbnN0IGZpbGUgPSBnZXRCbG9iKCdoZWxsbyB3b3JsZCcpXG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2sgICAgICAgICAgICAgICAgICA6IHRlc3RTdGFjayxcbiAgICAgICAgdXJsU3RvcmFnZSAgICAgICAgICAgICAgICAgOiB0ZXN0VXJsU3RvcmFnZSxcbiAgICAgICAgc3RvcmVGaW5nZXJwcmludEZvclJlc3VtaW5nOiB0cnVlLFxuICAgICAgICByZW1vdmVGaW5nZXJwcmludE9uU3VjY2VzcyA6IHRydWUsXG4gICAgICAgIHBhcmFsbGVsVXBsb2FkcyAgICAgICAgICAgIDogMixcbiAgICAgICAgcmV0cnlEZWxheXMgICAgICAgICAgICAgICAgOiBbMTBdLFxuICAgICAgICBlbmRwb2ludCAgICAgICAgICAgICAgICAgICA6ICdodHRwczovL3R1cy5pby91cGxvYWRzJyxcbiAgICAgICAgaGVhZGVycyAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgQ3VzdG9tOiAnYmxhcmdoJyxcbiAgICAgICAgfSxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICBmb286ICdoZWxsbycsXG4gICAgICAgIH0sXG4gICAgICAgIG9uUHJvZ3Jlc3MgKCkge30sXG4gICAgICAgIG9uU3VjY2VzcyAgOiB3YWl0YWJsZUZ1bmN0aW9uKCksXG4gICAgICAgIGZpbmdlcnByaW50OiAoKSA9PiBQcm9taXNlLnJlc29sdmUoJ2ZpbmdlcnByaW50ZWQnKSxcbiAgICAgIH1cbiAgICAgIHNweU9uKG9wdGlvbnMsICdvblByb2dyZXNzJylcblxuICAgICAgY29uc3QgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucylcbiAgICAgIHVwbG9hZC5zdGFydCgpXG5cbiAgICAgIGxldCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVycy5DdXN0b20pLnRvQmUoJ2JsYXJnaCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1MZW5ndGgnXSkudG9CZSg1KVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLUNvbmNhdCddKS50b0JlKCdwYXJ0aWFsJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1NZXRhZGF0YSddKS50b0JlVW5kZWZpbmVkKClcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uOiAnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQxJyxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cHM6Ly90dXMuaW8vdXBsb2FkcycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzLkN1c3RvbSkudG9CZSgnYmxhcmdoJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLUxlbmd0aCddKS50b0JlKDYpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtQ29uY2F0J10pLnRvQmUoJ3BhcnRpYWwnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLU1ldGFkYXRhJ10pLnRvQmVVbmRlZmluZWQoKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb246ICdodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDInLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcblxuICAgICAgLy8gQXNzZXJ0IHRoYXQgdGhlIFVSTHMgaGF2ZSBiZWVuIHN0b3JlZC5cbiAgICAgIGV4cGVjdCh0ZXN0VXJsU3RvcmFnZS5hZGRVcGxvYWQpLnRvSGF2ZUJlZW5DYWxsZWQoKVxuXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQxJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzLkN1c3RvbSkudG9CZSgnYmxhcmdoJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLU9mZnNldCddKS50b0JlKDApXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXSkudG9CZSgnYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbScpXG4gICAgICBleHBlY3QocmVxLmJvZHkuc2l6ZSkudG9CZSg1KVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiA1LFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDInKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnMuQ3VzdG9tKS50b0JlKCdibGFyZ2gnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtT2Zmc2V0J10pLnRvQmUoMClcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKS50b0JlKCdhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtJylcbiAgICAgIGV4cGVjdChyZXEuYm9keS5zaXplKS50b0JlKDYpXG5cbiAgICAgIC8vIFJldHVybiBhbiBlcnJvciB0byBlbnN1cmUgdGhhdCB0aGUgaW5kaXZpZHVhbCBwYXJ0aWFsIHVwbG9hZCBpcyBwcm9wZXJseSByZXRyaWVkLlxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMicpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnSEVBRCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAnVXBsb2FkLUxlbmd0aCc6IDExLFxuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMCxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQyJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzLkN1c3RvbSkudG9CZSgnYmxhcmdoJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLU9mZnNldCddKS50b0JlKDApXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXSkudG9CZSgnYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbScpXG4gICAgICBleHBlY3QocmVxLmJvZHkuc2l6ZSkudG9CZSg2KVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiA2LFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwczovL3R1cy5pby91cGxvYWRzJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQT1NUJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnMuQ3VzdG9tKS50b0JlKCdibGFyZ2gnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtTGVuZ3RoJ10pLnRvQmVVbmRlZmluZWQoKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLUNvbmNhdCddKS50b0JlKCdmaW5hbDtodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDEgaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQyJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1NZXRhZGF0YSddKS50b0JlKCdmb28gYUdWc2JHOD0nKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb246ICdodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDMnLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgYXdhaXQgb3B0aW9ucy5vblN1Y2Nlc3MudG9CZUNhbGxlZFxuXG4gICAgICBleHBlY3QodXBsb2FkLnVybCkudG9CZSgnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQzJylcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uUHJvZ3Jlc3MpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDUsIDExKVxuICAgICAgZXhwZWN0KG9wdGlvbnMub25Qcm9ncmVzcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMTEsIDExKVxuICAgICAgZXhwZWN0KHRlc3RVcmxTdG9yYWdlLnJlbW92ZVVwbG9hZCkudG9IYXZlQmVlbkNhbGxlZCgpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgc3BsaXQgYSBmaWxlIGludG8gbXVsdGlwbGUgcGFydHMgYmFzZWQgb24gY3VzdG9tIHNwbGl0U2l6ZUludG9QYXJ0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcblxuICAgICAgY29uc3QgdGVzdFVybFN0b3JhZ2UgPSB7XG4gICAgICAgIGFkZFVwbG9hZDogKGZpbmdlcnByaW50LCB1cGxvYWQpID0+IHtcbiAgICAgICAgICBleHBlY3QoZmluZ2VycHJpbnQpLnRvQmUoJ2ZpbmdlcnByaW50ZWQnKVxuICAgICAgICAgIGV4cGVjdCh1cGxvYWQudXBsb2FkVXJsKS50b0JlVW5kZWZpbmVkKClcbiAgICAgICAgICBleHBlY3QodXBsb2FkLnNpemUpLnRvQmUoMTEpXG4gICAgICAgICAgZXhwZWN0KHVwbG9hZC5wYXJhbGxlbFVwbG9hZFVybHMpLnRvRXF1YWwoW1xuICAgICAgICAgICAgJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMScsXG4gICAgICAgICAgICAnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQyJyxcbiAgICAgICAgICBdKVxuXG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgndHVzOjpmaW5nZXJwcmludGVkOjoxMzM3JylcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlVXBsb2FkOiAodXJsU3RvcmFnZUtleSkgPT4ge1xuICAgICAgICAgIGV4cGVjdCh1cmxTdG9yYWdlS2V5KS50b0JlKCd0dXM6OmZpbmdlcnByaW50ZWQ6OjEzMzcnKVxuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICB9LFxuICAgICAgfVxuICAgICAgc3B5T24odGVzdFVybFN0b3JhZ2UsICdyZW1vdmVVcGxvYWQnKS5hbmQuY2FsbFRocm91Z2goKVxuICAgICAgc3B5T24odGVzdFVybFN0b3JhZ2UsICdhZGRVcGxvYWQnKS5hbmQuY2FsbFRocm91Z2goKVxuXG4gICAgICBjb25zdCBmaWxlID0gZ2V0QmxvYignaGVsbG8gd29ybGQnKVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrICAgICAgICAgICAgICAgICAgOiB0ZXN0U3RhY2ssXG4gICAgICAgIHVybFN0b3JhZ2UgICAgICAgICAgICAgICAgIDogdGVzdFVybFN0b3JhZ2UsXG4gICAgICAgIHN0b3JlRmluZ2VycHJpbnRGb3JSZXN1bWluZzogdHJ1ZSxcbiAgICAgICAgcmVtb3ZlRmluZ2VycHJpbnRPblN1Y2Nlc3MgOiB0cnVlLFxuICAgICAgICBwYXJhbGxlbFVwbG9hZHMgICAgICAgICAgICA6IDIsXG4gICAgICAgIC8vIEV4cGVjdGVkIG91dHB1dDogW3sgc3RhcnQ6IDAsIGVuZDogMSB9LCB7IHN0YXJ0OiAxLCBlbmQ6IDExIH1dXG4gICAgICAgIHNwbGl0U2l6ZUludG9QYXJ0cyAgICAgICAgIDogKHRvdGFsU2l6ZSwgcGFydENvdW50KSA9PiB7XG4gICAgICAgICAgY29uc3QgcGFydFNpemUgPSAxXG4gICAgICAgICAgY29uc3QgcGFydHMgPSBbXVxuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0Q291bnQ7IGkrKykge1xuICAgICAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgICAgIHN0YXJ0OiBwYXJ0U2l6ZSAqIGksXG4gICAgICAgICAgICAgIGVuZCAgOiBwYXJ0U2l6ZSAqIChpICsgMSksXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcnRzW3BhcnRDb3VudCAtIDFdLmVuZCA9IHRvdGFsU2l6ZVxuXG4gICAgICAgICAgcmV0dXJuIHBhcnRzXG4gICAgICAgIH0sXG4gICAgICAgIHJldHJ5RGVsYXlzOiBbMTBdLFxuICAgICAgICBlbmRwb2ludCAgIDogJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMnLFxuICAgICAgICBoZWFkZXJzICAgIDoge1xuICAgICAgICAgIEN1c3RvbTogJ2JsYXJnaCcsXG4gICAgICAgIH0sXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgZm9vOiAnaGVsbG8nLFxuICAgICAgICB9LFxuICAgICAgICBvblByb2dyZXNzICgpIHt9LFxuICAgICAgICBvblN1Y2Nlc3MgIDogd2FpdGFibGVGdW5jdGlvbigpLFxuICAgICAgICBmaW5nZXJwcmludDogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCdmaW5nZXJwcmludGVkJyksXG4gICAgICB9XG4gICAgICBzcHlPbihvcHRpb25zLCAnb25Qcm9ncmVzcycpXG5cbiAgICAgIGNvbnN0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpXG4gICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICBsZXQgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwczovL3R1cy5pby91cGxvYWRzJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQT1NUJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnMuQ3VzdG9tKS50b0JlKCdibGFyZ2gnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtTGVuZ3RoJ10pLnRvQmUoMSlcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1Db25jYXQnXSkudG9CZSgncGFydGlhbCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtTWV0YWRhdGEnXSkudG9CZVVuZGVmaW5lZCgpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjAxLFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBMb2NhdGlvbjogJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMScsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVycy5DdXN0b20pLnRvQmUoJ2JsYXJnaCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1MZW5ndGgnXSkudG9CZSgxMClcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1Db25jYXQnXSkudG9CZSgncGFydGlhbCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtTWV0YWRhdGEnXSkudG9CZVVuZGVmaW5lZCgpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjAxLFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBMb2NhdGlvbjogJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMicsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuXG4gICAgICAvLyBBc3NlcnQgdGhhdCB0aGUgVVJMcyBoYXZlIGJlZW4gc3RvcmVkLlxuICAgICAgZXhwZWN0KHRlc3RVcmxTdG9yYWdlLmFkZFVwbG9hZCkudG9IYXZlQmVlbkNhbGxlZCgpXG5cbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDEnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnMuQ3VzdG9tKS50b0JlKCdibGFyZ2gnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtT2Zmc2V0J10pLnRvQmUoMClcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKS50b0JlKCdhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtJylcbiAgICAgIGV4cGVjdChyZXEuYm9keS5zaXplKS50b0JlKDEpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDEsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMicpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVycy5DdXN0b20pLnRvQmUoJ2JsYXJnaCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1PZmZzZXQnXSkudG9CZSgwKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snQ29udGVudC1UeXBlJ10pLnRvQmUoJ2FwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW0nKVxuICAgICAgZXhwZWN0KHJlcS5ib2R5LnNpemUpLnRvQmUoMTApXG5cbiAgICAgIC8vIFJldHVybiBhbiBlcnJvciB0byBlbnN1cmUgdGhhdCB0aGUgaW5kaXZpZHVhbCBwYXJ0aWFsIHVwbG9hZCBpcyBwcm9wZXJseSByZXRyaWVkLlxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMicpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnSEVBRCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAnVXBsb2FkLUxlbmd0aCc6IDExLFxuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMCxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQyJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzLkN1c3RvbSkudG9CZSgnYmxhcmdoJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLU9mZnNldCddKS50b0JlKDApXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXSkudG9CZSgnYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbScpXG4gICAgICBleHBlY3QocmVxLmJvZHkuc2l6ZSkudG9CZSgxMClcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMTAsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVycy5DdXN0b20pLnRvQmUoJ2JsYXJnaCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1MZW5ndGgnXSkudG9CZVVuZGVmaW5lZCgpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtQ29uY2F0J10pLnRvQmUoJ2ZpbmFsO2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMSBodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDInKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLU1ldGFkYXRhJ10pLnRvQmUoJ2ZvbyBhR1ZzYkc4PScpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjAxLFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBMb2NhdGlvbjogJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMycsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBhd2FpdCBvcHRpb25zLm9uU3VjY2Vzcy50b0JlQ2FsbGVkXG5cbiAgICAgIGV4cGVjdCh1cGxvYWQudXJsKS50b0JlKCdodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDMnKVxuICAgICAgZXhwZWN0KG9wdGlvbnMub25Qcm9ncmVzcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMSwgMTEpXG4gICAgICBleHBlY3Qob3B0aW9ucy5vblByb2dyZXNzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgxMSwgMTEpXG4gICAgICBleHBlY3QodGVzdFVybFN0b3JhZ2UucmVtb3ZlVXBsb2FkKS50b0hhdmVCZWVuQ2FsbGVkKClcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBlbWl0IGVycm9yIGZyb20gYSBwYXJ0aWFsIHVwbG9hZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcbiAgICAgIGNvbnN0IGZpbGUgPSBnZXRCbG9iKCdoZWxsbyB3b3JsZCcpXG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2sgICAgICA6IHRlc3RTdGFjayxcbiAgICAgICAgcGFyYWxsZWxVcGxvYWRzOiAyLFxuICAgICAgICByZXRyeURlbGF5cyAgICA6IG51bGwsXG4gICAgICAgIGVuZHBvaW50ICAgICAgIDogJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMnLFxuICAgICAgICBvbkVycm9yICAgICAgICA6IHdhaXRhYmxlRnVuY3Rpb24oJ29uRXJyb3InKSxcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucylcbiAgICAgIHVwbG9hZC5zdGFydCgpXG5cbiAgICAgIGNvbnN0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cHM6Ly90dXMuaW8vdXBsb2FkcycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1MZW5ndGgnXSkudG9CZSg1KVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDUwMCxcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IGVyciA9IGF3YWl0IG9wdGlvbnMub25FcnJvci50b0JlQ2FsbGVkXG4gICAgICBleHBlY3QoZXJyLm1lc3NhZ2UpLnRvQmUoJ3R1czogdW5leHBlY3RlZCByZXNwb25zZSB3aGlsZSBjcmVhdGluZyB1cGxvYWQsIG9yaWdpbmF0ZWQgZnJvbSByZXF1ZXN0IChtZXRob2Q6IFBPU1QsIHVybDogaHR0cHM6Ly90dXMuaW8vdXBsb2FkcywgcmVzcG9uc2UgY29kZTogNTAwLCByZXNwb25zZSB0ZXh0OiAsIHJlcXVlc3QgaWQ6IG4vYSknKVxuICAgICAgZXhwZWN0KGVyci5vcmlnaW5hbFJlcXVlc3QpLnRvQmUocmVxKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIHJlc3VtZSB0aGUgcGFydGlhbCB1cGxvYWRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuICAgICAgY29uc3QgZmlsZSA9IGdldEJsb2IoJ2hlbGxvIHdvcmxkJylcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjayAgICAgIDogdGVzdFN0YWNrLFxuICAgICAgICAvLyBUaGUgY2xpZW50IHNob3VsZCByZXN1bWUgdGhlIHBhcmFsbGVsIHVwbG9hZHMsIGV2ZW4gaWYgaXQgaXMgbm90XG4gICAgICAgIC8vIGNvbmZpZ3VyZWQgZm9yIG5ldyB1cGxvYWRzLlxuICAgICAgICBwYXJhbGxlbFVwbG9hZHM6IDEsXG4gICAgICAgIGVuZHBvaW50ICAgICAgIDogJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMnLFxuICAgICAgICBvblByb2dyZXNzICgpIHt9LFxuICAgICAgICBvblN1Y2Nlc3MgICAgICA6IHdhaXRhYmxlRnVuY3Rpb24oKSxcbiAgICAgIH1cbiAgICAgIHNweU9uKG9wdGlvbnMsICdvblByb2dyZXNzJylcblxuICAgICAgY29uc3QgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucylcblxuICAgICAgdXBsb2FkLnJlc3VtZUZyb21QcmV2aW91c1VwbG9hZCh7XG4gICAgICAgIHVybFN0b3JhZ2VLZXkgICAgIDogJ3R1czo6ZmluZ2VycHJpbnQ6OjEzMzcnLFxuICAgICAgICBwYXJhbGxlbFVwbG9hZFVybHM6IFtcbiAgICAgICAgICAnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQxJyxcbiAgICAgICAgICAnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQyJyxcbiAgICAgICAgXSxcbiAgICAgIH0pXG5cbiAgICAgIHVwbG9hZC5zdGFydCgpXG5cbiAgICAgIGxldCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMScpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnSEVBRCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAnVXBsb2FkLUxlbmd0aCc6IDUsXG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAyLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDInKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ0hFQUQnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgJ1VwbG9hZC1MZW5ndGgnOiA2LFxuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMCxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQxJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG4gICAgICBleHBlY3QocmVxLmJvZHkuc2l6ZSkudG9CZSgzKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiA1LFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDInKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcbiAgICAgIGV4cGVjdChyZXEuYm9keS5zaXplKS50b0JlKDYpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDYsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLUNvbmNhdCddKS50b0JlKCdmaW5hbDtodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDEgaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQyJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uOiAnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQzJyxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGF3YWl0IG9wdGlvbnMub25TdWNjZXNzLnRvQmVDYWxsZWRcblxuICAgICAgZXhwZWN0KHVwbG9hZC51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMycpXG4gICAgICBleHBlY3Qob3B0aW9ucy5vblByb2dyZXNzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg1LCAxMSlcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uUHJvZ3Jlc3MpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDExLCAxMSlcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBhYm9ydCBhbGwgcGFydGlhbCB1cGxvYWRzIGFuZCByZXN1bWUgZnJvbSB0aGVtJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuICAgICAgY29uc3QgZmlsZSA9IGdldEJsb2IoJ2hlbGxvIHdvcmxkJylcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjayAgICAgIDogdGVzdFN0YWNrLFxuICAgICAgICBwYXJhbGxlbFVwbG9hZHM6IDIsXG4gICAgICAgIGVuZHBvaW50ICAgICAgIDogJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMnLFxuICAgICAgICBvblByb2dyZXNzICgpIHt9LFxuICAgICAgICBvblN1Y2Nlc3MgICAgICA6IHdhaXRhYmxlRnVuY3Rpb24oKSxcbiAgICAgICAgZmluZ2VycHJpbnQgICAgOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoJ2ZpbmdlcnByaW50ZWQnKSxcbiAgICAgIH1cbiAgICAgIHNweU9uKG9wdGlvbnMsICdvblByb2dyZXNzJylcblxuICAgICAgY29uc3QgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucylcbiAgICAgIHVwbG9hZC5zdGFydCgpXG5cbiAgICAgIGxldCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtTGVuZ3RoJ10pLnRvQmUoNSlcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1Db25jYXQnXSkudG9CZSgncGFydGlhbCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtTWV0YWRhdGEnXSkudG9CZVVuZGVmaW5lZCgpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjAxLFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBMb2NhdGlvbjogJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMScsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtTGVuZ3RoJ10pLnRvQmUoNilcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1Db25jYXQnXSkudG9CZSgncGFydGlhbCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtTWV0YWRhdGEnXSkudG9CZVVuZGVmaW5lZCgpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjAxLFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBMb2NhdGlvbjogJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMicsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBjb25zdCByZXExID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXExLnVybCkudG9CZSgnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQxJylcbiAgICAgIGV4cGVjdChyZXExLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuICAgICAgZXhwZWN0KHJlcTEucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuICAgICAgZXhwZWN0KHJlcTEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1PZmZzZXQnXSkudG9CZSgwKVxuICAgICAgZXhwZWN0KHJlcTEucmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKS50b0JlKCdhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtJylcbiAgICAgIGV4cGVjdChyZXExLmJvZHkuc2l6ZSkudG9CZSg1KVxuXG4gICAgICBjb25zdCByZXEyID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEyLnVybCkudG9CZSgnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQyJylcbiAgICAgIGV4cGVjdChyZXEyLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuICAgICAgZXhwZWN0KHJlcTIucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuICAgICAgZXhwZWN0KHJlcTIucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1PZmZzZXQnXSkudG9CZSgwKVxuICAgICAgZXhwZWN0KHJlcTIucmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKS50b0JlKCdhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtJylcbiAgICAgIGV4cGVjdChyZXEyLmJvZHkuc2l6ZSkudG9CZSg2KVxuXG4gICAgICB1cGxvYWQuYWJvcnQoKVxuXG4gICAgICByZXExLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogNSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcTIucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiA2LFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgLy8gTm8gZnVydGhlciByZXF1ZXN0cyBzaG91bGQgYmUgc2VudC5cbiAgICAgIGNvbnN0IHJlcVByb21pc2UgPSB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgcmVxUHJvbWlzZSxcbiAgICAgICAgd2FpdCgxMDApLFxuICAgICAgXSlcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoJ3RpbWVkIG91dCcpXG5cbiAgICAgIC8vIFJlc3RhcnQgdGhlIHVwbG9hZFxuICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgLy8gUmV1c2UgdGhlIHByb21pc2UgZnJvbSBiZWZvcmUgYXMgaXQgaXMgbm90IGNhbmNlbGxlZC5cbiAgICAgIHJlcSA9IGF3YWl0IHJlcVByb21pc2VcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDEnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ0hFQUQnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgJ1VwbG9hZC1MZW5ndGgnOiA1LFxuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogNSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQyJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdIRUFEJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICdVcGxvYWQtTGVuZ3RoJzogNixcbiAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDYsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtTGVuZ3RoJ10pLnRvQmVVbmRlZmluZWQoKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLUNvbmNhdCddKS50b0JlKCdmaW5hbDtodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDEgaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQyJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uOiAnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQzJyxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGF3YWl0IG9wdGlvbnMub25TdWNjZXNzLnRvQmVDYWxsZWRcblxuICAgICAgZXhwZWN0KHVwbG9hZC51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMycpXG4gICAgICBleHBlY3Qob3B0aW9ucy5vblByb2dyZXNzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg1LCAxMSlcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uUHJvZ3Jlc3MpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDExLCAxMSlcbiAgICB9KVxuICB9KVxufSlcbiIsImNvbnN0IHsgVGVzdEh0dHBTdGFjaywgZ2V0QmxvYiB9ID0gcmVxdWlyZSgnLi9oZWxwZXJzL3V0aWxzJylcbmNvbnN0IHR1cyA9IHJlcXVpcmUoJy4uLy4uJylcblxuZGVzY3JpYmUoJ3R1cycsICgpID0+IHtcbiAgZGVzY3JpYmUoJ3Rlcm1pbmF0ZSB1cGxvYWQnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCB0ZXJtaW5hdGUgdXBsb2FkIHdoZW4gYWJvcnQgaXMgY2FsbGVkIHdpdGggdHJ1ZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCBhYm9ydFByb21pc2VcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcbiAgICAgIGNvbnN0IGZpbGUgPSBnZXRCbG9iKCdoZWxsbyB3b3JsZCcpXG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQgOiAnaHR0cDovL3R1cy5pby9maWxlcy8nLFxuICAgICAgICBjaHVua1NpemU6IDUsXG4gICAgICAgIG9uQ2h1bmtDb21wbGV0ZSAoKSB7XG4gICAgICAgICAgYWJvcnRQcm9taXNlID0gdXBsb2FkLmFib3J0KHRydWUpXG4gICAgICAgIH0sXG4gICAgICB9XG5cbiAgICAgIHNweU9uKG9wdGlvbnMsICdvbkNodW5rQ29tcGxldGUnKS5hbmQuY2FsbFRocm91Z2goKVxuXG4gICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKVxuICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgbGV0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy8nKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb246ICcvZmlsZXMvZm9vJyxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy9mb28nKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogNSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy9mb28nKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ0RFTEVURScpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogMjA0LFxuICAgICAgfSlcblxuICAgICAgZXhwZWN0KG9wdGlvbnMub25DaHVua0NvbXBsZXRlKS50b0hhdmVCZWVuQ2FsbGVkKClcbiAgICAgIGF3YWl0IGFib3J0UHJvbWlzZVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIHJldHJ5IHRlcm1pbmF0ZSB3aGVuIGFuIGVycm9yIGlzIHJldHVybmVkIG9uIGZpcnN0IHRyeScsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCBhYm9ydFByb21pc2VcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcbiAgICAgIGNvbnN0IGZpbGUgPSBnZXRCbG9iKCdoZWxsbyB3b3JsZCcpXG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2sgIDogdGVzdFN0YWNrLFxuICAgICAgICBlbmRwb2ludCAgIDogJ2h0dHA6Ly90dXMuaW8vZmlsZXMvJyxcbiAgICAgICAgY2h1bmtTaXplICA6IDUsXG4gICAgICAgIHJldHJ5RGVsYXlzOiBbMTAsIDEwLCAxMF0sXG4gICAgICAgIG9uQ2h1bmtDb21wbGV0ZSAoKSB7XG4gICAgICAgICAgYWJvcnRQcm9taXNlID0gdXBsb2FkLmFib3J0KHRydWUpXG4gICAgICAgIH0sXG4gICAgICB9XG5cbiAgICAgIHNweU9uKG9wdGlvbnMsICdvbkNodW5rQ29tcGxldGUnKS5hbmQuY2FsbFRocm91Z2goKVxuXG4gICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKVxuICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgbGV0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy8nKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb246ICcvZmlsZXMvZm9vJyxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy9mb28nKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogNSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy9mb28nKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ0RFTEVURScpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogNDIzLFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL2ZvbycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnREVMRVRFJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICB9KVxuXG4gICAgICBhd2FpdCBhYm9ydFByb21pc2VcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uQ2h1bmtDb21wbGV0ZSkudG9IYXZlQmVlbkNhbGxlZCgpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgc3RvcCByZXRyeWluZyB3aGVuIGFsbCBkZWxheXMgYXJlIHVzZWQgdXAnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2sgIDogdGVzdFN0YWNrLFxuICAgICAgICByZXRyeURlbGF5czogWzEwLCAxMF0sXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRlcm1pbmF0ZVByb21pc2UgPSB0dXMuVXBsb2FkLnRlcm1pbmF0ZSgnaHR0cDovL3R1cy5pby9maWxlcy9mb28nLCBvcHRpb25zKVxuXG4gICAgICBsZXQgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL2ZvbycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnREVMRVRFJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvZm9vJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdERUxFVEUnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDUwMCxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy9mb28nKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ0RFTEVURScpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgfSlcblxuICAgICAgYXdhaXQgZXhwZWN0QXN5bmModGVybWluYXRlUHJvbWlzZSkudG9CZVJlamVjdGVkV2l0aEVycm9yKC90dXM6IHVuZXhwZWN0ZWQgcmVzcG9uc2Ugd2hpbGUgdGVybWluYXRpbmcgdXBsb2FkLylcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBpbnZva2UgdGhlIHJlcXVlc3QgYW5kIHJlc3BvbnNlIFByb21pc2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIG9uQmVmb3JlUmVxdWVzdCAocmVxKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgZXhwZWN0KHJlcS5nZXRVUkwoKSkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzL2ZvbycpXG4gICAgICAgICAgICBleHBlY3QocmVxLmdldE1ldGhvZCgpKS50b0JlKCdERUxFVEUnKVxuICAgICAgICAgICAgcmVzb2x2ZSgpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgb25BZnRlclJlc3BvbnNlIChyZXEsIHJlcykge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIGV4cGVjdChyZXEuZ2V0VVJMKCkpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9mb28nKVxuICAgICAgICAgICAgZXhwZWN0KHJlcS5nZXRNZXRob2QoKSkudG9CZSgnREVMRVRFJylcbiAgICAgICAgICAgIGV4cGVjdChyZXMuZ2V0U3RhdHVzKCkpLnRvQmUoMjA0KVxuICAgICAgICAgICAgcmVzb2x2ZSgpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICAgIHNweU9uKG9wdGlvbnMsICdvbkJlZm9yZVJlcXVlc3QnKVxuICAgICAgc3B5T24ob3B0aW9ucywgJ29uQWZ0ZXJSZXNwb25zZScpXG5cbiAgICAgIGNvbnN0IHRlcm1pbmF0ZVByb21pc2UgPSB0dXMuVXBsb2FkLnRlcm1pbmF0ZSgnaHR0cDovL3R1cy5pby91cGxvYWRzL2ZvbycsIG9wdGlvbnMpXG5cbiAgICAgIGNvbnN0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzL2ZvbycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnREVMRVRFJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICB9KVxuXG4gICAgICBhd2FpdCBleHBlY3RBc3luYyh0ZXJtaW5hdGVQcm9taXNlKS50b0JlUmVzb2x2ZWQoKVxuICAgICAgZXhwZWN0KG9wdGlvbnMub25CZWZvcmVSZXF1ZXN0KS50b0hhdmVCZWVuQ2FsbGVkKClcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uQWZ0ZXJSZXNwb25zZSkudG9IYXZlQmVlbkNhbGxlZCgpXG4gICAgfSlcbiAgfSlcbn0pXG4iXX0=
