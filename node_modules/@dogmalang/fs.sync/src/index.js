"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.entry = entry;
exports.file = file;
exports.dir = dir;
exports.exists = exists;
exports.isFile = isFile;
exports.isDir = isDir;
exports.rm = rm;
exports.mv = mv;
exports.mkdir = mkdir;
exports.read = read;
exports.write = write;
exports.move = exports.tmp = void 0;

var _core = require("@dogmalang/core");

const path = _core.dogma.use(require("@dogmalang/path"));

const fs = _core.dogma.use(require("fs"));

const fsx = _core.dogma.use(require("fs-extra"));

class EntryType {
  constructor(name, val) {
    Object.defineProperty(this, "name", {
      value: name,
      enum: true
    });
    Object.defineProperty(this, "value", {
      value: val,
      enum: true
    });
  }
  /* istanbul ignore next */


  toString() {
    return this.name;
  }

}

Object.defineProperty(EntryType, "FILE", {
  value: new EntryType("FILE", 1),
  enum: true
});
Object.defineProperty(EntryType, "DIR", {
  value: new EntryType("DIR", 2),
  enum: true
});

const tmp = _core.dogma.use(require("os")).tmpdir();

exports.tmp = tmp;

function getEntryType(path) {
  let e;
  /* istanbul ignore next */

  _core.dogma.paramExpected("path", path, null);

  {
    const stat = fs.statSync(path);
    /*istanbul ignore else*/

    if (stat.isFile()) {
      e = EntryType.FILE;
    } else if (stat.isDirectory()) {
      e = EntryType.DIR;
    } else {
      _core.dogma.raise("invalid entry type for: %s.", path);
    }
  }
  return e;
}

function entry(...args) {
  let e;
  {
    const ep = path.join(...args);
    {
      const _ = getEntryType(ep);

      switch (_) {
        case EntryType.FILE:
          {
            e = file(ep);
          }
          ;
          /* istanbul ignore next */

          break;

        case EntryType.DIR:
          {
            e = dir(ep);
          }
          ;
          /* istanbul ignore next */

          break;
      }
    }
  }
  return e;
}

function file(...args) {
  {
    return _core.dogma.use(require("./File"))(path.join(...args));
  }
}

function dir(...args) {
  {
    return _core.dogma.use(require("./Dir"))(path.join(...args));
  }
}

function exists(...args) {
  {
    return _core.dogma.getItem(_core.dogma.peval(() => {
      return fs.statSync(path.join(...args));
    }), 0);
  }
}

function isFile(...args) {
  try {
    return fs.statSync(path.join(...args)).isFile();
  } catch (e) {
    /*istanbul ignore else*/
    if (_core.dogma.like(e, "ENOENT")) {
      return false;
    } else {
      _core.dogma.raise(e);
    }
  }
}

function isDir(...args) {
  try {
    return fs.statSync(path.join(...args)).isDirectory();
  } catch (e) {
    /*istanbul ignore else*/
    if (_core.dogma.like(e, "ENOENT")) {
      return false;
    } else {
      _core.dogma.raise(e);
    }
  }
}

function rm(...args) {
  {
    fsx.removeSync(path.join(...args));
  }
}

function mv(src, dst, opts) {
  /* istanbul ignore next */
  _core.dogma.paramExpected("src", src, _core.text);
  /* istanbul ignore next */


  _core.dogma.paramExpected("dst", dst, _core.text);
  /* istanbul ignore next */


  _core.dogma.paramExpectedToBe("opts", opts, _core.map);

  {
    fsx.moveSync(src, dst, opts || {
      ["overwrite"]: true
    });
  }
}

const move = mv;
exports.move = move;

function mkdir(...args) {
  let folder = "";
  {
    let opts;
    {
      const _ = (0, _core.len)(args);

      switch (_) {
        case 0:
          {
            _core.dogma.raise("dir path expected.");
          }
          ;
          /* istanbul ignore next */

          break;

        case 1:
          {
            folder = _core.dogma.getItem(args, 0);
          }
          ;
          /* istanbul ignore next */

          break;

        default:
          {
            if (_core.dogma.is(_core.dogma.getItem(args, -1), _core.map)) {
              _core.dogma.pevalAnd(() => {
                folder = _core.dogma.getSlice(args, 0, -2);
              }, () => {
                return opts = _core.dogma.getItem(args, -1);
              });
            } else {
              folder = args;
            }
          }
      }
    }
    opts = (0, _core.coalesce)(opts, {
      ["fromFilePath"]: false
    });

    if (_core.dogma.isNot(_core.dogma.paramExpected('folder', folder, [_core.text, _core.list]), _core.list)) {
      folder = [folder];
    }

    folder = path.join(...folder);

    if (opts.fromFilePath) {
      folder = path.dir(folder);
    }

    dir(folder).ensure();
  }
  return folder;
}

function read(...args) {
  {
    return entry(...args).read();
  }
}

function write(...args) {
  {
    let c;
    let opts;
    let path;
    {
      const size = (0, _core.len)(args);

      if (size == 0) {
        _core.dogma.raise("invalid fs.write() call. At least, two arguments expected. Received: 0.");
      } else if (size == 1) {
        _core.dogma.raise("invalid fs.write() call. At least, two arguments expected. Received: 1.");
      } else if (size == 2) {
        [c, path] = _core.dogma.getArrayToUnpack(args, 2);
      } else {
        [c, opts, path] = _core.dogma.getArrayToUnpack(args, 3);
      }
    }
    file(path).write(c, opts);
  }
}