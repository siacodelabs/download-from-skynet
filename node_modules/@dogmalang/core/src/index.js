"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.promisify = promisify;
exports.sleep = sleep;
exports.bind = bind;
exports.remove = remove;
exports.coalesce = coalesce;
exports.expect = expect;
exports.fmt = fmt;
exports.todo = todo;
exports.typename = typename;
exports.any = any;
exports.date = date;
exports.timestamp = timestamp;
exports.text = text;
exports.list = list;
exports.set = set;
exports.func = func;
exports.promise = promise;
exports.proxy = proxy;
exports.print = print;
exports.printf = printf;
exports.echo = echo;
exports.echof = echof;
exports.abstract = abstract;
exports.len = len;
exports.keys = keys;
exports.values = values;
exports.dogma = exports.map = exports.num = exports.re = exports.datetime = exports.bool = exports.json = exports.ps = void 0;

var _events = _interopRequireDefault(require("events"));

var _util = _interopRequireDefault(require("util"));

var _lodash = _interopRequireDefault(require("lodash.merge"));

var _lodash2 = _interopRequireDefault(require("lodash.clonedeep"));

var _deepEqual = _interopRequireDefault(require("deep-equal"));

var _time = require("@dogmalang/time.converter");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//imports

/**
 * An overload() parameter.
 */
class OverloadParam {
  /**
   * Default constructor.
   *
   * @param data:Object The data object.
   */
  constructor(data) {
    this.kind = data.kind;
    this.type = data.type;
  }

  isDiscard() {
    return this.kind == "...";
  }

  isMandatory() {
    return this.kind == "m";
  }

  isOptional() {
    return this.kind == "o";
  }
  /**
   * Check if the value complies the parameter definition.
   *
   * @param value The value to check.
   * @returns bool.
   */


  check(value) {
    //(1) check
    let complied;

    if (value == null) {
      if (this.isMandatory()) {
        complied = false;
      } else {
        complied = true;
      }
    } else {
      if (this.isDiscard()) {
        complied = true;
      } else {
        complied = dogma.is(value, this.type);
      }
    } //(2) return


    return complied;
  }

}
/**
 * A typedef.
 */


class TypeDef {
  /**
   * Default constructor.
   *
   * @param data:Object The data object.
   */
  constructor(data) {
    this.name = data.name;
    this.types = data.types;
    this.min = data.min;
    this.max = data.max;
  }
  /**
   * Check whether it is a list.
   */


  isList() {
    return this.min != null;
  }
  /**
   * Check whether and object complies the typedef.
   *
   * @param obj The object to check.
   * @returns true or false
   */


  comply(obj) {
    if (this.isList()) {
      return this._complyList(obj);
    } else {
      return dogma.is(obj, this.types);
    }
  }

  _complyList(arr) {
    let complied; //(1) is object a list?

    complied = dogma.is(arr, list); //(2) check items

    if (complied) {
      if (complied = arr.length >= this.min) {
        if (this.max != null) {
          complied = arr.length <= this.max;
        }
      }

      if (complied) {
        for (const item of arr) {
          if (!(complied = dogma.is(item, this.types))) {
            break;
          }
        }
      }
    } //(3) return


    return complied;
  }

}
/**
 * The process object.
 */


const ps = {
  get browser() {
    return !!process.browser;
  }

};
exports.ps = ps;

if (ps.browser) {
  Object.defineProperty(ps, "env", {
    value: {},
    writable: false,
    enumerable: true
  });
} else {
  Object.defineProperty(ps, "env", {
    get() {
      return process.env;
    },

    enumerable: true
  });
  Object.defineProperty(ps, "argv", {
    get() {
      return process.argv;
    },

    enumerable: true
  });
  Object.defineProperty(ps, "workDir", {
    get() {
      return process.cwd();
    },

    enumerable: true
  });
  Object.defineProperty(ps, "pid", {
    get() {
      return process.pid;
    },

    enumerable: true
  });
  Object.defineProperty(ps, "exit", {
    get() {
      return process.exit;
    },

    enumerable: true
  });
  Object.defineProperty(ps, "cd", {
    get() {
      return process.chdir;
    },

    enumerable: true
  });
  Object.defineProperty(ps, "on", {
    get() {
      return process.on.bind(process);
    },

    emnumerable: true
  });
  Object.defineProperty(ps, "once", {
    get() {
      return process.once.bind(process);
    },

    enumerable: true
  });
}
/**
 * promisify().
 */


function promisify(...args) {
  return _util.default.promisify(...args);
}
/**
 * sleep()
 */


function sleep(time) {
  return new Promise(function (rslv) {
    setTimeout(rslv, (0, _time.ms)(time));
  });
}
/**
 * bind().
 */


function bind(obj, meth) {
  if (typeof meth == "string") {
    return obj[meth].bind(obj);
  } else {
    return meth.bind(obj);
  }
}
/**
 * Decode a string in JSON format.
 * 
 * @param serialized  Text in JSON format.
 * @param Type        Type to convert.
 */


function decodeJson(serialized, Type) {
  //(1) decode JSON
  let object;

  if (arguments.length != 2) {
    object = JSON.parse(serialized);
  } else {
    if (Type && Type.fromJSON instanceof Function) {
      object = Type.fromJSON(serialized);
    } else {
      object = JSON.parse(serialized);

      if (Type) {
        dogma.setTypeToObject(object, Type);
      }
    }
  } //(2) return object


  return object;
}
/**
 * The json object.
 */


const json = {
  encode: JSON.stringify,
  decode: decodeJson
};
/**
 * The remove() function.
 */

exports.json = json;

function remove(...args) {
  var keys, obj; //(1) arguments

  keys = args.slice(0, args.length - 1);
  obj = args[args.length - 1]; //(2) remove

  if (obj != null) {
    if (obj instanceof Array) {
      for (var i = 1; i >= 0;) {
        i = obj.findIndex(ele => keys.includes(ele));
        if (i >= 0) obj.splice(i, 1);
      }
    } else if (obj instanceof Set) {
      for (let key of keys) obj.delete(key);
    } else {
      for (let key of keys) delete obj[key];
    }
  } //(3) return


  return obj;
}
/**
 * coalesce() function.
 */


function coalesce(...args) {
  return dogma.coalesce(...args);
}
/**
 * expect() function.
 */


function expect(name, value, type) {
  return dogma.expect(name, value, type);
}
/**
 * fmt() function.
 */


function fmt(...args) {
  if (args.length == 1) return _util.default.inspect(args[0], {
    depth: null
  });else return _util.default.format(...args);
}
/**
 * todo() function.
 */


function todo() {
  throw new TypeError("TODO");
}
/**
 * type() function.
 */


function typename(val) {
  //(1) built-in types
  switch (typeof val) {
    case "boolean":
      return "bool";

    case "function":
      return "fn";

    case "number":
      return "num";

    case "string":
      return "text";

    case "undefined":
      return "nil";
  }

  if (val === null) return "nil";
  if (val instanceof Array) return "list";
  if (val instanceof Set) return "set";
  if (val instanceof Promise) return "promise";
  if (val instanceof Date) return "timestamp";
  if (val instanceof RegExp) return "re"; //(2) user types

  var tn = val.constructor.name;
  if (tn == "Object") tn = "map";
  return tn;
}
/**
 * any type.
 */


function any() {}
/**
 * bool type.
 */


const bool = Boolean;
/**
 * current date without time.
 */

exports.bool = bool;

function date() {
  const now = new Date();
  return new Date(now.toLocaleDateString());
}
/**
 * timestamp type.
 */


function timestamp(val) {
  if (val) return new Date(val);else return new Date();
}

const datetime = timestamp;
/**
 * re.
 */

exports.datetime = datetime;
const re = RegExp;
/**
 * text type.
 */

exports.re = re;

function text(...args) {
  var res = "";

  for (let arg of args) res += String(arg);

  return res;
}
/**
 * num type.
 */


const num = Number;
/**
 * list type.
 */

exports.num = num;

function list(...args) {
  var res;

  if (args.length == 0) {
    res = [];
  } else if (args.length == 1) {
    if (args[0] instanceof Array || args[0] instanceof Set) res = Array.from(args[0]);else res = [args[0]];
  } else {
    res = [];

    for (let item of args) res.push(item);
  }

  return res;
}
/**
 * set type.
 */


function set(...args) {
  var res;

  if (args.length == 0) {
    res = new Set();
  } else if (args.length == 1) {
    if (args[0] instanceof Array || args[0] instanceof Set) res = new Set(args[0]);else res = new Set(args);
  } else {
    res = new Set(args);
  }

  return res;
}
/**
 * map type.
 */


const map = Object;
/**
 * func type.
 */

exports.map = map;

function func(...args) {
  return new Function(...args);
}
/**
 * Return the parameters of a function.
 */


func.getParamsOf = function (fn) {
  var params = []; //(1) extract

  fn = fn.toString();

  if (/^[a-zA-Z$_0-9]+ *=>/.test(fn)) {
    params = /^([^(=>)]+) *=>/.exec(fn)[1].replace(/ /g, "").split(",");
  } else if (/^async +[a-zA-Z$_0-9]+ *=>/.test(fn)) {
    params = /^async +([^(=>)]+) *=>/.exec(fn)[1].replace(/ /g, "").split(",");
  } else if (/^\(.*\) *=>/.test(fn)) {
    params = /^\(([^(=>)]*)\) *=>/.exec(fn)[1].replace(/ /g, "").split(",");
  } else if (/^async *\(.*\) *=>/.test(fn)) {
    params = /^async *\(([^(=>)]*)\) *=>/.exec(fn)[1].replace(/ /g, "").split(",");
  } else if (/^function[^(]*\(.*\)/.test(fn)) {
    params = /^function[^(]*\(([^()]*)\) *{/.exec(fn)[1].replace(/ /g, "").split(",");
  } else if (/^async +function[^(]*\(.*\)/.test(fn)) {
    params = /^async +function[^(]*\(([^()]*)\) *{/.exec(fn)[1].replace(/ /g, "").split(",");
  }

  if (params.length == 1 && params[0] == "") params = []; //(2) return

  return params;
};
/**
 * Check whether a function has a parameter name.
 */


func.exists = function (param, fn) {
  return func.getParamsOf(fn).includes(param);
};
/**
 * Return the argument list for a call.
 */


func.buildArgs = function (args, fn) {
  var rslt = [];

  for (let param of func.getParamsOf(fn)) rslt.push(args[param]);

  return rslt;
};
/**
 * promise type.
 */


function promise(...args) {
  return new Promise(...args);
}

promise.resolve = function (...args) {
  return Promise.resolve(...args);
};

promise.reject = function (...args) {
  return Promise.reject(...args);
};

promise.all = function (...args) {
  return (Promise.allSettled || Promise.all)(...args);
};
/**
 * proxy type.
 */


function proxy(...args) {
  return new Proxy(...args);
}
/**
 * print() function.
 */


function print(...args) {
  console.log(...args);
}
/**
 * printf() function.
 */


function printf(...args) {
  if (args.length == 1) {
    console.log(_util.default.inspect(args[0], {
      depth: null
    }));
  } else {
    console.log(_util.default.format(...args));
  }
}
/**
 * echo() function.
 */


function echo(...args) {
  var txt = "";

  for (let i = 0; i < args.length; i += 1) {
    if (i == 0) txt += _util.default.format(args[i]);else txt += " " + _util.default.format(args[i]);
  }

  process.stdout.write(txt);
}
/**
 * echof() function.
 */


function echof(...args) {
  process.stdout.write(_util.default.format(...args));
}
/**
 * abstract() function.
 */


function abstract() {
  throw new TypeError("abstract method.");
}
/**
 * len() function.
 */


function len(obj) {
  var l; //(1) get length

  if (obj == null) {
    l = 0;
  } else if (obj instanceof Set) {
    l = obj.size;
  } else if (typeof obj == "string" || "length" in obj) {
    l = obj.length;
  } else if ("len" in obj && typeof obj.len == "number" && obj.constructor.name != "Object") {
    l = obj.len;
  } else if (obj instanceof Object) {
    l = Object.entries(obj).length;
  } //(2) return


  return l;
}
/**
 * keys() function.
 */


function keys(obj) {
  return Object.keys(obj);
}
/**
 * values() function.
 */


function values(obj) {
  var res;

  if (obj instanceof Set) {
    res = Array.from(obj);
  } else {
    res = Object.values(obj);
  }

  return res;
}
/**
 * dogma object.
 */


const dogma = {
  TypeDef(...args) {
    return new TypeDef(...args);
  },

  /**
   * OverloadParam class.
   */
  OverloadParam(...args) {
    return new OverloadParam(...args);
  },

  /**
   * Set the type to an object.
   * 
   * @param obj   Object to set its type.
   * @param Type  The type to set.
   * 
   * @returns the object.
   * @throws a TypeError when obj is not Object.
   */
  setTypeToObject(obj, Type) {
    //(1) set the type
    if (obj.__proto__ !== Object.prototype) {
      throw new TypeError("object must be Object or map.");
    }

    obj.__proto__ = Type.prototype; //(2) return

    return obj;
  },

  /**
   * Generate a copy of an object.
   */
  copy(obj) {
    return (0, _lodash2.default)(obj);
  },

  /**
   * overload().
   *
   * @returns bool
   */
  overload(values, params) {
    //(1) check
    let ok;

    if (values.length == 0) {
      ok = true;

      for (let i = 0; i < params.length; i += 1) {
        const param = params[i];

        if (param.isMandatory()) {
          ok = false;
          break;
        }
      }
    } else if (values.length <= params.length) {
      ok = true;

      for (let i = 0; i < values.length; i += 1) {
        const value = values[i];
        const param = params[i];

        if (param.isDiscard()) {
          break;
        } else {
          if (!(ok = param.check(value))) {
            break;
          }
        }
      }

      if (ok) {
        for (let i = values.length; i < params.length; i += 1) {
          const param = params[i];

          if (param.isMandatory()) {
            ok = false;
            break;
          }
        }
      }
    } else {
      //values.length > params.length
      ok = false;

      for (let i = 0; i < values.length; i += 1) {
        const value = values[i];
        const param = params[i];

        if (!param) {
          ok = false;
          break;
        } else if (param.isDiscard()) {
          ok = true;
          break;
        } else {
          if (!(ok = param.check(value))) {
            break;
          }
        }
      }
    } //(2) return


    return ok;
  },

  /**
   * coalesce() function.
   */
  coalesce(...args) {
    var res;

    for (let arg of args) {
      if (arg !== null && arg !== undefined) {
        res = arg;
        break;
      }
    }

    return res;
  },

  /**
   * Alias for catch().
   */
  catchError(fn) {
    try {
      return fn();
    } catch (e) {
      return null;
    }
  },

  /**
   * Alias for set().
   */
  set(...args) {
    return set(...args);
  },

  /**
   * Implementation of the emit() function.
   *
   * @param obj   Object that raises the event.
   * @param name  Event name.
   * @param e     Event instance.
   */
  emit(obj, name, e) {
    //(1) get the event definition
    var def;

    for (let proto = obj.__proto__; proto; proto = proto.__proto__) {
      const events = proto.constructor.__events__;

      if (events) {
        if (def = events[name]) break;
      }
    } //(2) check event


    if (!def) {
      throw new Error(`'${name}' event can't be emitted by ${typename(obj)}.`);
    }

    if (def.type && !dogma.is(e, def.type)) {
      throw new Error(`'${name}' event doesn't comply with the event type.`);
    } //(3) emit


    obj._emitter.emit(name, e);
  },

  /**
   * Implementation of the const() function.
   *
   * @param obj Object to set as immutable.
   */
  immutable(obj) {
    return new Proxy(obj, {
      set() {
        throw new Error("Const object, this can't be updated.");
      },

      deleteProperty() {
        throw new Error("Const object, its fields/properties can't be deleted.");
      },

      defineProperty() {
        throw new Error("Const object, this can't define new fields/properties.");
      }

    });
  },

  /**
   * Create a new interface object.
   *
   * @param name:string   Interface name.
   * @param fields:object The interface fields.
   * @param base:object   The base interface.
   */
  intf(name, fields, base) {
    //(1) add base members
    if (base) {
      if (!(base instanceof Intf)) throw TypeError("base expected to be Intf.");
      fields = Object.assign({}, base.fields, fields);
    } //(2) return intf


    return new Intf(name, fields);
  },

  /**
   * Event emitter.
   */
  EventEmitter: class {
    constructor() {
      Object.defineProperty(this, "_emitter", {
        value: new _events.default(),
        writable: false,
        enumerable: false
      });
    }

    on(event, hdlr) {
      this._emitter.on(event, hdlr);

      return this;
    }

    off(event, hdlr) {
      this._emitter.removeListener(event, hdlr);

      return this;
    }

    emit(event, data) {
      this._emitter.emit(event, data);
    }

  },

  /**
   * autobind.
   */
  autobind(self, type) {
    if (type.__bind__ instanceof Array) {
      for (let i of type.__bind__) {
        let [name, meth] = i;
        self[name] = meth.bind(self);
      }
    }
  },

  /**
   * pawait()
   */
  async pawait(fn) {
    try {
      const rslt = await fn();
      return [true, rslt];
    } catch (e) {
      return [false, e];
    }
  },

  /**
   * async with {delay, repeat}
   */
  repeatAsyncly(fn, opts) {
    const repeat = opts.repeat,
          delay = (0, _time.ms)(opts.delay);

    if (repeat === false) {
      dogma.asyncly(fn, delay);
    } else if (repeat === true) {
      toInfinity(fn, delay);
    } else if (typeof repeat == "number") {
      times(fn, repeat, delay);
    } else {
      throw "invalid repeat value. Expected: bool or num. Received: " + repeat + ".";
    }

    function toInfinity(fn, delay) {
      setInterval(function () {
        try {
          fn();
        } catch (e) {//nop
        }
      }, delay);
    }

    function times(fn, repeat, delay) {
      var cnt = 0;
      const interval = setInterval(function () {
        if (cnt < repeat) {
          cnt += 1;

          try {
            fn();
          } catch (e) {//nop
          }
        } else {
          clearInterval(interval);
        }
      }, delay);
    }
  },

  /**
   * async with {delay}.
   */
  asyncly(fn, delay) {
    //(1) get seconds to delay
    const PAT = /^([0-9]+) *(ms|s|m|h)?$/;

    if (typeof delay == "string" && PAT.test(delay)) {
      delay = PAT.exec(delay);

      switch (delay[2]) {
        case "s":
          delay = delay[1] * 1000;
          break;

        case "m":
          delay = delay[1] * 1000 * 60;
          break;

        case "h":
          delay = delay[1] * 1000 * 60 * 60;
          break;

        default:
          delay = delay[1] * 1;
      }
    } //(2) run asyncly


    setTimeout(fn, delay);
  },

  /**
   * mixin().
   */
  mixin(a, b) {
    const mems = {}; //(1) get object to insert

    b = b.prototype || b; //(2) get members to insert

    for (let name of Object.getOwnPropertyNames(b)) {
      const desc = Object.getOwnPropertyDescriptor(b, name);

      if (!["constructor", "_constructor"].includes(name)) {
        if (desc.get instanceof Function || desc.value instanceof Function) {
          Object.defineProperty(a.prototype, name, desc);
        }
      }
    } //(3) insert


    Object.assign(a.prototype, mems);
  },

  /**
   * super.method op.
   */
  super(instance, method) {
    var res; //(1) get base method

    for (let base = instance.__proto__.__proto__; base !== undefined; base = base.__proto__) {
      if (res = base[method]) break;
    } //(2) return


    if (res) return res.bind(instance);else return null;
  },

  /**
   * exp ==^ exp
   */
  deepEq(val1, val2) {
    return (0, _deepEqual.default)(val1, val2);
  },

  /**
   * exp ==~ value
   */
  enumEq(val, fld) {
    var res = false;
    if (val !== null && val !== undefined) res = val == val.constructor[fld];
    return res;
  },

  /**
   * Return an enum item from other item.
   */
  enumGet(val, item) {
    return val.constructor[item];
  },

  /**
   * is operator.
   */
  is(obj, clss) {
    if (clss instanceof TypeDef) {
      return clss.comply(obj);
    } else if (clss instanceof Intf) {
      return clss.comply(obj);
    } else if (clss instanceof Array) {
      let is = false;

      for (let c of clss) {
        if (is = dogma.is(obj, c)) break;
      }

      return is;
    } else if (clss === null || clss === undefined) {
      return obj === null || clss === undefined;
    } else if (clss === any) {
      return obj !== null && obj !== undefined;
    } else if (clss === bool || clss === Boolean) {
      return typeof obj == "boolean";
    } else if (clss === timestamp || clss === Date) {
      return obj instanceof Date;
    } else if (clss === text || clss === String) {
      return typeof obj == "string";
    } else if (clss === num || clss === Number) {
      return typeof obj == "number";
    } else if (clss === re || clss === RegExp) {
      return obj instanceof RegExp;
    } else if (clss === list || clss === Array) {
      return obj instanceof Array;
    } else if (clss === set || clss === Set) {
      return obj instanceof Set;
    } else if (clss === map || clss === Object) {
      return obj !== null && !(obj instanceof Array) && obj instanceof Object;
    } else if (clss === func || clss === Function) {
      return obj instanceof Function;
    } else if (clss === promise || clss === Promise) {
      return obj instanceof Promise;
    } else if (typeof clss == "number") {
      return obj === clss;
    } else if (typeof clss == "boolean") {
      return obj === clss;
    } else if (typeof clss == "string") {
      let is = false;

      if (typeof obj == "string") {
        is = obj == clss;
      } else if (obj != null) {
        for (let base = obj.__proto__; base; base = base.__proto__) {
          if (is = base.constructor.name == clss) break;
        }
      }

      return is;
    } else {
      try {
        return obj instanceof clss;
      } catch (e) {
        return false;
      }
    }
  },

  /**
   * is not operator.
   */
  isNot(obj, clss) {
    return !dogma.is(obj, clss);
  },

  /**
   * as operator.
   */
  cast(value, type) {
    return dogma.expect(value ? value.toString() : "nil", value, type);
  },

  /**
   * like operator.
   */
  like(txt, pat) {
    if (pat instanceof Array) {
      for (let p of pat) {
        if (RegExp(p).test(txt)) return true;
      }

      return false;
    } else {
      return RegExp(pat).test(txt);
    }
  },

  /**
   * not like operator.
   */
  notLike(txt, pat) {
    return !dogma.like(txt, pat);
  },

  /**
   * <<< op
   */
  lshift(...args) {
    if (args.length == 1) {
      const arg = args[0];

      if (arg instanceof Array) {
        return arg.splice(0, 1)[0];
      } else {
        throw new TypeError("array expected for working with unary <<< op.");
      }
    } else {
      const [one, two] = args;

      if (one instanceof Set) {
        one.add(two);
        return one;
      } else if (one instanceof Array) {
        one.push(two);
        return one;
      } else {
        return one << two;
      }
    }
  },

  /**
   * >> op
   */
  rshift(...args) {
    if (args.length == 1) {
      const arg = args[0];

      if (arg instanceof Array) {
        return arg.pop();
      } else {
        throw new TypeError("array expected for working with unary >>> op.");
      }
    } else {
      const [one, two] = args;

      if (two instanceof Array) {
        two.splice(0, 0, one);
        return two;
      } else {
        return one >> two;
      }
    }
  },

  /**
   * nop expression.
   */
  nop() {
    return function () {};
  },

  /**
   * Check if a value is an expected type.
   *
   * @param name:string The value name.
   * @param value       The value to check.
   * @param type        The type to check.
   *
   * @return the value when ok.
   */
  expect(name, value, type) {
    return dogma.paramExpected(name, value, type);
  },

  /**
   * Expected to be a value and type.
   *
   * @param name:string Parameter name.
   * @param value       Parameter value.
   * @param type        Parameter type.
   *
   * @return the value when ok.
   */
  paramExpected(name, value, type) {
    if (value === undefined || value === null) throw new TypeError(name + " expected.");
    if (type) this.paramExpectedToBe(name, value, type);
    return value;
  },

  /**
   * A value expected to be of a type.
   */
  paramExpectedToBe(name, value, type) {
    function getTypeNameOf(type) {
      if (type === bool || type === Boolean) return "bool";
      if (type === list || type === Array) return "list";
      if (type === set || type === Set) return "set";
      if (type === map || type === Object) return "map";
      if (type === num || type === Number) return "num";
      if (type === text || type === String) return "text";
      return type.name || text(type);
    }

    if (value !== null && value !== undefined) {
      if (type instanceof Array) {
        let ok = false;

        for (let t of type) if (ok = dogma.is(value, t)) break;

        if (!ok) {
          const types = [];

          for (let t of type) types.push(getTypeNameOf(t));

          throw new TypeError(_util.default.format("'%s' expected to be one of (%s). Received: %s.", name, types.join(", "), typename(value)));
        }
      } else {
        if (!dogma.is(value, type)) {
          throw new TypeError(_util.default.format("'%s' expected to be '%s'. Received: %s.", name, getTypeNameOf(type), typename(value)));
        }
      }
    }

    return value;
  },

  /**
   * A parameter expected to have one or several fields.
   *
   * @param name:string     Parameter name.
   * @param val             Parameter value.
   * @param desc:object     Parameter description. Every parameter: {type, mandatory}.
   * @param mandatory:bool  Is it mandatory?
   */
  paramExpectedToHave(name, val, desc, mandatory = false) {
    if (mandatory) {
      this.paramExpected(name, val, map);
    } else {
      this.paramExpectedToBe(name, val, map);
    }

    if (val) {
      for (let key in desc) {
        const v = val[key],
              d = desc[key];

        if (d.mandatory || v !== null && v !== undefined) {
          this.paramExpected(name + "." + key, v, d.type);
        }
      }
    }
  },

  /**
   * Run an expression in protected mode.
   */
  peval(fn) {
    var ok, res;

    try {
      res = fn();
      ok = true;
    } catch (e) {
      ok = false;
      res = e;
    }

    return [ok, res];
  },

  /**
   * Expression && Expression
   */
  pevalAnd(exp1, exp2) {
    const [ok, res] = dogma.peval(exp1);
    if (ok) return exp2();else throw res;
  },

  /**
   * Expression || Expression
   */
  pevalOr(exp1, exp2) {
    const [ok, res] = dogma.peval(exp1);
    if (ok) return res;else return exp2();
  },

  /**
   * throw() function.
   */
  raise(...args) {
    if (args.length == 1) throw args[0];else throw _util.default.format(...args);
  },

  /**
   * [] operator.
   */
  getItem(coll, ix) {
    return coll[getIx(coll, ix)];
  },

  /**
   * ?[] operator.
   */
  getOptionalItem(coll, ix) {
    if (coll == null) {
      return null;
    } else {
      return coll[getIx(coll, ix)];
    }
  },

  /**
   * []= operator.
   */
  setItem(op, coll, ix, val) {
    ix = getIx(coll, ix);

    switch (op) {
      case "=":
        coll[ix] = val;
        break;

      case "+=":
        coll[ix] += val;
        break;

      case "-=":
        coll[ix] -= val;
        break;

      case "*=":
        coll[ix] *= val;
        break;

      case "**=":
        coll[ix] = Math.pow(coll[ix], val);
        break;

      case "/=":
        coll[ix] /= val;
        break;

      case "%=":
        coll[ix] %= val;
        break;

      case "<<=":
        coll[ix] <<= val;
        break;

      case ">>=":
        coll[ix] >>= val;
        break;

      case "|=":
        coll[ix] |= val;
        break;

      case "&=":
        coll[ix] &= val;
        break;

      case "^=":
        coll[ix] ^= val;
        break;
    }

    return val;
  },

  /**
   * [,] operator.
   */
  getSlice(coll, start, end) {
    return coll.slice(getIx(coll, start), getIx(coll, end) + 1);
  },

  /**
   * obj{*} op.
   */
  clone(obj, fields = {}, rename = [], remove = [], dup = []) {
    var res = (0, _lodash.default)({}, obj); //(1) fields

    for (let [name, value] of Object.entries(fields)) res[name] = value;

    for (let obj of dup) Object.assign(res, obj); //(2) rename


    for (let [name, value] of Object.entries(rename)) {
      res[name] = res[value];
      delete res[value];
    } //(3) remove


    for (let name of remove) delete res[name]; //(4) return


    return res;
  },

  /**
   * obj{**} op.
   */
  copyAndUpdate(obj, fields = {}, rename = [], remove = [], dup = []) {
    var res = dogma.copy(obj); //(1) fields

    for (let [name, value] of Object.entries(fields)) res[name] = value;

    for (let obj of dup) Object.assign(res, obj); //(2) rename


    for (let [name, value] of Object.entries(rename)) {
      res[name] = res[value];
      delete res[value];
    } //(3) remove


    for (let name of remove) delete res[name]; //(4) return


    return res;
  },

  /**
   * obj[*] op·
   */
  cloneL(arr, ...items) {
    var res; //(1) clone

    res = list(arr);

    for (let i of items) res.push(i); //(3) return


    return res;
  },

  /**
   * {field, ...obj}
   */
  pack(obj, ...fields) {
    const res = {}; //(1) pack

    for (let fld of fields) {
      if (typeof fld == "string") {
        res[fld] = obj[fld];
      } else if (fld.name === undefined) {
        Object.assign(res, fld.value);
      } else {
        res[fld.name] = fld.value;
      }
    } //(2) return


    return res;
  },

  /**
   * update op.
   */
  update(obj, ...fields) {
    //(1) update
    for (let fld of fields) {
      if (fld.type == "mapped") {
        //use used {name, name...}=Exp
        for (let name of fld.name) {
          let vname = (fld.visib == "." || fld.visib == "!" ? "" : "_") + name;

          if (fld.assign == "=") {
            obj[vname] = fld.value[name];
          } else if (fld.assign == ":=" || fld.assign == "::=") {
            Object.defineProperty(obj, vname, {
              enum: fld.visib == ".",
              value: fld.value[name]
            });
          } else if (fld.assign == "?=") {
            if (obj[vname] === null || obj[vname] === undefined) obj[vname] = fld.value[name];
          } else if (fld.assign == ".=") {
            Object.defineProperty(obj, "_" + name, {
              value: fld.value[name],
              writable: true
            });
            Object.defineProperty(obj, name, {
              enum: true,

              get() {
                return this["_" + name];
              }

            });
          }
        }
      } else {
        for (let name of fld.name instanceof Array ? fld.name : [fld.name]) {
          let vname = (fld.visib == "." || fld.visib == "!" ? "" : "_") + name;

          if (fld.assign == "=") {
            obj[vname] = fld.value;
          } else if (fld.assign == ":=" || fld.assign == "::=") {
            Object.defineProperty(obj, vname, {
              enum: fld.visib == ".",
              value: fld.value
            });
          } else if (fld.assign == "?=") {
            if (obj[vname] === null || obj[vname] === undefined) obj[vname] = fld.value;
          } else if (fld.assign == ".=") {
            Object.defineProperty(obj, "_" + name, {
              value: fld.value,
              writable: true
            });
            Object.defineProperty(obj, name, {
              enum: true,

              get() {
                return this["_" + name];
              }

            });
          }
        }
      }
    } //(2) return


    return obj;
  },

  /**
   * Return array for [...] = val.
   */
  getArrayToUnpack(val, size) {
    if (!(val instanceof Array)) val = Array(size).fill(val);
    return val;
  },

  /**
   * Returnt default member or the object passed as argument.
   */
  use(mod) {
    if (mod != null && mod !== undefined) {
      if ("default" in mod) mod = mod.default;
    }

    return mod;
  },

  /**
   * in op.
   */
  includes(coll, item) {
    if (coll && coll.includes) return coll.includes(item);else if (coll instanceof Set) return coll.has(item);else if (typeof coll == "object" && coll != null) return item in coll;else return false;
  }

};
/**
 * Return the positive index for a collection.
 */

exports.dogma = dogma;

function getIx(coll, ix) {
  if (typeof ix == "number" && ix < 0) {
    let aux = ix;
    ix = len(coll) - Math.abs(ix);
    if (ix < 0) ix = aux;
  }

  return ix;
}
/**
 * An interface definition.
 */


class Intf {
  /**
   * Constructor.
   *
   * @param name:string   The interface name.
   * @param fields:object The field definitions.
   */
  constructor(name, fields) {
    Object.defineProperty(this, "name", {
      value: name,
      writable: false,
      enumerable: true
    });
    Object.defineProperty(this, "fields", {
      value: fields,
      writable: false,
      enumerable: true
    });
  }
  /**
   * Check whether an object complies wuith the interface.
   *
   * @param obj:object  The object to check.
   * @return true or false.
   */


  comply(obj) {
    //(1) check
    var ok = false;

    if (obj instanceof Object) {
      ok = true;

      for (const [name, def] of Object.entries(this.fields)) {
        const val = obj[name];

        if (val == null) {
          if (!def.optional) {
            ok = false;
            break;
          }
        } else {
          try {
            expect(name, val, def.type);
          } catch (_) {
            ok = false;
            break;
          }
        }
      }
    } //(2) return


    return ok;
  }

}